
;;; All the macros and the scheme-object printing procedure
;;; are defined in compiler.s
%include "compiler.s"

section .bss
;;; This pointer is used to manage allocations on our heap.
malloc_pointer:
    resq 1

section .data
const_tbl:
MAKE_NIL
MAKE_VOID
MAKE_BOOL(1)
MAKE_BOOL(0)
MAKE_LITERAL_STRING 8, "whatever"
MAKE_LITERAL_SYMBOL(const_tbl+6)
MAKE_LITERAL_INT(0)
MAKE_LITERAL_INT(1)
MAKE_LITERAL_CHAR(0)
MAKE_LITERAL_INT(2)

;;; These macro definitions are required for the primitive
;;; definitions in the epilogue to work properly
%define SOB_VOID_ADDRESS const_tbl+1
%define SOB_NIL_ADDRESS const_tbl+0
%define SOB_FALSE_ADDRESS const_tbl+4
%define SOB_TRUE_ADDRESS const_tbl+2

fvar_tbl:
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED
dq T_UNDEFINED

global main
section .text
main:
    push rbp

    ;; set up the heap
    mov rdi, GB(4)
    call malloc
    mov [malloc_pointer], rax

    ;; Set up the dummy activation frame
    ;; The dummy return address is T_UNDEFINED
    ;; (which a is a macro for 0) so that returning
    ;; from the top level (which SHOULD NOT HAPPEN
    ;; AND IS A BUG) will cause a segfault.
    push 0
    push qword SOB_NIL_ADDRESS
    push qword T_UNDEFINED
    push rsp

    mov rbp,rsp


    ;; Set up the primitive stdlib fvars:
    ;; Since the primtive procedures are defined in assembly,
    ;; they are not generated by scheme (define ...) expressions.
    ;; This is where we emulate the missing (define ...) expressions
    ;; for all the primitive procedures.
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, is_boolean)
    mov [fvar_tbl +0* WORD_SIZE], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, is_float)
    mov [fvar_tbl +1* WORD_SIZE], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, is_integer)
    mov [fvar_tbl +2* WORD_SIZE], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, is_pair)
    mov [fvar_tbl +3* WORD_SIZE], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, is_null)
    mov [fvar_tbl +4* WORD_SIZE], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, is_char)
    mov [fvar_tbl +5* WORD_SIZE], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, is_string)
    mov [fvar_tbl +6* WORD_SIZE], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, is_procedure)
    mov [fvar_tbl +7* WORD_SIZE], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, is_symbol)
    mov [fvar_tbl +8* WORD_SIZE], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, string_length)
    mov [fvar_tbl +9* WORD_SIZE], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, string_ref)
    mov [fvar_tbl +10* WORD_SIZE], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, string_set)
    mov [fvar_tbl +11* WORD_SIZE], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, make_string)
    mov [fvar_tbl +12* WORD_SIZE], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, symbol_to_string)
    mov [fvar_tbl +13* WORD_SIZE], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, char_to_integer)
    mov [fvar_tbl +14* WORD_SIZE], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, integer_to_char)
    mov [fvar_tbl +15* WORD_SIZE], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, is_eq)
    mov [fvar_tbl +16* WORD_SIZE], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, bin_add)
    mov [fvar_tbl +17* WORD_SIZE], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, bin_mul)
    mov [fvar_tbl +18* WORD_SIZE], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, bin_sub)
    mov [fvar_tbl +19* WORD_SIZE], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, bin_div)
    mov [fvar_tbl +20* WORD_SIZE], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, bin_lt)
    mov [fvar_tbl +21* WORD_SIZE], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, bin_equ)
    mov [fvar_tbl +22* WORD_SIZE], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, car_)
    mov [fvar_tbl +23* WORD_SIZE], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, cdr_)
    mov [fvar_tbl +24* WORD_SIZE], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, cons_)
    mov [fvar_tbl +25* WORD_SIZE], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, set_car)
    mov [fvar_tbl +26* WORD_SIZE], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, set_cdr)
    mov [fvar_tbl +27* WORD_SIZE], rax
    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, apply_)
    mov [fvar_tbl +28* WORD_SIZE], rax


some_compiled_section10:
;define:
; 
; lambda optional: 
mov rbx, 0
shl rbx, 3
MALLOC rax, rbx
push rax ; pushing ext_env for later 
;copying pointers:
mov rcx, 0
cmp rcx, 1
jle end_pointers_copy2
copy_pointers0:
push rcx
neg rcx
add rcx, 0
mov rbx, [rbp + WORD_SIZE * 2] ; getting pointer to old env
mov rdx, [rbx + rcx * WORD_SIZE] ; getting to rdx old_env[i]
inc rcx
mov [rax + WORD_SIZE * rcx], rdx ; putting env[i] (stored in rdx) into ext_env[i + 1]
pop rcx ; restoring counter
loop copy_pointers0
end_pointers_copy2:
mov rcx, [rbp + 3 * WORD_SIZE] ; getting to rcx the number of the current parameters 
inc rcx
shl rcx, 3
MALLOC rbx, rcx
mov qword [rax], rbx ; getting the new allocated memory pointer to ext_env[0]
mov rax, rbx ; more convinient with pointer to extenv[0] in rax 

mov rbx, rcx ; rbx will be constant and hold the size of params
; copying parameters to new env 
cmp rbx, 0
je end_parameters_copy3
copy_parameters1: 
push rcx
neg rcx
add rcx, rbx ; rcx starts high and decreases with iterations
lea rdx, [rbp + WORD_SIZE * rcx]
add rdx, 4 * WORD_SIZE ; now rdx has the address of param_i 
mov rdx, [rdx] ; now rdx has the param_i 
mov [rax + WORD_SIZE * rcx], rdx 
pop rcx
loop copy_parameters1
end_parameters_copy3:
pop rbx
MAKE_CLOSURE(rax, rbx, Lcode4)
jmp Lcont5
Lcode4: 
push rbp
mov rbp, rsp
mov rax, [rbp + WORD_SIZE * 3] ; rax <- n 
cmp rax, 0; n =? |must|
jne opt_list_creation7
lea rbx, [rbp + WORD_SIZE * (rax + 4)] ; magic <- Nil
mov qword [rbx], const_tbl
jmp actual_code6
opt_list_creation7:
mov rbx, const_tbl
dec rax ; rax <- n - 1
make_list_loop8: ; create list loop 
mov rcx, [rbp + WORD_SIZE * (4 + rax)] ; rcx <- params[i]
MAKE_PAIR(rdx, rcx, rbx)
mov rbx, rdx
dec rax
cmp rax, 0
jge make_list_loop8
mov rax, [rbp + WORD_SIZE * 3]
dec rax; rax <- n - 1
mov [rbp + WORD_SIZE * (4 + rax)], rbx; save optional list on the stack
sub rax, 0 ; constant rax <- n - 1 - |must| (offset to move)
jz actual_code6
lea rcx, [4 + 0] ; i <- must_length + 4 
stack_reduction9:

push rcx
dec rcx
mov rbx, [rbp + WORD_SIZE * rcx]
add rcx, rax
mov [rbp + WORD_SIZE * rcx], rbx
pop rcx
loop stack_reduction9
lea rsp, [rsp + WORD_SIZE * rax]
mov rbp, rsp
mov qword [rbp + WORD_SIZE * 3], 0
actual_code6:
;parameter variable:
mov rax, [rbp + WORD_SIZE * (4 + 0)]

leave
ret
Lcont5: 
mov [fvar_tbl + 52 * WORD_SIZE], rax 
 lea rax, [const_tbl+1] 

	call write_sob_if_not_void

some_compiled_section53:
;define:
;applic:applic11
;push magic:
mov rbx, 0
push rbx
;free variable:
mov rax, qword [fvar_tbl + 28 * WORD_SIZE]

push rax
;free variable:
mov rax, qword [fvar_tbl + 25 * WORD_SIZE]

push rax
;free variable:
mov rax, qword [fvar_tbl + 24 * WORD_SIZE]

push rax
;free variable:
mov rax, qword [fvar_tbl + 23 * WORD_SIZE]

push rax
;free variable:
mov rax, qword [fvar_tbl + 4 * WORD_SIZE]

push rax
;back to applic: applic11
;push num of args: 
mov rbx,5
push rbx
;generate proc:
;simple lambda:
mov rbx, 0
shl rbx, 3
MALLOC rax, rbx
push rax; pushing ext_env for later 
;copying pointers:
mov rcx, 0
cmp rcx, 1
jle end_pointers_copy14
copy_pointers12:
push rcx
neg rcx
add rcx, 0
mov rbx, [rbp + WORD_SIZE * 2] ; getting pointer to old env
mov rdx, [rbx + rcx * WORD_SIZE] ; getting to rdx old_env[i]
inc rcx
mov [rax + WORD_SIZE * rcx], rdx ; putting env[i] (stored in rdx) into ext_env[i + 1]
pop rcx ; restoring counter
loop copy_pointers12
end_pointers_copy14:
mov rcx, [rbp + 3 * WORD_SIZE] ; getting to rcx the number of the current parameters 
inc rcx
shl rcx, 3
MALLOC rbx, rcx
mov qword [rax], rbx ; getting the new allocated memory pointer to ext_env[0]
mov rax, rbx ; more convinient with pointer to extenv[0] in rax 

mov rbx, rcx ; rbx will be constant and hold the size of params
; copying parameters to new env 
cmp rbx, 0
je end_parameters_copy15
copy_parameters13: 
push rcx
neg rcx
add rcx, rbx ; rcx starts high and decreases with iterations
lea rdx, [rbp + WORD_SIZE * rcx]
add rdx, 4 * WORD_SIZE ; now rdx has the address of param_i 
mov rdx, [rdx] ; now rdx has the param_i 
mov [rax + WORD_SIZE * rcx], rdx 
pop rcx
loop copy_parameters13
end_parameters_copy15:
pop rbx
MAKE_CLOSURE(rax, rbx, Lcode16)
jmp Lcont17
Lcode16: 
push rbp
mov rbp, rsp
;applicTp:
;constant
lea rax, [const_tbl+ 23]

push rax
;push num of args: 
mov rbx,1
push rbx
;generate proc:
;simple lambda:
mov rbx, 1
shl rbx, 3
MALLOC rax, rbx
push rax; pushing ext_env for later 
;copying pointers:
mov rcx, 1
cmp rcx, 1
jle end_pointers_copy21
copy_pointers19:
push rcx
neg rcx
add rcx, 1
mov rbx, [rbp + WORD_SIZE * 2] ; getting pointer to old env
mov rdx, [rbx + rcx * WORD_SIZE] ; getting to rdx old_env[i]
inc rcx
mov [rax + WORD_SIZE * rcx], rdx ; putting env[i] (stored in rdx) into ext_env[i + 1]
pop rcx ; restoring counter
loop copy_pointers19
end_pointers_copy21:
mov rcx, [rbp + 3 * WORD_SIZE] ; getting to rcx the number of the current parameters 
inc rcx
shl rcx, 3
MALLOC rbx, rcx
mov qword [rax], rbx ; getting the new allocated memory pointer to ext_env[0]
mov rax, rbx ; more convinient with pointer to extenv[0] in rax 

mov rbx, rcx ; rbx will be constant and hold the size of params
; copying parameters to new env 
cmp rbx, 0
je end_parameters_copy22
copy_parameters20: 
push rcx
neg rcx
add rcx, rbx ; rcx starts high and decreases with iterations
lea rdx, [rbp + WORD_SIZE * rcx]
add rdx, 4 * WORD_SIZE ; now rdx has the address of param_i 
mov rdx, [rdx] ; now rdx has the param_i 
mov [rax + WORD_SIZE * rcx], rdx 
pop rcx
loop copy_parameters20
end_parameters_copy22:
pop rbx
MAKE_CLOSURE(rax, rbx, Lcode23)
jmp Lcont24
Lcode23: 
push rbp
mov rbp, rsp
;sequence:
;set:
; Box:
lea rcx, [4 + 0]
MALLOC rax, WORD_SIZE
mov rbx, [rbp + WORD_SIZE * rcx]
mov [rax], rbx

mov qword [rbp + WORD_SIZE * (4 + 0)], rax
mov rax, SOB_VOID_ADDRESS 

;sequence:
;box set:
; , f, l
; lambda optional: 
mov rbx, 2
shl rbx, 3
MALLOC rax, rbx
push rax ; pushing ext_env for later 
;copying pointers:
mov rcx, 2
cmp rcx, 1
jle end_pointers_copy27
copy_pointers25:
push rcx
neg rcx
add rcx, 2
mov rbx, [rbp + WORD_SIZE * 2] ; getting pointer to old env
mov rdx, [rbx + rcx * WORD_SIZE] ; getting to rdx old_env[i]
inc rcx
mov [rax + WORD_SIZE * rcx], rdx ; putting env[i] (stored in rdx) into ext_env[i + 1]
pop rcx ; restoring counter
loop copy_pointers25
end_pointers_copy27:
mov rcx, [rbp + 3 * WORD_SIZE] ; getting to rcx the number of the current parameters 
inc rcx
shl rcx, 3
MALLOC rbx, rcx
mov qword [rax], rbx ; getting the new allocated memory pointer to ext_env[0]
mov rax, rbx ; more convinient with pointer to extenv[0] in rax 

mov rbx, rcx ; rbx will be constant and hold the size of params
; copying parameters to new env 
cmp rbx, 0
je end_parameters_copy28
copy_parameters26: 
push rcx
neg rcx
add rcx, rbx ; rcx starts high and decreases with iterations
lea rdx, [rbp + WORD_SIZE * rcx]
add rdx, 4 * WORD_SIZE ; now rdx has the address of param_i 
mov rdx, [rdx] ; now rdx has the param_i 
mov [rax + WORD_SIZE * rcx], rdx 
pop rcx
loop copy_parameters26
end_parameters_copy28:
pop rbx
MAKE_CLOSURE(rax, rbx, Lcode29)
jmp Lcont30
Lcode29: 
push rbp
mov rbp, rsp
mov rax, [rbp + WORD_SIZE * 3] ; rax <- n 
cmp rax, 2; n =? |must|
jne opt_list_creation32
lea rbx, [rbp + WORD_SIZE * (rax + 4)] ; magic <- Nil
mov qword [rbx], const_tbl
jmp actual_code31
opt_list_creation32:
mov rbx, const_tbl
dec rax ; rax <- n - 1
make_list_loop33: ; create list loop 
mov rcx, [rbp + WORD_SIZE * (4 + rax)] ; rcx <- params[i]
MAKE_PAIR(rdx, rcx, rbx)
mov rbx, rdx
dec rax
cmp rax, 2
jge make_list_loop33
mov rax, [rbp + WORD_SIZE * 3]
dec rax; rax <- n - 1
mov [rbp + WORD_SIZE * (4 + rax)], rbx; save optional list on the stack
sub rax, 2 ; constant rax <- n - 1 - |must| (offset to move)
jz actual_code31
lea rcx, [4 + 2] ; i <- must_length + 4 
stack_reduction34:

push rcx
dec rcx
mov rbx, [rbp + WORD_SIZE * rcx]
add rcx, rax
mov [rbp + WORD_SIZE * rcx], rbx
pop rcx
loop stack_reduction34
lea rsp, [rsp + WORD_SIZE * rax]
mov rbp, rsp
mov qword [rbp + WORD_SIZE * 3], 2
actual_code31:
;if:
;applic:applic52
;push magic:
mov rbx, 0
push rbx
;parameter variable:
mov rax, [rbp + WORD_SIZE * (4 + 1)]

push rax
;back to applic: applic52
;push num of args: 
mov rbx,1
push rbx
;generate proc:
;bound variable:
mov rbx, [rbp + WORD_SIZE * 2]
mov rbx, [rbx + WORD_SIZE * 1]
mov rax, [rbx + WORD_SIZE * 0]

;back to applic: applic52
;assuming we get correct input, no need to check type closure 
CLOSURE_ENV rbx, rax ;rbx contains pointer to env
push rbx      ;push env pointer
CLOSURE_CODE rbx, rax 
call rbx
;clean stack
add rsp, WORD_SIZE *1 ; pop env
pop rbx               ; pop arg count
shl rbx, 3            ; rbx = rbx * 8
add rbx, WORD_SIZE    ; clean magic
add rsp, rbx          ; pop args

 cmp rax, SOB_FALSE_ADDRESS 
 je Lelse36 
;constant
lea rax, [const_tbl+ 0]

 jmp Lexit35 
 Lelse36:
;if:
;applic:applic51
;push magic:
mov rbx, 0
push rbx
;parameter variable:
mov rax, [rbp + WORD_SIZE * (4 + 2)]

push rax
;back to applic: applic51
;push num of args: 
mov rbx,1
push rbx
;generate proc:
;bound variable:
mov rbx, [rbp + WORD_SIZE * 2]
mov rbx, [rbx + WORD_SIZE * 1]
mov rax, [rbx + WORD_SIZE * 0]

;back to applic: applic51
;assuming we get correct input, no need to check type closure 
CLOSURE_ENV rbx, rax ;rbx contains pointer to env
push rbx      ;push env pointer
CLOSURE_CODE rbx, rax 
call rbx
;clean stack
add rsp, WORD_SIZE *1 ; pop env
pop rbx               ; pop arg count
shl rbx, 3            ; rbx = rbx * 8
add rbx, WORD_SIZE    ; clean magic
add rsp, rbx          ; pop args

 cmp rax, SOB_FALSE_ADDRESS 
 je Lelse38 
;applicTp:
;applic:applic47
;push magic:
mov rbx, 0
push rbx
;applic:applic48
;push magic:
mov rbx, 0
push rbx
;parameter variable:
mov rax, [rbp + WORD_SIZE * (4 + 1)]

push rax
;back to applic: applic48
;push num of args: 
mov rbx,1
push rbx
;generate proc:
;bound variable:
mov rbx, [rbp + WORD_SIZE * 2]
mov rbx, [rbx + WORD_SIZE * 1]
mov rax, [rbx + WORD_SIZE * 2]

;back to applic: applic48
;assuming we get correct input, no need to check type closure 
CLOSURE_ENV rbx, rax ;rbx contains pointer to env
push rbx      ;push env pointer
CLOSURE_CODE rbx, rax 
call rbx
;clean stack
add rsp, WORD_SIZE *1 ; pop env
pop rbx               ; pop arg count
shl rbx, 3            ; rbx = rbx * 8
add rbx, WORD_SIZE    ; clean magic
add rsp, rbx          ; pop args

push rax
;parameter variable:
mov rax, [rbp + WORD_SIZE * (4 + 0)]

push rax
;back to applic: applic47
;push num of args: 
mov rbx,2
push rbx
;generate proc:
;box get:
;bound variable:
mov rbx, [rbp + WORD_SIZE * 2]
mov rbx, [rbx + WORD_SIZE * 0]
mov rax, [rbx + WORD_SIZE * 0]

mov qword rax, [rax]

;back to applic: applic47
;assuming we get correct input, no need to check type closure 
CLOSURE_ENV rbx, rax ;rbx contains pointer to env
push rbx      ;push env pointer
CLOSURE_CODE rbx, rax 
call rbx
;clean stack
add rsp, WORD_SIZE *1 ; pop env
pop rbx               ; pop arg count
shl rbx, 3            ; rbx = rbx * 8
add rbx, WORD_SIZE    ; clean magic
add rsp, rbx          ; pop args

push rax
;applic:applic49
;push magic:
mov rbx, 0
push rbx
;applic:applic50
;push magic:
mov rbx, 0
push rbx
;parameter variable:
mov rax, [rbp + WORD_SIZE * (4 + 1)]

push rax
;back to applic: applic50
;push num of args: 
mov rbx,1
push rbx
;generate proc:
;bound variable:
mov rbx, [rbp + WORD_SIZE * 2]
mov rbx, [rbx + WORD_SIZE * 1]
mov rax, [rbx + WORD_SIZE * 1]

;back to applic: applic50
;assuming we get correct input, no need to check type closure 
CLOSURE_ENV rbx, rax ;rbx contains pointer to env
push rbx      ;push env pointer
CLOSURE_CODE rbx, rax 
call rbx
;clean stack
add rsp, WORD_SIZE *1 ; pop env
pop rbx               ; pop arg count
shl rbx, 3            ; rbx = rbx * 8
add rbx, WORD_SIZE    ; clean magic
add rsp, rbx          ; pop args

push rax
;back to applic: applic49
;push num of args: 
mov rbx,1
push rbx
;generate proc:
;parameter variable:
mov rax, [rbp + WORD_SIZE * (4 + 0)]

;back to applic: applic49
;assuming we get correct input, no need to check type closure 
CLOSURE_ENV rbx, rax ;rbx contains pointer to env
push rbx      ;push env pointer
CLOSURE_CODE rbx, rax 
call rbx
;clean stack
add rsp, WORD_SIZE *1 ; pop env
pop rbx               ; pop arg count
shl rbx, 3            ; rbx = rbx * 8
add rbx, WORD_SIZE    ; clean magic
add rsp, rbx          ; pop args

push rax
;push num of args: 
mov rbx,2
push rbx
;generate proc:
;bound variable:
mov rbx, [rbp + WORD_SIZE * 2]
mov rbx, [rbx + WORD_SIZE * 1]
mov rax, [rbx + WORD_SIZE * 3]

;assuming we get correct input, no need to check type closure 
add rax, TYPE_SIZE 
mov rbx, [rax] ;rbx contains pointer to env
push rbx      ;push env pointer
add rax, WORD_SIZE 
mov rbx, [rax] ;rbx contains pointer to code ; (rbx contains pointer to code)
;------------------------changes in opt - do not use rbx ---------------------
push qword [rbp + WORD_SIZE ] ; push old ret addr
; lets get to rax the dst to copy
mov rax, [rbp + WORD_SIZE * 3]
mov r9, [rbp]
add rax, 3
shl rax, 3
add rax, rbp
; lets get to rdx the src to copy
mov rdx, [rsp + WORD_SIZE * 2]
mov r10, rdx
add rdx, 2
shl rdx, 3
add rdx, rsp
; lets get to rcx the number of iterations needed
lea rcx, [r10 + 3]
copy_stack46:

mov r11, [rdx]
mov [rax], r11
sub rax, 8
sub rdx, 8
loop copy_stack46
add rax, 8
mov rsp, rax
mov rbp, r9
jmp rbx
 jmp Lexit37 
 Lelse38:
;applicTp:
;applic:applic40
;push magic:
mov rbx, 0
push rbx
;applic:applic41
;push magic:
mov rbx, 0
push rbx
;parameter variable:
mov rax, [rbp + WORD_SIZE * (4 + 2)]

push rax
;bound variable:
mov rbx, [rbp + WORD_SIZE * 2]
mov rbx, [rbx + WORD_SIZE * 1]
mov rax, [rbx + WORD_SIZE * 2]

push rax
;back to applic: applic41
;push num of args: 
mov rbx,2
push rbx
;generate proc:
;box get:
;bound variable:
mov rbx, [rbp + WORD_SIZE * 2]
mov rbx, [rbx + WORD_SIZE * 0]
mov rax, [rbx + WORD_SIZE * 0]

mov qword rax, [rax]

;back to applic: applic41
;assuming we get correct input, no need to check type closure 
CLOSURE_ENV rbx, rax ;rbx contains pointer to env
push rbx      ;push env pointer
CLOSURE_CODE rbx, rax 
call rbx
;clean stack
add rsp, WORD_SIZE *1 ; pop env
pop rbx               ; pop arg count
shl rbx, 3            ; rbx = rbx * 8
add rbx, WORD_SIZE    ; clean magic
add rsp, rbx          ; pop args

push rax
;applic:applic42
;push magic:
mov rbx, 0
push rbx
;parameter variable:
mov rax, [rbp + WORD_SIZE * (4 + 1)]

push rax
;back to applic: applic42
;push num of args: 
mov rbx,1
push rbx
;generate proc:
;bound variable:
mov rbx, [rbp + WORD_SIZE * 2]
mov rbx, [rbx + WORD_SIZE * 1]
mov rax, [rbx + WORD_SIZE * 2]

;back to applic: applic42
;assuming we get correct input, no need to check type closure 
CLOSURE_ENV rbx, rax ;rbx contains pointer to env
push rbx      ;push env pointer
CLOSURE_CODE rbx, rax 
call rbx
;clean stack
add rsp, WORD_SIZE *1 ; pop env
pop rbx               ; pop arg count
shl rbx, 3            ; rbx = rbx * 8
add rbx, WORD_SIZE    ; clean magic
add rsp, rbx          ; pop args

push rax
;parameter variable:
mov rax, [rbp + WORD_SIZE * (4 + 0)]

push rax
;free variable:
mov rax, qword [fvar_tbl + 55 * WORD_SIZE]

push rax
;back to applic: applic40
;push num of args: 
mov rbx,4
push rbx
;generate proc:
;bound variable:
mov rbx, [rbp + WORD_SIZE * 2]
mov rbx, [rbx + WORD_SIZE * 1]
mov rax, [rbx + WORD_SIZE * 4]

;back to applic: applic40
;assuming we get correct input, no need to check type closure 
CLOSURE_ENV rbx, rax ;rbx contains pointer to env
push rbx      ;push env pointer
CLOSURE_CODE rbx, rax 
call rbx
;clean stack
add rsp, WORD_SIZE *1 ; pop env
pop rbx               ; pop arg count
shl rbx, 3            ; rbx = rbx * 8
add rbx, WORD_SIZE    ; clean magic
add rsp, rbx          ; pop args

push rax
;applic:applic43
;push magic:
mov rbx, 0
push rbx
;applic:applic44
;push magic:
mov rbx, 0
push rbx
;parameter variable:
mov rax, [rbp + WORD_SIZE * (4 + 2)]

push rax
;bound variable:
mov rbx, [rbp + WORD_SIZE * 2]
mov rbx, [rbx + WORD_SIZE * 1]
mov rax, [rbx + WORD_SIZE * 1]

push rax
;back to applic: applic44
;push num of args: 
mov rbx,2
push rbx
;generate proc:
;box get:
;bound variable:
mov rbx, [rbp + WORD_SIZE * 2]
mov rbx, [rbx + WORD_SIZE * 0]
mov rax, [rbx + WORD_SIZE * 0]

mov qword rax, [rax]

;back to applic: applic44
;assuming we get correct input, no need to check type closure 
CLOSURE_ENV rbx, rax ;rbx contains pointer to env
push rbx      ;push env pointer
CLOSURE_CODE rbx, rax 
call rbx
;clean stack
add rsp, WORD_SIZE *1 ; pop env
pop rbx               ; pop arg count
shl rbx, 3            ; rbx = rbx * 8
add rbx, WORD_SIZE    ; clean magic
add rsp, rbx          ; pop args

push rax
;applic:applic45
;push magic:
mov rbx, 0
push rbx
;parameter variable:
mov rax, [rbp + WORD_SIZE * (4 + 1)]

push rax
;back to applic: applic45
;push num of args: 
mov rbx,1
push rbx
;generate proc:
;bound variable:
mov rbx, [rbp + WORD_SIZE * 2]
mov rbx, [rbx + WORD_SIZE * 1]
mov rax, [rbx + WORD_SIZE * 1]

;back to applic: applic45
;assuming we get correct input, no need to check type closure 
CLOSURE_ENV rbx, rax ;rbx contains pointer to env
push rbx      ;push env pointer
CLOSURE_CODE rbx, rax 
call rbx
;clean stack
add rsp, WORD_SIZE *1 ; pop env
pop rbx               ; pop arg count
shl rbx, 3            ; rbx = rbx * 8
add rbx, WORD_SIZE    ; clean magic
add rsp, rbx          ; pop args

push rax
;parameter variable:
mov rax, [rbp + WORD_SIZE * (4 + 0)]

push rax
;back to applic: applic43
;push num of args: 
mov rbx,3
push rbx
;generate proc:
;bound variable:
mov rbx, [rbp + WORD_SIZE * 2]
mov rbx, [rbx + WORD_SIZE * 1]
mov rax, [rbx + WORD_SIZE * 4]

;back to applic: applic43
;assuming we get correct input, no need to check type closure 
CLOSURE_ENV rbx, rax ;rbx contains pointer to env
push rbx      ;push env pointer
CLOSURE_CODE rbx, rax 
call rbx
;clean stack
add rsp, WORD_SIZE *1 ; pop env
pop rbx               ; pop arg count
shl rbx, 3            ; rbx = rbx * 8
add rbx, WORD_SIZE    ; clean magic
add rsp, rbx          ; pop args

push rax
;push num of args: 
mov rbx,2
push rbx
;generate proc:
;bound variable:
mov rbx, [rbp + WORD_SIZE * 2]
mov rbx, [rbx + WORD_SIZE * 1]
mov rax, [rbx + WORD_SIZE * 3]

;assuming we get correct input, no need to check type closure 
add rax, TYPE_SIZE 
mov rbx, [rax] ;rbx contains pointer to env
push rbx      ;push env pointer
add rax, WORD_SIZE 
mov rbx, [rax] ;rbx contains pointer to code ; (rbx contains pointer to code)
;------------------------changes in opt - do not use rbx ---------------------
push qword [rbp + WORD_SIZE ] ; push old ret addr
; lets get to rax the dst to copy
mov rax, [rbp + WORD_SIZE * 3]
mov r9, [rbp]
add rax, 3
shl rax, 3
add rax, rbp
; lets get to rdx the src to copy
mov rdx, [rsp + WORD_SIZE * 2]
mov r10, rdx
add rdx, 2
shl rdx, 3
add rdx, rsp
; lets get to rcx the number of iterations needed
lea rcx, [r10 + 3]
copy_stack39:

mov r11, [rdx]
mov [rax], r11
sub rax, 8
sub rdx, 8
loop copy_stack39
add rax, 8
mov rsp, rax
mov rbp, r9
jmp rbx
 Lexit37: 

 Lexit35: 

leave
ret
Lcont30: 

push rax
;parameter variable:
mov rax, [rbp + WORD_SIZE * (4 + 0)]

pop rbx
mov qword [rax], rbx
;box get:
;parameter variable:
mov rax, [rbp + WORD_SIZE * (4 + 0)]

mov qword rax, [rax]



leave
ret
Lcont24: 

;assuming we get correct input, no need to check type closure 
add rax, TYPE_SIZE 
mov rbx, [rax] ;rbx contains pointer to env
push rbx      ;push env pointer
add rax, WORD_SIZE 
mov rbx, [rax] ;rbx contains pointer to code ; (rbx contains pointer to code)
;------------------------changes in opt - do not use rbx ---------------------
push qword [rbp + WORD_SIZE ] ; push old ret addr
; lets get to rax the dst to copy
mov rax, [rbp + WORD_SIZE * 3]
mov r9, [rbp]
add rax, 3
shl rax, 3
add rax, rbp
; lets get to rdx the src to copy
mov rdx, [rsp + WORD_SIZE * 2]
mov r10, rdx
add rdx, 2
shl rdx, 3
add rdx, rsp
; lets get to rcx the number of iterations needed
lea rcx, [r10 + 3]
copy_stack18:

mov r11, [rdx]
mov [rax], r11
sub rax, 8
sub rdx, 8
loop copy_stack18
add rax, 8
mov rsp, rax
mov rbp, r9
jmp rbx
leave
ret
Lcont17: 

;back to applic: applic11
;assuming we get correct input, no need to check type closure 
CLOSURE_ENV rbx, rax ;rbx contains pointer to env
push rbx      ;push env pointer
CLOSURE_CODE rbx, rax 
call rbx
;clean stack
add rsp, WORD_SIZE *1 ; pop env
pop rbx               ; pop arg count
shl rbx, 3            ; rbx = rbx * 8
add rbx, WORD_SIZE    ; clean magic
add rsp, rbx          ; pop args
mov [fvar_tbl + 55 * WORD_SIZE], rax 
 lea rax, [const_tbl+1] 

	call write_sob_if_not_void

some_compiled_section74:
;define:
;applic:applic54
;push magic:
mov rbx, 0
push rbx
;free variable:
mov rax, qword [fvar_tbl + 24 * WORD_SIZE]

push rax
;free variable:
mov rax, qword [fvar_tbl + 23 * WORD_SIZE]

push rax
;free variable:
mov rax, qword [fvar_tbl + 4 * WORD_SIZE]

push rax
;back to applic: applic54
;push num of args: 
mov rbx,3
push rbx
;generate proc:
;simple lambda:
mov rbx, 0
shl rbx, 3
MALLOC rax, rbx
push rax; pushing ext_env for later 
;copying pointers:
mov rcx, 0
cmp rcx, 1
jle end_pointers_copy57
copy_pointers55:
push rcx
neg rcx
add rcx, 0
mov rbx, [rbp + WORD_SIZE * 2] ; getting pointer to old env
mov rdx, [rbx + rcx * WORD_SIZE] ; getting to rdx old_env[i]
inc rcx
mov [rax + WORD_SIZE * rcx], rdx ; putting env[i] (stored in rdx) into ext_env[i + 1]
pop rcx ; restoring counter
loop copy_pointers55
end_pointers_copy57:
mov rcx, [rbp + 3 * WORD_SIZE] ; getting to rcx the number of the current parameters 
inc rcx
shl rcx, 3
MALLOC rbx, rcx
mov qword [rax], rbx ; getting the new allocated memory pointer to ext_env[0]
mov rax, rbx ; more convinient with pointer to extenv[0] in rax 

mov rbx, rcx ; rbx will be constant and hold the size of params
; copying parameters to new env 
cmp rbx, 0
je end_parameters_copy58
copy_parameters56: 
push rcx
neg rcx
add rcx, rbx ; rcx starts high and decreases with iterations
lea rdx, [rbp + WORD_SIZE * rcx]
add rdx, 4 * WORD_SIZE ; now rdx has the address of param_i 
mov rdx, [rdx] ; now rdx has the param_i 
mov [rax + WORD_SIZE * rcx], rdx 
pop rcx
loop copy_parameters56
end_parameters_copy58:
pop rbx
MAKE_CLOSURE(rax, rbx, Lcode59)
jmp Lcont60
Lcode59: 
push rbp
mov rbp, rsp
;simple lambda:
mov rbx, 1
shl rbx, 3
MALLOC rax, rbx
push rax; pushing ext_env for later 
;copying pointers:
mov rcx, 1
cmp rcx, 1
jle end_pointers_copy63
copy_pointers61:
push rcx
neg rcx
add rcx, 1
mov rbx, [rbp + WORD_SIZE * 2] ; getting pointer to old env
mov rdx, [rbx + rcx * WORD_SIZE] ; getting to rdx old_env[i]
inc rcx
mov [rax + WORD_SIZE * rcx], rdx ; putting env[i] (stored in rdx) into ext_env[i + 1]
pop rcx ; restoring counter
loop copy_pointers61
end_pointers_copy63:
mov rcx, [rbp + 3 * WORD_SIZE] ; getting to rcx the number of the current parameters 
inc rcx
shl rcx, 3
MALLOC rbx, rcx
mov qword [rax], rbx ; getting the new allocated memory pointer to ext_env[0]
mov rax, rbx ; more convinient with pointer to extenv[0] in rax 

mov rbx, rcx ; rbx will be constant and hold the size of params
; copying parameters to new env 
cmp rbx, 0
je end_parameters_copy64
copy_parameters62: 
push rcx
neg rcx
add rcx, rbx ; rcx starts high and decreases with iterations
lea rdx, [rbp + WORD_SIZE * rcx]
add rdx, 4 * WORD_SIZE ; now rdx has the address of param_i 
mov rdx, [rdx] ; now rdx has the param_i 
mov [rax + WORD_SIZE * rcx], rdx 
pop rcx
loop copy_parameters62
end_parameters_copy64:
pop rbx
MAKE_CLOSURE(rax, rbx, Lcode65)
jmp Lcont66
Lcode65: 
push rbp
mov rbp, rsp
;if:
;applic:applic73
;push magic:
mov rbx, 0
push rbx
;parameter variable:
mov rax, [rbp + WORD_SIZE * (4 + 2)]

push rax
;back to applic: applic73
;push num of args: 
mov rbx,1
push rbx
;generate proc:
;bound variable:
mov rbx, [rbp + WORD_SIZE * 2]
mov rbx, [rbx + WORD_SIZE * 0]
mov rax, [rbx + WORD_SIZE * 0]

;back to applic: applic73
;assuming we get correct input, no need to check type closure 
CLOSURE_ENV rbx, rax ;rbx contains pointer to env
push rbx      ;push env pointer
CLOSURE_CODE rbx, rax 
call rbx
;clean stack
add rsp, WORD_SIZE *1 ; pop env
pop rbx               ; pop arg count
shl rbx, 3            ; rbx = rbx * 8
add rbx, WORD_SIZE    ; clean magic
add rsp, rbx          ; pop args

 cmp rax, SOB_FALSE_ADDRESS 
 je Lelse68 
;parameter variable:
mov rax, [rbp + WORD_SIZE * (4 + 1)]

 jmp Lexit67 
 Lelse68:
;applicTp:
;applic:applic70
;push magic:
mov rbx, 0
push rbx
;applic:applic71
;push magic:
mov rbx, 0
push rbx
;parameter variable:
mov rax, [rbp + WORD_SIZE * (4 + 2)]

push rax
;back to applic: applic71
;push num of args: 
mov rbx,1
push rbx
;generate proc:
;bound variable:
mov rbx, [rbp + WORD_SIZE * 2]
mov rbx, [rbx + WORD_SIZE * 0]
mov rax, [rbx + WORD_SIZE * 2]

;back to applic: applic71
;assuming we get correct input, no need to check type closure 
CLOSURE_ENV rbx, rax ;rbx contains pointer to env
push rbx      ;push env pointer
CLOSURE_CODE rbx, rax 
call rbx
;clean stack
add rsp, WORD_SIZE *1 ; pop env
pop rbx               ; pop arg count
shl rbx, 3            ; rbx = rbx * 8
add rbx, WORD_SIZE    ; clean magic
add rsp, rbx          ; pop args

push rax
;parameter variable:
mov rax, [rbp + WORD_SIZE * (4 + 1)]

push rax
;parameter variable:
mov rax, [rbp + WORD_SIZE * (4 + 0)]

push rax
;back to applic: applic70
;push num of args: 
mov rbx,3
push rbx
;generate proc:
;free variable:
mov rax, qword [fvar_tbl + 48 * WORD_SIZE]

;back to applic: applic70
;assuming we get correct input, no need to check type closure 
CLOSURE_ENV rbx, rax ;rbx contains pointer to env
push rbx      ;push env pointer
CLOSURE_CODE rbx, rax 
call rbx
;clean stack
add rsp, WORD_SIZE *1 ; pop env
pop rbx               ; pop arg count
shl rbx, 3            ; rbx = rbx * 8
add rbx, WORD_SIZE    ; clean magic
add rsp, rbx          ; pop args

push rax
;applic:applic72
;push magic:
mov rbx, 0
push rbx
;parameter variable:
mov rax, [rbp + WORD_SIZE * (4 + 2)]

push rax
;back to applic: applic72
;push num of args: 
mov rbx,1
push rbx
;generate proc:
;bound variable:
mov rbx, [rbp + WORD_SIZE * 2]
mov rbx, [rbx + WORD_SIZE * 0]
mov rax, [rbx + WORD_SIZE * 1]

;back to applic: applic72
;assuming we get correct input, no need to check type closure 
CLOSURE_ENV rbx, rax ;rbx contains pointer to env
push rbx      ;push env pointer
CLOSURE_CODE rbx, rax 
call rbx
;clean stack
add rsp, WORD_SIZE *1 ; pop env
pop rbx               ; pop arg count
shl rbx, 3            ; rbx = rbx * 8
add rbx, WORD_SIZE    ; clean magic
add rsp, rbx          ; pop args

push rax
;push num of args: 
mov rbx,2
push rbx
;generate proc:
;parameter variable:
mov rax, [rbp + WORD_SIZE * (4 + 0)]

;assuming we get correct input, no need to check type closure 
add rax, TYPE_SIZE 
mov rbx, [rax] ;rbx contains pointer to env
push rbx      ;push env pointer
add rax, WORD_SIZE 
mov rbx, [rax] ;rbx contains pointer to code ; (rbx contains pointer to code)
;------------------------changes in opt - do not use rbx ---------------------
push qword [rbp + WORD_SIZE ] ; push old ret addr
; lets get to rax the dst to copy
mov rax, [rbp + WORD_SIZE * 3]
mov r9, [rbp]
add rax, 3
shl rax, 3
add rax, rbp
; lets get to rdx the src to copy
mov rdx, [rsp + WORD_SIZE * 2]
mov r10, rdx
add rdx, 2
shl rdx, 3
add rdx, rsp
; lets get to rcx the number of iterations needed
lea rcx, [r10 + 3]
copy_stack69:

mov r11, [rdx]
mov [rax], r11
sub rax, 8
sub rdx, 8
loop copy_stack69
add rax, 8
mov rsp, rax
mov rbp, r9
jmp rbx
 Lexit67: 

leave
ret
Lcont66: 

leave
ret
Lcont60: 

;back to applic: applic54
;assuming we get correct input, no need to check type closure 
CLOSURE_ENV rbx, rax ;rbx contains pointer to env
push rbx      ;push env pointer
CLOSURE_CODE rbx, rax 
call rbx
;clean stack
add rsp, WORD_SIZE *1 ; pop env
pop rbx               ; pop arg count
shl rbx, 3            ; rbx = rbx * 8
add rbx, WORD_SIZE    ; clean magic
add rsp, rbx          ; pop args
mov [fvar_tbl + 48 * WORD_SIZE], rax 
 lea rax, [const_tbl+1] 

	call write_sob_if_not_void

some_compiled_section95:
;define:
;applic:applic75
;push magic:
mov rbx, 0
push rbx
;free variable:
mov rax, qword [fvar_tbl + 24 * WORD_SIZE]

push rax
;free variable:
mov rax, qword [fvar_tbl + 23 * WORD_SIZE]

push rax
;free variable:
mov rax, qword [fvar_tbl + 4 * WORD_SIZE]

push rax
;back to applic: applic75
;push num of args: 
mov rbx,3
push rbx
;generate proc:
;simple lambda:
mov rbx, 0
shl rbx, 3
MALLOC rax, rbx
push rax; pushing ext_env for later 
;copying pointers:
mov rcx, 0
cmp rcx, 1
jle end_pointers_copy78
copy_pointers76:
push rcx
neg rcx
add rcx, 0
mov rbx, [rbp + WORD_SIZE * 2] ; getting pointer to old env
mov rdx, [rbx + rcx * WORD_SIZE] ; getting to rdx old_env[i]
inc rcx
mov [rax + WORD_SIZE * rcx], rdx ; putting env[i] (stored in rdx) into ext_env[i + 1]
pop rcx ; restoring counter
loop copy_pointers76
end_pointers_copy78:
mov rcx, [rbp + 3 * WORD_SIZE] ; getting to rcx the number of the current parameters 
inc rcx
shl rcx, 3
MALLOC rbx, rcx
mov qword [rax], rbx ; getting the new allocated memory pointer to ext_env[0]
mov rax, rbx ; more convinient with pointer to extenv[0] in rax 

mov rbx, rcx ; rbx will be constant and hold the size of params
; copying parameters to new env 
cmp rbx, 0
je end_parameters_copy79
copy_parameters77: 
push rcx
neg rcx
add rcx, rbx ; rcx starts high and decreases with iterations
lea rdx, [rbp + WORD_SIZE * rcx]
add rdx, 4 * WORD_SIZE ; now rdx has the address of param_i 
mov rdx, [rdx] ; now rdx has the param_i 
mov [rax + WORD_SIZE * rcx], rdx 
pop rcx
loop copy_parameters77
end_parameters_copy79:
pop rbx
MAKE_CLOSURE(rax, rbx, Lcode80)
jmp Lcont81
Lcode80: 
push rbp
mov rbp, rsp
;simple lambda:
mov rbx, 1
shl rbx, 3
MALLOC rax, rbx
push rax; pushing ext_env for later 
;copying pointers:
mov rcx, 1
cmp rcx, 1
jle end_pointers_copy84
copy_pointers82:
push rcx
neg rcx
add rcx, 1
mov rbx, [rbp + WORD_SIZE * 2] ; getting pointer to old env
mov rdx, [rbx + rcx * WORD_SIZE] ; getting to rdx old_env[i]
inc rcx
mov [rax + WORD_SIZE * rcx], rdx ; putting env[i] (stored in rdx) into ext_env[i + 1]
pop rcx ; restoring counter
loop copy_pointers82
end_pointers_copy84:
mov rcx, [rbp + 3 * WORD_SIZE] ; getting to rcx the number of the current parameters 
inc rcx
shl rcx, 3
MALLOC rbx, rcx
mov qword [rax], rbx ; getting the new allocated memory pointer to ext_env[0]
mov rax, rbx ; more convinient with pointer to extenv[0] in rax 

mov rbx, rcx ; rbx will be constant and hold the size of params
; copying parameters to new env 
cmp rbx, 0
je end_parameters_copy85
copy_parameters83: 
push rcx
neg rcx
add rcx, rbx ; rcx starts high and decreases with iterations
lea rdx, [rbp + WORD_SIZE * rcx]
add rdx, 4 * WORD_SIZE ; now rdx has the address of param_i 
mov rdx, [rdx] ; now rdx has the param_i 
mov [rax + WORD_SIZE * rcx], rdx 
pop rcx
loop copy_parameters83
end_parameters_copy85:
pop rbx
MAKE_CLOSURE(rax, rbx, Lcode86)
jmp Lcont87
Lcode86: 
push rbp
mov rbp, rsp
;if:
;applic:applic94
;push magic:
mov rbx, 0
push rbx
;parameter variable:
mov rax, [rbp + WORD_SIZE * (4 + 2)]

push rax
;back to applic: applic94
;push num of args: 
mov rbx,1
push rbx
;generate proc:
;bound variable:
mov rbx, [rbp + WORD_SIZE * 2]
mov rbx, [rbx + WORD_SIZE * 0]
mov rax, [rbx + WORD_SIZE * 0]

;back to applic: applic94
;assuming we get correct input, no need to check type closure 
CLOSURE_ENV rbx, rax ;rbx contains pointer to env
push rbx      ;push env pointer
CLOSURE_CODE rbx, rax 
call rbx
;clean stack
add rsp, WORD_SIZE *1 ; pop env
pop rbx               ; pop arg count
shl rbx, 3            ; rbx = rbx * 8
add rbx, WORD_SIZE    ; clean magic
add rsp, rbx          ; pop args

 cmp rax, SOB_FALSE_ADDRESS 
 je Lelse89 
;parameter variable:
mov rax, [rbp + WORD_SIZE * (4 + 1)]

 jmp Lexit88 
 Lelse89:
;applicTp:
;applic:applic91
;push magic:
mov rbx, 0
push rbx
;parameter variable:
mov rax, [rbp + WORD_SIZE * (4 + 2)]

push rax
;back to applic: applic91
;push num of args: 
mov rbx,1
push rbx
;generate proc:
;bound variable:
mov rbx, [rbp + WORD_SIZE * 2]
mov rbx, [rbx + WORD_SIZE * 0]
mov rax, [rbx + WORD_SIZE * 1]

;back to applic: applic91
;assuming we get correct input, no need to check type closure 
CLOSURE_ENV rbx, rax ;rbx contains pointer to env
push rbx      ;push env pointer
CLOSURE_CODE rbx, rax 
call rbx
;clean stack
add rsp, WORD_SIZE *1 ; pop env
pop rbx               ; pop arg count
shl rbx, 3            ; rbx = rbx * 8
add rbx, WORD_SIZE    ; clean magic
add rsp, rbx          ; pop args

push rax
;applic:applic92
;push magic:
mov rbx, 0
push rbx
;applic:applic93
;push magic:
mov rbx, 0
push rbx
;parameter variable:
mov rax, [rbp + WORD_SIZE * (4 + 2)]

push rax
;back to applic: applic93
;push num of args: 
mov rbx,1
push rbx
;generate proc:
;bound variable:
mov rbx, [rbp + WORD_SIZE * 2]
mov rbx, [rbx + WORD_SIZE * 0]
mov rax, [rbx + WORD_SIZE * 2]

;back to applic: applic93
;assuming we get correct input, no need to check type closure 
CLOSURE_ENV rbx, rax ;rbx contains pointer to env
push rbx      ;push env pointer
CLOSURE_CODE rbx, rax 
call rbx
;clean stack
add rsp, WORD_SIZE *1 ; pop env
pop rbx               ; pop arg count
shl rbx, 3            ; rbx = rbx * 8
add rbx, WORD_SIZE    ; clean magic
add rsp, rbx          ; pop args

push rax
;parameter variable:
mov rax, [rbp + WORD_SIZE * (4 + 1)]

push rax
;parameter variable:
mov rax, [rbp + WORD_SIZE * (4 + 0)]

push rax
;back to applic: applic92
;push num of args: 
mov rbx,3
push rbx
;generate proc:
;free variable:
mov rax, qword [fvar_tbl + 47 * WORD_SIZE]

;back to applic: applic92
;assuming we get correct input, no need to check type closure 
CLOSURE_ENV rbx, rax ;rbx contains pointer to env
push rbx      ;push env pointer
CLOSURE_CODE rbx, rax 
call rbx
;clean stack
add rsp, WORD_SIZE *1 ; pop env
pop rbx               ; pop arg count
shl rbx, 3            ; rbx = rbx * 8
add rbx, WORD_SIZE    ; clean magic
add rsp, rbx          ; pop args

push rax
;push num of args: 
mov rbx,2
push rbx
;generate proc:
;parameter variable:
mov rax, [rbp + WORD_SIZE * (4 + 0)]

;assuming we get correct input, no need to check type closure 
add rax, TYPE_SIZE 
mov rbx, [rax] ;rbx contains pointer to env
push rbx      ;push env pointer
add rax, WORD_SIZE 
mov rbx, [rax] ;rbx contains pointer to code ; (rbx contains pointer to code)
;------------------------changes in opt - do not use rbx ---------------------
push qword [rbp + WORD_SIZE ] ; push old ret addr
; lets get to rax the dst to copy
mov rax, [rbp + WORD_SIZE * 3]
mov r9, [rbp]
add rax, 3
shl rax, 3
add rax, rbp
; lets get to rdx the src to copy
mov rdx, [rsp + WORD_SIZE * 2]
mov r10, rdx
add rdx, 2
shl rdx, 3
add rdx, rsp
; lets get to rcx the number of iterations needed
lea rcx, [r10 + 3]
copy_stack90:

mov r11, [rdx]
mov [rax], r11
sub rax, 8
sub rdx, 8
loop copy_stack90
add rax, 8
mov rsp, rax
mov rbp, r9
jmp rbx
 Lexit88: 

leave
ret
Lcont87: 

leave
ret
Lcont81: 

;back to applic: applic75
;assuming we get correct input, no need to check type closure 
CLOSURE_ENV rbx, rax ;rbx contains pointer to env
push rbx      ;push env pointer
CLOSURE_CODE rbx, rax 
call rbx
;clean stack
add rsp, WORD_SIZE *1 ; pop env
pop rbx               ; pop arg count
shl rbx, 3            ; rbx = rbx * 8
add rbx, WORD_SIZE    ; clean magic
add rsp, rbx          ; pop args
mov [fvar_tbl + 47 * WORD_SIZE], rax 
 lea rax, [const_tbl+1] 

	call write_sob_if_not_void

some_compiled_section124:
;define:
;applic:applic96
;push magic:
mov rbx, 0
push rbx
;free variable:
mov rax, qword [fvar_tbl + 25 * WORD_SIZE]

push rax
;free variable:
mov rax, qword [fvar_tbl + 48 * WORD_SIZE]

push rax
;free variable:
mov rax, qword [fvar_tbl + 4 * WORD_SIZE]

push rax
;back to applic: applic96
;push num of args: 
mov rbx,3
push rbx
;generate proc:
;simple lambda:
mov rbx, 0
shl rbx, 3
MALLOC rax, rbx
push rax; pushing ext_env for later 
;copying pointers:
mov rcx, 0
cmp rcx, 1
jle end_pointers_copy99
copy_pointers97:
push rcx
neg rcx
add rcx, 0
mov rbx, [rbp + WORD_SIZE * 2] ; getting pointer to old env
mov rdx, [rbx + rcx * WORD_SIZE] ; getting to rdx old_env[i]
inc rcx
mov [rax + WORD_SIZE * rcx], rdx ; putting env[i] (stored in rdx) into ext_env[i + 1]
pop rcx ; restoring counter
loop copy_pointers97
end_pointers_copy99:
mov rcx, [rbp + 3 * WORD_SIZE] ; getting to rcx the number of the current parameters 
inc rcx
shl rcx, 3
MALLOC rbx, rcx
mov qword [rax], rbx ; getting the new allocated memory pointer to ext_env[0]
mov rax, rbx ; more convinient with pointer to extenv[0] in rax 

mov rbx, rcx ; rbx will be constant and hold the size of params
; copying parameters to new env 
cmp rbx, 0
je end_parameters_copy100
copy_parameters98: 
push rcx
neg rcx
add rcx, rbx ; rcx starts high and decreases with iterations
lea rdx, [rbp + WORD_SIZE * rcx]
add rdx, 4 * WORD_SIZE ; now rdx has the address of param_i 
mov rdx, [rdx] ; now rdx has the param_i 
mov [rax + WORD_SIZE * rcx], rdx 
pop rcx
loop copy_parameters98
end_parameters_copy100:
pop rbx
MAKE_CLOSURE(rax, rbx, Lcode101)
jmp Lcont102
Lcode101: 
push rbp
mov rbp, rsp
; 
; lambda optional: 
mov rbx, 1
shl rbx, 3
MALLOC rax, rbx
push rax ; pushing ext_env for later 
;copying pointers:
mov rcx, 1
cmp rcx, 1
jle end_pointers_copy105
copy_pointers103:
push rcx
neg rcx
add rcx, 1
mov rbx, [rbp + WORD_SIZE * 2] ; getting pointer to old env
mov rdx, [rbx + rcx * WORD_SIZE] ; getting to rdx old_env[i]
inc rcx
mov [rax + WORD_SIZE * rcx], rdx ; putting env[i] (stored in rdx) into ext_env[i + 1]
pop rcx ; restoring counter
loop copy_pointers103
end_pointers_copy105:
mov rcx, [rbp + 3 * WORD_SIZE] ; getting to rcx the number of the current parameters 
inc rcx
shl rcx, 3
MALLOC rbx, rcx
mov qword [rax], rbx ; getting the new allocated memory pointer to ext_env[0]
mov rax, rbx ; more convinient with pointer to extenv[0] in rax 

mov rbx, rcx ; rbx will be constant and hold the size of params
; copying parameters to new env 
cmp rbx, 0
je end_parameters_copy106
copy_parameters104: 
push rcx
neg rcx
add rcx, rbx ; rcx starts high and decreases with iterations
lea rdx, [rbp + WORD_SIZE * rcx]
add rdx, 4 * WORD_SIZE ; now rdx has the address of param_i 
mov rdx, [rdx] ; now rdx has the param_i 
mov [rax + WORD_SIZE * rcx], rdx 
pop rcx
loop copy_parameters104
end_parameters_copy106:
pop rbx
MAKE_CLOSURE(rax, rbx, Lcode107)
jmp Lcont108
Lcode107: 
push rbp
mov rbp, rsp
mov rax, [rbp + WORD_SIZE * 3] ; rax <- n 
cmp rax, 0; n =? |must|
jne opt_list_creation110
lea rbx, [rbp + WORD_SIZE * (rax + 4)] ; magic <- Nil
mov qword [rbx], const_tbl
jmp actual_code109
opt_list_creation110:
mov rbx, const_tbl
dec rax ; rax <- n - 1
make_list_loop111: ; create list loop 
mov rcx, [rbp + WORD_SIZE * (4 + rax)] ; rcx <- params[i]
MAKE_PAIR(rdx, rcx, rbx)
mov rbx, rdx
dec rax
cmp rax, 0
jge make_list_loop111
mov rax, [rbp + WORD_SIZE * 3]
dec rax; rax <- n - 1
mov [rbp + WORD_SIZE * (4 + rax)], rbx; save optional list on the stack
sub rax, 0 ; constant rax <- n - 1 - |must| (offset to move)
jz actual_code109
lea rcx, [4 + 0] ; i <- must_length + 4 
stack_reduction112:

push rcx
dec rcx
mov rbx, [rbp + WORD_SIZE * rcx]
add rcx, rax
mov [rbp + WORD_SIZE * rcx], rbx
pop rcx
loop stack_reduction112
lea rsp, [rsp + WORD_SIZE * rax]
mov rbp, rsp
mov qword [rbp + WORD_SIZE * 3], 0
actual_code109:
;applicTp:
;parameter variable:
mov rax, [rbp + WORD_SIZE * (4 + 0)]

push rax
;constant
lea rax, [const_tbl+ 0]

push rax
;simple lambda:
mov rbx, 2
shl rbx, 3
MALLOC rax, rbx
push rax; pushing ext_env for later 
;copying pointers:
mov rcx, 2
cmp rcx, 1
jle end_pointers_copy116
copy_pointers114:
push rcx
neg rcx
add rcx, 2
mov rbx, [rbp + WORD_SIZE * 2] ; getting pointer to old env
mov rdx, [rbx + rcx * WORD_SIZE] ; getting to rdx old_env[i]
inc rcx
mov [rax + WORD_SIZE * rcx], rdx ; putting env[i] (stored in rdx) into ext_env[i + 1]
pop rcx ; restoring counter
loop copy_pointers114
end_pointers_copy116:
mov rcx, [rbp + 3 * WORD_SIZE] ; getting to rcx the number of the current parameters 
inc rcx
shl rcx, 3
MALLOC rbx, rcx
mov qword [rax], rbx ; getting the new allocated memory pointer to ext_env[0]
mov rax, rbx ; more convinient with pointer to extenv[0] in rax 

mov rbx, rcx ; rbx will be constant and hold the size of params
; copying parameters to new env 
cmp rbx, 0
je end_parameters_copy117
copy_parameters115: 
push rcx
neg rcx
add rcx, rbx ; rcx starts high and decreases with iterations
lea rdx, [rbp + WORD_SIZE * rcx]
add rdx, 4 * WORD_SIZE ; now rdx has the address of param_i 
mov rdx, [rdx] ; now rdx has the param_i 
mov [rax + WORD_SIZE * rcx], rdx 
pop rcx
loop copy_parameters115
end_parameters_copy117:
pop rbx
MAKE_CLOSURE(rax, rbx, Lcode118)
jmp Lcont119
Lcode118: 
push rbp
mov rbp, rsp
;if:
;applic:applic123
;push magic:
mov rbx, 0
push rbx
;parameter variable:
mov rax, [rbp + WORD_SIZE * (4 + 1)]

push rax
;back to applic: applic123
;push num of args: 
mov rbx,1
push rbx
;generate proc:
;bound variable:
mov rbx, [rbp + WORD_SIZE * 2]
mov rbx, [rbx + WORD_SIZE * 1]
mov rax, [rbx + WORD_SIZE * 0]

;back to applic: applic123
;assuming we get correct input, no need to check type closure 
CLOSURE_ENV rbx, rax ;rbx contains pointer to env
push rbx      ;push env pointer
CLOSURE_CODE rbx, rax 
call rbx
;clean stack
add rsp, WORD_SIZE *1 ; pop env
pop rbx               ; pop arg count
shl rbx, 3            ; rbx = rbx * 8
add rbx, WORD_SIZE    ; clean magic
add rsp, rbx          ; pop args

 cmp rax, SOB_FALSE_ADDRESS 
 je Lelse121 
;parameter variable:
mov rax, [rbp + WORD_SIZE * (4 + 0)]

 jmp Lexit120 
 Lelse121:
;applicTp:
;parameter variable:
mov rax, [rbp + WORD_SIZE * (4 + 0)]

push rax
;parameter variable:
mov rax, [rbp + WORD_SIZE * (4 + 1)]

push rax
;bound variable:
mov rbx, [rbp + WORD_SIZE * 2]
mov rbx, [rbx + WORD_SIZE * 1]
mov rax, [rbx + WORD_SIZE * 2]

push rax
;push num of args: 
mov rbx,3
push rbx
;generate proc:
;bound variable:
mov rbx, [rbp + WORD_SIZE * 2]
mov rbx, [rbx + WORD_SIZE * 1]
mov rax, [rbx + WORD_SIZE * 1]

;assuming we get correct input, no need to check type closure 
add rax, TYPE_SIZE 
mov rbx, [rax] ;rbx contains pointer to env
push rbx      ;push env pointer
add rax, WORD_SIZE 
mov rbx, [rax] ;rbx contains pointer to code ; (rbx contains pointer to code)
;------------------------changes in opt - do not use rbx ---------------------
push qword [rbp + WORD_SIZE ] ; push old ret addr
; lets get to rax the dst to copy
mov rax, [rbp + WORD_SIZE * 3]
mov r9, [rbp]
add rax, 3
shl rax, 3
add rax, rbp
; lets get to rdx the src to copy
mov rdx, [rsp + WORD_SIZE * 2]
mov r10, rdx
add rdx, 2
shl rdx, 3
add rdx, rsp
; lets get to rcx the number of iterations needed
lea rcx, [r10 + 3]
copy_stack122:

mov r11, [rdx]
mov [rax], r11
sub rax, 8
sub rdx, 8
loop copy_stack122
add rax, 8
mov rsp, rax
mov rbp, r9
jmp rbx
 Lexit120: 

leave
ret
Lcont119: 

push rax
;push num of args: 
mov rbx,3
push rbx
;generate proc:
;bound variable:
mov rbx, [rbp + WORD_SIZE * 2]
mov rbx, [rbx + WORD_SIZE * 0]
mov rax, [rbx + WORD_SIZE * 1]

;assuming we get correct input, no need to check type closure 
add rax, TYPE_SIZE 
mov rbx, [rax] ;rbx contains pointer to env
push rbx      ;push env pointer
add rax, WORD_SIZE 
mov rbx, [rax] ;rbx contains pointer to code ; (rbx contains pointer to code)
;------------------------changes in opt - do not use rbx ---------------------
push qword [rbp + WORD_SIZE ] ; push old ret addr
; lets get to rax the dst to copy
mov rax, [rbp + WORD_SIZE * 3]
mov r9, [rbp]
add rax, 3
shl rax, 3
add rax, rbp
; lets get to rdx the src to copy
mov rdx, [rsp + WORD_SIZE * 2]
mov r10, rdx
add rdx, 2
shl rdx, 3
add rdx, rsp
; lets get to rcx the number of iterations needed
lea rcx, [r10 + 3]
copy_stack113:

mov r11, [rdx]
mov [rax], r11
sub rax, 8
sub rdx, 8
loop copy_stack113
add rax, 8
mov rsp, rax
mov rbp, r9
jmp rbx
leave
ret
Lcont108: 

leave
ret
Lcont102: 

;back to applic: applic96
;assuming we get correct input, no need to check type closure 
CLOSURE_ENV rbx, rax ;rbx contains pointer to env
push rbx      ;push env pointer
CLOSURE_CODE rbx, rax 
call rbx
;clean stack
add rsp, WORD_SIZE *1 ; pop env
pop rbx               ; pop arg count
shl rbx, 3            ; rbx = rbx * 8
add rbx, WORD_SIZE    ; clean magic
add rsp, rbx          ; pop args
mov [fvar_tbl + 36 * WORD_SIZE], rax 
 lea rax, [const_tbl+1] 

	call write_sob_if_not_void

some_compiled_section169:
;define:
;applic:applic125
;push magic:
mov rbx, 0
push rbx
;free variable:
mov rax, qword [fvar_tbl + 48 * WORD_SIZE]

push rax
;free variable:
mov rax, qword [fvar_tbl + 25 * WORD_SIZE]

push rax
;free variable:
mov rax, qword [fvar_tbl + 36 * WORD_SIZE]

push rax
;free variable:
mov rax, qword [fvar_tbl + 52 * WORD_SIZE]

push rax
;free variable:
mov rax, qword [fvar_tbl + 4 * WORD_SIZE]

push rax
;free variable:
mov rax, qword [fvar_tbl + 24 * WORD_SIZE]

push rax
;free variable:
mov rax, qword [fvar_tbl + 23 * WORD_SIZE]

push rax
;back to applic: applic125
;push num of args: 
mov rbx,7
push rbx
;generate proc:
;simple lambda:
mov rbx, 0
shl rbx, 3
MALLOC rax, rbx
push rax; pushing ext_env for later 
;copying pointers:
mov rcx, 0
cmp rcx, 1
jle end_pointers_copy128
copy_pointers126:
push rcx
neg rcx
add rcx, 0
mov rbx, [rbp + WORD_SIZE * 2] ; getting pointer to old env
mov rdx, [rbx + rcx * WORD_SIZE] ; getting to rdx old_env[i]
inc rcx
mov [rax + WORD_SIZE * rcx], rdx ; putting env[i] (stored in rdx) into ext_env[i + 1]
pop rcx ; restoring counter
loop copy_pointers126
end_pointers_copy128:
mov rcx, [rbp + 3 * WORD_SIZE] ; getting to rcx the number of the current parameters 
inc rcx
shl rcx, 3
MALLOC rbx, rcx
mov qword [rax], rbx ; getting the new allocated memory pointer to ext_env[0]
mov rax, rbx ; more convinient with pointer to extenv[0] in rax 

mov rbx, rcx ; rbx will be constant and hold the size of params
; copying parameters to new env 
cmp rbx, 0
je end_parameters_copy129
copy_parameters127: 
push rcx
neg rcx
add rcx, rbx ; rcx starts high and decreases with iterations
lea rdx, [rbp + WORD_SIZE * rcx]
add rdx, 4 * WORD_SIZE ; now rdx has the address of param_i 
mov rdx, [rdx] ; now rdx has the param_i 
mov [rax + WORD_SIZE * rcx], rdx 
pop rcx
loop copy_parameters127
end_parameters_copy129:
pop rbx
MAKE_CLOSURE(rax, rbx, Lcode130)
jmp Lcont131
Lcode130: 
push rbp
mov rbp, rsp
;applicTp:
;constant
lea rax, [const_tbl+ 23]

push rax
;push num of args: 
mov rbx,1
push rbx
;generate proc:
;simple lambda:
mov rbx, 1
shl rbx, 3
MALLOC rax, rbx
push rax; pushing ext_env for later 
;copying pointers:
mov rcx, 1
cmp rcx, 1
jle end_pointers_copy135
copy_pointers133:
push rcx
neg rcx
add rcx, 1
mov rbx, [rbp + WORD_SIZE * 2] ; getting pointer to old env
mov rdx, [rbx + rcx * WORD_SIZE] ; getting to rdx old_env[i]
inc rcx
mov [rax + WORD_SIZE * rcx], rdx ; putting env[i] (stored in rdx) into ext_env[i + 1]
pop rcx ; restoring counter
loop copy_pointers133
end_pointers_copy135:
mov rcx, [rbp + 3 * WORD_SIZE] ; getting to rcx the number of the current parameters 
inc rcx
shl rcx, 3
MALLOC rbx, rcx
mov qword [rax], rbx ; getting the new allocated memory pointer to ext_env[0]
mov rax, rbx ; more convinient with pointer to extenv[0] in rax 

mov rbx, rcx ; rbx will be constant and hold the size of params
; copying parameters to new env 
cmp rbx, 0
je end_parameters_copy136
copy_parameters134: 
push rcx
neg rcx
add rcx, rbx ; rcx starts high and decreases with iterations
lea rdx, [rbp + WORD_SIZE * rcx]
add rdx, 4 * WORD_SIZE ; now rdx has the address of param_i 
mov rdx, [rdx] ; now rdx has the param_i 
mov [rax + WORD_SIZE * rcx], rdx 
pop rcx
loop copy_parameters134
end_parameters_copy136:
pop rbx
MAKE_CLOSURE(rax, rbx, Lcode137)
jmp Lcont138
Lcode137: 
push rbp
mov rbp, rsp
;sequence:
;set:
; Box:
lea rcx, [4 + 0]
MALLOC rax, WORD_SIZE
mov rbx, [rbp + WORD_SIZE * rcx]
mov [rax], rbx

mov qword [rbp + WORD_SIZE * (4 + 0)], rax
mov rax, SOB_VOID_ADDRESS 

;sequence:
;box set:
;simple lambda:
mov rbx, 2
shl rbx, 3
MALLOC rax, rbx
push rax; pushing ext_env for later 
;copying pointers:
mov rcx, 2
cmp rcx, 1
jle end_pointers_copy141
copy_pointers139:
push rcx
neg rcx
add rcx, 2
mov rbx, [rbp + WORD_SIZE * 2] ; getting pointer to old env
mov rdx, [rbx + rcx * WORD_SIZE] ; getting to rdx old_env[i]
inc rcx
mov [rax + WORD_SIZE * rcx], rdx ; putting env[i] (stored in rdx) into ext_env[i + 1]
pop rcx ; restoring counter
loop copy_pointers139
end_pointers_copy141:
mov rcx, [rbp + 3 * WORD_SIZE] ; getting to rcx the number of the current parameters 
inc rcx
shl rcx, 3
MALLOC rbx, rcx
mov qword [rax], rbx ; getting the new allocated memory pointer to ext_env[0]
mov rax, rbx ; more convinient with pointer to extenv[0] in rax 

mov rbx, rcx ; rbx will be constant and hold the size of params
; copying parameters to new env 
cmp rbx, 0
je end_parameters_copy142
copy_parameters140: 
push rcx
neg rcx
add rcx, rbx ; rcx starts high and decreases with iterations
lea rdx, [rbp + WORD_SIZE * rcx]
add rdx, 4 * WORD_SIZE ; now rdx has the address of param_i 
mov rdx, [rdx] ; now rdx has the param_i 
mov [rax + WORD_SIZE * rcx], rdx 
pop rcx
loop copy_parameters140
end_parameters_copy142:
pop rbx
MAKE_CLOSURE(rax, rbx, Lcode143)
jmp Lcont144
Lcode143: 
push rbp
mov rbp, rsp
;if:
;applic:applic152
;push magic:
mov rbx, 0
push rbx
;parameter variable:
mov rax, [rbp + WORD_SIZE * (4 + 0)]

push rax
;back to applic: applic152
;push num of args: 
mov rbx,1
push rbx
;generate proc:
;bound variable:
mov rbx, [rbp + WORD_SIZE * 2]
mov rbx, [rbx + WORD_SIZE * 1]
mov rax, [rbx + WORD_SIZE * 2]

;back to applic: applic152
;assuming we get correct input, no need to check type closure 
CLOSURE_ENV rbx, rax ;rbx contains pointer to env
push rbx      ;push env pointer
CLOSURE_CODE rbx, rax 
call rbx
;clean stack
add rsp, WORD_SIZE *1 ; pop env
pop rbx               ; pop arg count
shl rbx, 3            ; rbx = rbx * 8
add rbx, WORD_SIZE    ; clean magic
add rsp, rbx          ; pop args

 cmp rax, SOB_FALSE_ADDRESS 
 je Lelse146 
;parameter variable:
mov rax, [rbp + WORD_SIZE * (4 + 0)]

 jmp Lexit145 
 Lelse146:
;applicTp:
;applic:applic148
;push magic:
mov rbx, 0
push rbx
;applic:applic149
;push magic:
mov rbx, 0
push rbx
;parameter variable:
mov rax, [rbp + WORD_SIZE * (4 + 0)]

push rax
;back to applic: applic149
;push num of args: 
mov rbx,1
push rbx
;generate proc:
;bound variable:
mov rbx, [rbp + WORD_SIZE * 2]
mov rbx, [rbx + WORD_SIZE * 1]
mov rax, [rbx + WORD_SIZE * 0]

;back to applic: applic149
;assuming we get correct input, no need to check type closure 
CLOSURE_ENV rbx, rax ;rbx contains pointer to env
push rbx      ;push env pointer
CLOSURE_CODE rbx, rax 
call rbx
;clean stack
add rsp, WORD_SIZE *1 ; pop env
pop rbx               ; pop arg count
shl rbx, 3            ; rbx = rbx * 8
add rbx, WORD_SIZE    ; clean magic
add rsp, rbx          ; pop args

push rax
;back to applic: applic148
;push num of args: 
mov rbx,1
push rbx
;generate proc:
;bound variable:
mov rbx, [rbp + WORD_SIZE * 2]
mov rbx, [rbx + WORD_SIZE * 1]
mov rax, [rbx + WORD_SIZE * 3]

;back to applic: applic148
;assuming we get correct input, no need to check type closure 
CLOSURE_ENV rbx, rax ;rbx contains pointer to env
push rbx      ;push env pointer
CLOSURE_CODE rbx, rax 
call rbx
;clean stack
add rsp, WORD_SIZE *1 ; pop env
pop rbx               ; pop arg count
shl rbx, 3            ; rbx = rbx * 8
add rbx, WORD_SIZE    ; clean magic
add rsp, rbx          ; pop args

push rax
;applic:applic150
;push magic:
mov rbx, 0
push rbx
;applic:applic151
;push magic:
mov rbx, 0
push rbx
;parameter variable:
mov rax, [rbp + WORD_SIZE * (4 + 0)]

push rax
;back to applic: applic151
;push num of args: 
mov rbx,1
push rbx
;generate proc:
;bound variable:
mov rbx, [rbp + WORD_SIZE * 2]
mov rbx, [rbx + WORD_SIZE * 1]
mov rax, [rbx + WORD_SIZE * 1]

;back to applic: applic151
;assuming we get correct input, no need to check type closure 
CLOSURE_ENV rbx, rax ;rbx contains pointer to env
push rbx      ;push env pointer
CLOSURE_CODE rbx, rax 
call rbx
;clean stack
add rsp, WORD_SIZE *1 ; pop env
pop rbx               ; pop arg count
shl rbx, 3            ; rbx = rbx * 8
add rbx, WORD_SIZE    ; clean magic
add rsp, rbx          ; pop args

push rax
;back to applic: applic150
;push num of args: 
mov rbx,1
push rbx
;generate proc:
;box get:
;bound variable:
mov rbx, [rbp + WORD_SIZE * 2]
mov rbx, [rbx + WORD_SIZE * 0]
mov rax, [rbx + WORD_SIZE * 0]

mov qword rax, [rax]

;back to applic: applic150
;assuming we get correct input, no need to check type closure 
CLOSURE_ENV rbx, rax ;rbx contains pointer to env
push rbx      ;push env pointer
CLOSURE_CODE rbx, rax 
call rbx
;clean stack
add rsp, WORD_SIZE *1 ; pop env
pop rbx               ; pop arg count
shl rbx, 3            ; rbx = rbx * 8
add rbx, WORD_SIZE    ; clean magic
add rsp, rbx          ; pop args

push rax
;push num of args: 
mov rbx,2
push rbx
;generate proc:
;bound variable:
mov rbx, [rbp + WORD_SIZE * 2]
mov rbx, [rbx + WORD_SIZE * 1]
mov rax, [rbx + WORD_SIZE * 4]

;assuming we get correct input, no need to check type closure 
add rax, TYPE_SIZE 
mov rbx, [rax] ;rbx contains pointer to env
push rbx      ;push env pointer
add rax, WORD_SIZE 
mov rbx, [rax] ;rbx contains pointer to code ; (rbx contains pointer to code)
;------------------------changes in opt - do not use rbx ---------------------
push qword [rbp + WORD_SIZE ] ; push old ret addr
; lets get to rax the dst to copy
mov rax, [rbp + WORD_SIZE * 3]
mov r9, [rbp]
add rax, 3
shl rax, 3
add rax, rbp
; lets get to rdx the src to copy
mov rdx, [rsp + WORD_SIZE * 2]
mov r10, rdx
add rdx, 2
shl rdx, 3
add rdx, rsp
; lets get to rcx the number of iterations needed
lea rcx, [r10 + 3]
copy_stack147:

mov r11, [rdx]
mov [rax], r11
sub rax, 8
sub rdx, 8
loop copy_stack147
add rax, 8
mov rsp, rax
mov rbp, r9
jmp rbx
 Lexit145: 

leave
ret
Lcont144: 

push rax
;parameter variable:
mov rax, [rbp + WORD_SIZE * (4 + 0)]

pop rbx
mov qword [rax], rbx
; 
; lambda optional: 
mov rbx, 2
shl rbx, 3
MALLOC rax, rbx
push rax ; pushing ext_env for later 
;copying pointers:
mov rcx, 2
cmp rcx, 1
jle end_pointers_copy155
copy_pointers153:
push rcx
neg rcx
add rcx, 2
mov rbx, [rbp + WORD_SIZE * 2] ; getting pointer to old env
mov rdx, [rbx + rcx * WORD_SIZE] ; getting to rdx old_env[i]
inc rcx
mov [rax + WORD_SIZE * rcx], rdx ; putting env[i] (stored in rdx) into ext_env[i + 1]
pop rcx ; restoring counter
loop copy_pointers153
end_pointers_copy155:
mov rcx, [rbp + 3 * WORD_SIZE] ; getting to rcx the number of the current parameters 
inc rcx
shl rcx, 3
MALLOC rbx, rcx
mov qword [rax], rbx ; getting the new allocated memory pointer to ext_env[0]
mov rax, rbx ; more convinient with pointer to extenv[0] in rax 

mov rbx, rcx ; rbx will be constant and hold the size of params
; copying parameters to new env 
cmp rbx, 0
je end_parameters_copy156
copy_parameters154: 
push rcx
neg rcx
add rcx, rbx ; rcx starts high and decreases with iterations
lea rdx, [rbp + WORD_SIZE * rcx]
add rdx, 4 * WORD_SIZE ; now rdx has the address of param_i 
mov rdx, [rdx] ; now rdx has the param_i 
mov [rax + WORD_SIZE * rcx], rdx 
pop rcx
loop copy_parameters154
end_parameters_copy156:
pop rbx
MAKE_CLOSURE(rax, rbx, Lcode157)
jmp Lcont158
Lcode157: 
push rbp
mov rbp, rsp
mov rax, [rbp + WORD_SIZE * 3] ; rax <- n 
cmp rax, 0; n =? |must|
jne opt_list_creation160
lea rbx, [rbp + WORD_SIZE * (rax + 4)] ; magic <- Nil
mov qword [rbx], const_tbl
jmp actual_code159
opt_list_creation160:
mov rbx, const_tbl
dec rax ; rax <- n - 1
make_list_loop161: ; create list loop 
mov rcx, [rbp + WORD_SIZE * (4 + rax)] ; rcx <- params[i]
MAKE_PAIR(rdx, rcx, rbx)
mov rbx, rdx
dec rax
cmp rax, 0
jge make_list_loop161
mov rax, [rbp + WORD_SIZE * 3]
dec rax; rax <- n - 1
mov [rbp + WORD_SIZE * (4 + rax)], rbx; save optional list on the stack
sub rax, 0 ; constant rax <- n - 1 - |must| (offset to move)
jz actual_code159
lea rcx, [4 + 0] ; i <- must_length + 4 
stack_reduction162:

push rcx
dec rcx
mov rbx, [rbp + WORD_SIZE * rcx]
add rcx, rax
mov [rbp + WORD_SIZE * rcx], rbx
pop rcx
loop stack_reduction162
lea rsp, [rsp + WORD_SIZE * rax]
mov rbp, rsp
mov qword [rbp + WORD_SIZE * 3], 0
actual_code159:
;applicTp:
;applic:applic164
;push magic:
mov rbx, 0
push rbx
;applic:applic165
;push magic:
mov rbx, 0
push rbx
;applic:applic166
;push magic:
mov rbx, 0
push rbx
;parameter variable:
mov rax, [rbp + WORD_SIZE * (4 + 0)]

push rax
;back to applic: applic166
;push num of args: 
mov rbx,1
push rbx
;generate proc:
;box get:
;bound variable:
mov rbx, [rbp + WORD_SIZE * 2]
mov rbx, [rbx + WORD_SIZE * 0]
mov rax, [rbx + WORD_SIZE * 0]

mov qword rax, [rax]

;back to applic: applic166
;assuming we get correct input, no need to check type closure 
CLOSURE_ENV rbx, rax ;rbx contains pointer to env
push rbx      ;push env pointer
CLOSURE_CODE rbx, rax 
call rbx
;clean stack
add rsp, WORD_SIZE *1 ; pop env
pop rbx               ; pop arg count
shl rbx, 3            ; rbx = rbx * 8
add rbx, WORD_SIZE    ; clean magic
add rsp, rbx          ; pop args

push rax
;back to applic: applic165
;push num of args: 
mov rbx,1
push rbx
;generate proc:
;bound variable:
mov rbx, [rbp + WORD_SIZE * 2]
mov rbx, [rbx + WORD_SIZE * 1]
mov rax, [rbx + WORD_SIZE * 1]

;back to applic: applic165
;assuming we get correct input, no need to check type closure 
CLOSURE_ENV rbx, rax ;rbx contains pointer to env
push rbx      ;push env pointer
CLOSURE_CODE rbx, rax 
call rbx
;clean stack
add rsp, WORD_SIZE *1 ; pop env
pop rbx               ; pop arg count
shl rbx, 3            ; rbx = rbx * 8
add rbx, WORD_SIZE    ; clean magic
add rsp, rbx          ; pop args

push rax
;back to applic: applic164
;push num of args: 
mov rbx,1
push rbx
;generate proc:
;box get:
;bound variable:
mov rbx, [rbp + WORD_SIZE * 2]
mov rbx, [rbx + WORD_SIZE * 0]
mov rax, [rbx + WORD_SIZE * 0]

mov qword rax, [rax]

;back to applic: applic164
;assuming we get correct input, no need to check type closure 
CLOSURE_ENV rbx, rax ;rbx contains pointer to env
push rbx      ;push env pointer
CLOSURE_CODE rbx, rax 
call rbx
;clean stack
add rsp, WORD_SIZE *1 ; pop env
pop rbx               ; pop arg count
shl rbx, 3            ; rbx = rbx * 8
add rbx, WORD_SIZE    ; clean magic
add rsp, rbx          ; pop args

push rax
;applic:applic167
;push magic:
mov rbx, 0
push rbx
;applic:applic168
;push magic:
mov rbx, 0
push rbx
;parameter variable:
mov rax, [rbp + WORD_SIZE * (4 + 0)]

push rax
;back to applic: applic168
;push num of args: 
mov rbx,1
push rbx
;generate proc:
;box get:
;bound variable:
mov rbx, [rbp + WORD_SIZE * 2]
mov rbx, [rbx + WORD_SIZE * 0]
mov rax, [rbx + WORD_SIZE * 0]

mov qword rax, [rax]

;back to applic: applic168
;assuming we get correct input, no need to check type closure 
CLOSURE_ENV rbx, rax ;rbx contains pointer to env
push rbx      ;push env pointer
CLOSURE_CODE rbx, rax 
call rbx
;clean stack
add rsp, WORD_SIZE *1 ; pop env
pop rbx               ; pop arg count
shl rbx, 3            ; rbx = rbx * 8
add rbx, WORD_SIZE    ; clean magic
add rsp, rbx          ; pop args

push rax
;back to applic: applic167
;push num of args: 
mov rbx,1
push rbx
;generate proc:
;bound variable:
mov rbx, [rbp + WORD_SIZE * 2]
mov rbx, [rbx + WORD_SIZE * 1]
mov rax, [rbx + WORD_SIZE * 0]

;back to applic: applic167
;assuming we get correct input, no need to check type closure 
CLOSURE_ENV rbx, rax ;rbx contains pointer to env
push rbx      ;push env pointer
CLOSURE_CODE rbx, rax 
call rbx
;clean stack
add rsp, WORD_SIZE *1 ; pop env
pop rbx               ; pop arg count
shl rbx, 3            ; rbx = rbx * 8
add rbx, WORD_SIZE    ; clean magic
add rsp, rbx          ; pop args

push rax
;bound variable:
mov rbx, [rbp + WORD_SIZE * 2]
mov rbx, [rbx + WORD_SIZE * 1]
mov rax, [rbx + WORD_SIZE * 5]

push rax
;push num of args: 
mov rbx,3
push rbx
;generate proc:
;bound variable:
mov rbx, [rbp + WORD_SIZE * 2]
mov rbx, [rbx + WORD_SIZE * 1]
mov rax, [rbx + WORD_SIZE * 6]

;assuming we get correct input, no need to check type closure 
add rax, TYPE_SIZE 
mov rbx, [rax] ;rbx contains pointer to env
push rbx      ;push env pointer
add rax, WORD_SIZE 
mov rbx, [rax] ;rbx contains pointer to code ; (rbx contains pointer to code)
;------------------------changes in opt - do not use rbx ---------------------
push qword [rbp + WORD_SIZE ] ; push old ret addr
; lets get to rax the dst to copy
mov rax, [rbp + WORD_SIZE * 3]
mov r9, [rbp]
add rax, 3
shl rax, 3
add rax, rbp
; lets get to rdx the src to copy
mov rdx, [rsp + WORD_SIZE * 2]
mov r10, rdx
add rdx, 2
shl rdx, 3
add rdx, rsp
; lets get to rcx the number of iterations needed
lea rcx, [r10 + 3]
copy_stack163:

mov r11, [rdx]
mov [rax], r11
sub rax, 8
sub rdx, 8
loop copy_stack163
add rax, 8
mov rsp, rax
mov rbp, r9
jmp rbx
leave
ret
Lcont158: 



leave
ret
Lcont138: 

;assuming we get correct input, no need to check type closure 
add rax, TYPE_SIZE 
mov rbx, [rax] ;rbx contains pointer to env
push rbx      ;push env pointer
add rax, WORD_SIZE 
mov rbx, [rax] ;rbx contains pointer to code ; (rbx contains pointer to code)
;------------------------changes in opt - do not use rbx ---------------------
push qword [rbp + WORD_SIZE ] ; push old ret addr
; lets get to rax the dst to copy
mov rax, [rbp + WORD_SIZE * 3]
mov r9, [rbp]
add rax, 3
shl rax, 3
add rax, rbp
; lets get to rdx the src to copy
mov rdx, [rsp + WORD_SIZE * 2]
mov r10, rdx
add rdx, 2
shl rdx, 3
add rdx, rsp
; lets get to rcx the number of iterations needed
lea rcx, [r10 + 3]
copy_stack132:

mov r11, [rdx]
mov [rax], r11
sub rax, 8
sub rdx, 8
loop copy_stack132
add rax, 8
mov rsp, rax
mov rbp, r9
jmp rbx
leave
ret
Lcont131: 

;back to applic: applic125
;assuming we get correct input, no need to check type closure 
CLOSURE_ENV rbx, rax ;rbx contains pointer to env
push rbx      ;push env pointer
CLOSURE_CODE rbx, rax 
call rbx
;clean stack
add rsp, WORD_SIZE *1 ; pop env
pop rbx               ; pop arg count
shl rbx, 3            ; rbx = rbx * 8
add rbx, WORD_SIZE    ; clean magic
add rsp, rbx          ; pop args
mov [fvar_tbl + 43 * WORD_SIZE], rax 
 lea rax, [const_tbl+1] 

	call write_sob_if_not_void

some_compiled_section212:
;define:
;applic:applic170
;push magic:
mov rbx, 0
push rbx
;free variable:
mov rax, qword [fvar_tbl + 28 * WORD_SIZE]

push rax
;free variable:
mov rax, qword [fvar_tbl + 25 * WORD_SIZE]

push rax
;free variable:
mov rax, qword [fvar_tbl + 24 * WORD_SIZE]

push rax
;free variable:
mov rax, qword [fvar_tbl + 23 * WORD_SIZE]

push rax
;free variable:
mov rax, qword [fvar_tbl + 4 * WORD_SIZE]

push rax
;back to applic: applic170
;push num of args: 
mov rbx,5
push rbx
;generate proc:
;simple lambda:
mov rbx, 0
shl rbx, 3
MALLOC rax, rbx
push rax; pushing ext_env for later 
;copying pointers:
mov rcx, 0
cmp rcx, 1
jle end_pointers_copy173
copy_pointers171:
push rcx
neg rcx
add rcx, 0
mov rbx, [rbp + WORD_SIZE * 2] ; getting pointer to old env
mov rdx, [rbx + rcx * WORD_SIZE] ; getting to rdx old_env[i]
inc rcx
mov [rax + WORD_SIZE * rcx], rdx ; putting env[i] (stored in rdx) into ext_env[i + 1]
pop rcx ; restoring counter
loop copy_pointers171
end_pointers_copy173:
mov rcx, [rbp + 3 * WORD_SIZE] ; getting to rcx the number of the current parameters 
inc rcx
shl rcx, 3
MALLOC rbx, rcx
mov qword [rax], rbx ; getting the new allocated memory pointer to ext_env[0]
mov rax, rbx ; more convinient with pointer to extenv[0] in rax 

mov rbx, rcx ; rbx will be constant and hold the size of params
; copying parameters to new env 
cmp rbx, 0
je end_parameters_copy174
copy_parameters172: 
push rcx
neg rcx
add rcx, rbx ; rcx starts high and decreases with iterations
lea rdx, [rbp + WORD_SIZE * rcx]
add rdx, 4 * WORD_SIZE ; now rdx has the address of param_i 
mov rdx, [rdx] ; now rdx has the param_i 
mov [rax + WORD_SIZE * rcx], rdx 
pop rcx
loop copy_parameters172
end_parameters_copy174:
pop rbx
MAKE_CLOSURE(rax, rbx, Lcode175)
jmp Lcont176
Lcode175: 
push rbp
mov rbp, rsp
;applicTp:
;constant
lea rax, [const_tbl+ 23]

push rax
;push num of args: 
mov rbx,1
push rbx
;generate proc:
;simple lambda:
mov rbx, 1
shl rbx, 3
MALLOC rax, rbx
push rax; pushing ext_env for later 
;copying pointers:
mov rcx, 1
cmp rcx, 1
jle end_pointers_copy180
copy_pointers178:
push rcx
neg rcx
add rcx, 1
mov rbx, [rbp + WORD_SIZE * 2] ; getting pointer to old env
mov rdx, [rbx + rcx * WORD_SIZE] ; getting to rdx old_env[i]
inc rcx
mov [rax + WORD_SIZE * rcx], rdx ; putting env[i] (stored in rdx) into ext_env[i + 1]
pop rcx ; restoring counter
loop copy_pointers178
end_pointers_copy180:
mov rcx, [rbp + 3 * WORD_SIZE] ; getting to rcx the number of the current parameters 
inc rcx
shl rcx, 3
MALLOC rbx, rcx
mov qword [rax], rbx ; getting the new allocated memory pointer to ext_env[0]
mov rax, rbx ; more convinient with pointer to extenv[0] in rax 

mov rbx, rcx ; rbx will be constant and hold the size of params
; copying parameters to new env 
cmp rbx, 0
je end_parameters_copy181
copy_parameters179: 
push rcx
neg rcx
add rcx, rbx ; rcx starts high and decreases with iterations
lea rdx, [rbp + WORD_SIZE * rcx]
add rdx, 4 * WORD_SIZE ; now rdx has the address of param_i 
mov rdx, [rdx] ; now rdx has the param_i 
mov [rax + WORD_SIZE * rcx], rdx 
pop rcx
loop copy_parameters179
end_parameters_copy181:
pop rbx
MAKE_CLOSURE(rax, rbx, Lcode182)
jmp Lcont183
Lcode182: 
push rbp
mov rbp, rsp
;sequence:
;set:
; Box:
lea rcx, [4 + 0]
MALLOC rax, WORD_SIZE
mov rbx, [rbp + WORD_SIZE * rcx]
mov [rax], rbx

mov qword [rbp + WORD_SIZE * (4 + 0)], rax
mov rax, SOB_VOID_ADDRESS 

;sequence:
;box set:
; , f, l
; lambda optional: 
mov rbx, 2
shl rbx, 3
MALLOC rax, rbx
push rax ; pushing ext_env for later 
;copying pointers:
mov rcx, 2
cmp rcx, 1
jle end_pointers_copy186
copy_pointers184:
push rcx
neg rcx
add rcx, 2
mov rbx, [rbp + WORD_SIZE * 2] ; getting pointer to old env
mov rdx, [rbx + rcx * WORD_SIZE] ; getting to rdx old_env[i]
inc rcx
mov [rax + WORD_SIZE * rcx], rdx ; putting env[i] (stored in rdx) into ext_env[i + 1]
pop rcx ; restoring counter
loop copy_pointers184
end_pointers_copy186:
mov rcx, [rbp + 3 * WORD_SIZE] ; getting to rcx the number of the current parameters 
inc rcx
shl rcx, 3
MALLOC rbx, rcx
mov qword [rax], rbx ; getting the new allocated memory pointer to ext_env[0]
mov rax, rbx ; more convinient with pointer to extenv[0] in rax 

mov rbx, rcx ; rbx will be constant and hold the size of params
; copying parameters to new env 
cmp rbx, 0
je end_parameters_copy187
copy_parameters185: 
push rcx
neg rcx
add rcx, rbx ; rcx starts high and decreases with iterations
lea rdx, [rbp + WORD_SIZE * rcx]
add rdx, 4 * WORD_SIZE ; now rdx has the address of param_i 
mov rdx, [rdx] ; now rdx has the param_i 
mov [rax + WORD_SIZE * rcx], rdx 
pop rcx
loop copy_parameters185
end_parameters_copy187:
pop rbx
MAKE_CLOSURE(rax, rbx, Lcode188)
jmp Lcont189
Lcode188: 
push rbp
mov rbp, rsp
mov rax, [rbp + WORD_SIZE * 3] ; rax <- n 
cmp rax, 2; n =? |must|
jne opt_list_creation191
lea rbx, [rbp + WORD_SIZE * (rax + 4)] ; magic <- Nil
mov qword [rbx], const_tbl
jmp actual_code190
opt_list_creation191:
mov rbx, const_tbl
dec rax ; rax <- n - 1
make_list_loop192: ; create list loop 
mov rcx, [rbp + WORD_SIZE * (4 + rax)] ; rcx <- params[i]
MAKE_PAIR(rdx, rcx, rbx)
mov rbx, rdx
dec rax
cmp rax, 2
jge make_list_loop192
mov rax, [rbp + WORD_SIZE * 3]
dec rax; rax <- n - 1
mov [rbp + WORD_SIZE * (4 + rax)], rbx; save optional list on the stack
sub rax, 2 ; constant rax <- n - 1 - |must| (offset to move)
jz actual_code190
lea rcx, [4 + 2] ; i <- must_length + 4 
stack_reduction193:

push rcx
dec rcx
mov rbx, [rbp + WORD_SIZE * rcx]
add rcx, rax
mov [rbp + WORD_SIZE * rcx], rbx
pop rcx
loop stack_reduction193
lea rsp, [rsp + WORD_SIZE * rax]
mov rbp, rsp
mov qword [rbp + WORD_SIZE * 3], 2
actual_code190:
;if:
;applic:applic211
;push magic:
mov rbx, 0
push rbx
;parameter variable:
mov rax, [rbp + WORD_SIZE * (4 + 1)]

push rax
;back to applic: applic211
;push num of args: 
mov rbx,1
push rbx
;generate proc:
;bound variable:
mov rbx, [rbp + WORD_SIZE * 2]
mov rbx, [rbx + WORD_SIZE * 1]
mov rax, [rbx + WORD_SIZE * 0]

;back to applic: applic211
;assuming we get correct input, no need to check type closure 
CLOSURE_ENV rbx, rax ;rbx contains pointer to env
push rbx      ;push env pointer
CLOSURE_CODE rbx, rax 
call rbx
;clean stack
add rsp, WORD_SIZE *1 ; pop env
pop rbx               ; pop arg count
shl rbx, 3            ; rbx = rbx * 8
add rbx, WORD_SIZE    ; clean magic
add rsp, rbx          ; pop args

 cmp rax, SOB_FALSE_ADDRESS 
 je Lelse195 
;constant
lea rax, [const_tbl+ 0]

 jmp Lexit194 
 Lelse195:
;if:
;applic:applic210
;push magic:
mov rbx, 0
push rbx
;parameter variable:
mov rax, [rbp + WORD_SIZE * (4 + 2)]

push rax
;back to applic: applic210
;push num of args: 
mov rbx,1
push rbx
;generate proc:
;bound variable:
mov rbx, [rbp + WORD_SIZE * 2]
mov rbx, [rbx + WORD_SIZE * 1]
mov rax, [rbx + WORD_SIZE * 0]

;back to applic: applic210
;assuming we get correct input, no need to check type closure 
CLOSURE_ENV rbx, rax ;rbx contains pointer to env
push rbx      ;push env pointer
CLOSURE_CODE rbx, rax 
call rbx
;clean stack
add rsp, WORD_SIZE *1 ; pop env
pop rbx               ; pop arg count
shl rbx, 3            ; rbx = rbx * 8
add rbx, WORD_SIZE    ; clean magic
add rsp, rbx          ; pop args

 cmp rax, SOB_FALSE_ADDRESS 
 je Lelse197 
;applicTp:
;applic:applic206
;push magic:
mov rbx, 0
push rbx
;applic:applic207
;push magic:
mov rbx, 0
push rbx
;parameter variable:
mov rax, [rbp + WORD_SIZE * (4 + 1)]

push rax
;back to applic: applic207
;push num of args: 
mov rbx,1
push rbx
;generate proc:
;bound variable:
mov rbx, [rbp + WORD_SIZE * 2]
mov rbx, [rbx + WORD_SIZE * 1]
mov rax, [rbx + WORD_SIZE * 2]

;back to applic: applic207
;assuming we get correct input, no need to check type closure 
CLOSURE_ENV rbx, rax ;rbx contains pointer to env
push rbx      ;push env pointer
CLOSURE_CODE rbx, rax 
call rbx
;clean stack
add rsp, WORD_SIZE *1 ; pop env
pop rbx               ; pop arg count
shl rbx, 3            ; rbx = rbx * 8
add rbx, WORD_SIZE    ; clean magic
add rsp, rbx          ; pop args

push rax
;parameter variable:
mov rax, [rbp + WORD_SIZE * (4 + 0)]

push rax
;back to applic: applic206
;push num of args: 
mov rbx,2
push rbx
;generate proc:
;box get:
;bound variable:
mov rbx, [rbp + WORD_SIZE * 2]
mov rbx, [rbx + WORD_SIZE * 0]
mov rax, [rbx + WORD_SIZE * 0]

mov qword rax, [rax]

;back to applic: applic206
;assuming we get correct input, no need to check type closure 
CLOSURE_ENV rbx, rax ;rbx contains pointer to env
push rbx      ;push env pointer
CLOSURE_CODE rbx, rax 
call rbx
;clean stack
add rsp, WORD_SIZE *1 ; pop env
pop rbx               ; pop arg count
shl rbx, 3            ; rbx = rbx * 8
add rbx, WORD_SIZE    ; clean magic
add rsp, rbx          ; pop args

push rax
;applic:applic208
;push magic:
mov rbx, 0
push rbx
;applic:applic209
;push magic:
mov rbx, 0
push rbx
;parameter variable:
mov rax, [rbp + WORD_SIZE * (4 + 1)]

push rax
;back to applic: applic209
;push num of args: 
mov rbx,1
push rbx
;generate proc:
;bound variable:
mov rbx, [rbp + WORD_SIZE * 2]
mov rbx, [rbx + WORD_SIZE * 1]
mov rax, [rbx + WORD_SIZE * 1]

;back to applic: applic209
;assuming we get correct input, no need to check type closure 
CLOSURE_ENV rbx, rax ;rbx contains pointer to env
push rbx      ;push env pointer
CLOSURE_CODE rbx, rax 
call rbx
;clean stack
add rsp, WORD_SIZE *1 ; pop env
pop rbx               ; pop arg count
shl rbx, 3            ; rbx = rbx * 8
add rbx, WORD_SIZE    ; clean magic
add rsp, rbx          ; pop args

push rax
;back to applic: applic208
;push num of args: 
mov rbx,1
push rbx
;generate proc:
;parameter variable:
mov rax, [rbp + WORD_SIZE * (4 + 0)]

;back to applic: applic208
;assuming we get correct input, no need to check type closure 
CLOSURE_ENV rbx, rax ;rbx contains pointer to env
push rbx      ;push env pointer
CLOSURE_CODE rbx, rax 
call rbx
;clean stack
add rsp, WORD_SIZE *1 ; pop env
pop rbx               ; pop arg count
shl rbx, 3            ; rbx = rbx * 8
add rbx, WORD_SIZE    ; clean magic
add rsp, rbx          ; pop args

push rax
;push num of args: 
mov rbx,2
push rbx
;generate proc:
;bound variable:
mov rbx, [rbp + WORD_SIZE * 2]
mov rbx, [rbx + WORD_SIZE * 1]
mov rax, [rbx + WORD_SIZE * 3]

;assuming we get correct input, no need to check type closure 
add rax, TYPE_SIZE 
mov rbx, [rax] ;rbx contains pointer to env
push rbx      ;push env pointer
add rax, WORD_SIZE 
mov rbx, [rax] ;rbx contains pointer to code ; (rbx contains pointer to code)
;------------------------changes in opt - do not use rbx ---------------------
push qword [rbp + WORD_SIZE ] ; push old ret addr
; lets get to rax the dst to copy
mov rax, [rbp + WORD_SIZE * 3]
mov r9, [rbp]
add rax, 3
shl rax, 3
add rax, rbp
; lets get to rdx the src to copy
mov rdx, [rsp + WORD_SIZE * 2]
mov r10, rdx
add rdx, 2
shl rdx, 3
add rdx, rsp
; lets get to rcx the number of iterations needed
lea rcx, [r10 + 3]
copy_stack205:

mov r11, [rdx]
mov [rax], r11
sub rax, 8
sub rdx, 8
loop copy_stack205
add rax, 8
mov rsp, rax
mov rbp, r9
jmp rbx
 jmp Lexit196 
 Lelse197:
;applicTp:
;applic:applic199
;push magic:
mov rbx, 0
push rbx
;applic:applic200
;push magic:
mov rbx, 0
push rbx
;parameter variable:
mov rax, [rbp + WORD_SIZE * (4 + 2)]

push rax
;bound variable:
mov rbx, [rbp + WORD_SIZE * 2]
mov rbx, [rbx + WORD_SIZE * 1]
mov rax, [rbx + WORD_SIZE * 2]

push rax
;back to applic: applic200
;push num of args: 
mov rbx,2
push rbx
;generate proc:
;box get:
;bound variable:
mov rbx, [rbp + WORD_SIZE * 2]
mov rbx, [rbx + WORD_SIZE * 0]
mov rax, [rbx + WORD_SIZE * 0]

mov qword rax, [rax]

;back to applic: applic200
;assuming we get correct input, no need to check type closure 
CLOSURE_ENV rbx, rax ;rbx contains pointer to env
push rbx      ;push env pointer
CLOSURE_CODE rbx, rax 
call rbx
;clean stack
add rsp, WORD_SIZE *1 ; pop env
pop rbx               ; pop arg count
shl rbx, 3            ; rbx = rbx * 8
add rbx, WORD_SIZE    ; clean magic
add rsp, rbx          ; pop args

push rax
;applic:applic201
;push magic:
mov rbx, 0
push rbx
;parameter variable:
mov rax, [rbp + WORD_SIZE * (4 + 1)]

push rax
;back to applic: applic201
;push num of args: 
mov rbx,1
push rbx
;generate proc:
;bound variable:
mov rbx, [rbp + WORD_SIZE * 2]
mov rbx, [rbx + WORD_SIZE * 1]
mov rax, [rbx + WORD_SIZE * 2]

;back to applic: applic201
;assuming we get correct input, no need to check type closure 
CLOSURE_ENV rbx, rax ;rbx contains pointer to env
push rbx      ;push env pointer
CLOSURE_CODE rbx, rax 
call rbx
;clean stack
add rsp, WORD_SIZE *1 ; pop env
pop rbx               ; pop arg count
shl rbx, 3            ; rbx = rbx * 8
add rbx, WORD_SIZE    ; clean magic
add rsp, rbx          ; pop args

push rax
;parameter variable:
mov rax, [rbp + WORD_SIZE * (4 + 0)]

push rax
;free variable:
mov rax, qword [fvar_tbl + 55 * WORD_SIZE]

push rax
;back to applic: applic199
;push num of args: 
mov rbx,4
push rbx
;generate proc:
;bound variable:
mov rbx, [rbp + WORD_SIZE * 2]
mov rbx, [rbx + WORD_SIZE * 1]
mov rax, [rbx + WORD_SIZE * 4]

;back to applic: applic199
;assuming we get correct input, no need to check type closure 
CLOSURE_ENV rbx, rax ;rbx contains pointer to env
push rbx      ;push env pointer
CLOSURE_CODE rbx, rax 
call rbx
;clean stack
add rsp, WORD_SIZE *1 ; pop env
pop rbx               ; pop arg count
shl rbx, 3            ; rbx = rbx * 8
add rbx, WORD_SIZE    ; clean magic
add rsp, rbx          ; pop args

push rax
;applic:applic202
;push magic:
mov rbx, 0
push rbx
;applic:applic203
;push magic:
mov rbx, 0
push rbx
;parameter variable:
mov rax, [rbp + WORD_SIZE * (4 + 2)]

push rax
;bound variable:
mov rbx, [rbp + WORD_SIZE * 2]
mov rbx, [rbx + WORD_SIZE * 1]
mov rax, [rbx + WORD_SIZE * 1]

push rax
;back to applic: applic203
;push num of args: 
mov rbx,2
push rbx
;generate proc:
;box get:
;bound variable:
mov rbx, [rbp + WORD_SIZE * 2]
mov rbx, [rbx + WORD_SIZE * 0]
mov rax, [rbx + WORD_SIZE * 0]

mov qword rax, [rax]

;back to applic: applic203
;assuming we get correct input, no need to check type closure 
CLOSURE_ENV rbx, rax ;rbx contains pointer to env
push rbx      ;push env pointer
CLOSURE_CODE rbx, rax 
call rbx
;clean stack
add rsp, WORD_SIZE *1 ; pop env
pop rbx               ; pop arg count
shl rbx, 3            ; rbx = rbx * 8
add rbx, WORD_SIZE    ; clean magic
add rsp, rbx          ; pop args

push rax
;applic:applic204
;push magic:
mov rbx, 0
push rbx
;parameter variable:
mov rax, [rbp + WORD_SIZE * (4 + 1)]

push rax
;back to applic: applic204
;push num of args: 
mov rbx,1
push rbx
;generate proc:
;bound variable:
mov rbx, [rbp + WORD_SIZE * 2]
mov rbx, [rbx + WORD_SIZE * 1]
mov rax, [rbx + WORD_SIZE * 1]

;back to applic: applic204
;assuming we get correct input, no need to check type closure 
CLOSURE_ENV rbx, rax ;rbx contains pointer to env
push rbx      ;push env pointer
CLOSURE_CODE rbx, rax 
call rbx
;clean stack
add rsp, WORD_SIZE *1 ; pop env
pop rbx               ; pop arg count
shl rbx, 3            ; rbx = rbx * 8
add rbx, WORD_SIZE    ; clean magic
add rsp, rbx          ; pop args

push rax
;parameter variable:
mov rax, [rbp + WORD_SIZE * (4 + 0)]

push rax
;back to applic: applic202
;push num of args: 
mov rbx,3
push rbx
;generate proc:
;bound variable:
mov rbx, [rbp + WORD_SIZE * 2]
mov rbx, [rbx + WORD_SIZE * 1]
mov rax, [rbx + WORD_SIZE * 4]

;back to applic: applic202
;assuming we get correct input, no need to check type closure 
CLOSURE_ENV rbx, rax ;rbx contains pointer to env
push rbx      ;push env pointer
CLOSURE_CODE rbx, rax 
call rbx
;clean stack
add rsp, WORD_SIZE *1 ; pop env
pop rbx               ; pop arg count
shl rbx, 3            ; rbx = rbx * 8
add rbx, WORD_SIZE    ; clean magic
add rsp, rbx          ; pop args

push rax
;push num of args: 
mov rbx,2
push rbx
;generate proc:
;bound variable:
mov rbx, [rbp + WORD_SIZE * 2]
mov rbx, [rbx + WORD_SIZE * 1]
mov rax, [rbx + WORD_SIZE * 3]

;assuming we get correct input, no need to check type closure 
add rax, TYPE_SIZE 
mov rbx, [rax] ;rbx contains pointer to env
push rbx      ;push env pointer
add rax, WORD_SIZE 
mov rbx, [rax] ;rbx contains pointer to code ; (rbx contains pointer to code)
;------------------------changes in opt - do not use rbx ---------------------
push qword [rbp + WORD_SIZE ] ; push old ret addr
; lets get to rax the dst to copy
mov rax, [rbp + WORD_SIZE * 3]
mov r9, [rbp]
add rax, 3
shl rax, 3
add rax, rbp
; lets get to rdx the src to copy
mov rdx, [rsp + WORD_SIZE * 2]
mov r10, rdx
add rdx, 2
shl rdx, 3
add rdx, rsp
; lets get to rcx the number of iterations needed
lea rcx, [r10 + 3]
copy_stack198:

mov r11, [rdx]
mov [rax], r11
sub rax, 8
sub rdx, 8
loop copy_stack198
add rax, 8
mov rsp, rax
mov rbp, r9
jmp rbx
 Lexit196: 

 Lexit194: 

leave
ret
Lcont189: 

push rax
;parameter variable:
mov rax, [rbp + WORD_SIZE * (4 + 0)]

pop rbx
mov qword [rax], rbx
;box get:
;parameter variable:
mov rax, [rbp + WORD_SIZE * (4 + 0)]

mov qword rax, [rax]



leave
ret
Lcont183: 

;assuming we get correct input, no need to check type closure 
add rax, TYPE_SIZE 
mov rbx, [rax] ;rbx contains pointer to env
push rbx      ;push env pointer
add rax, WORD_SIZE 
mov rbx, [rax] ;rbx contains pointer to code ; (rbx contains pointer to code)
;------------------------changes in opt - do not use rbx ---------------------
push qword [rbp + WORD_SIZE ] ; push old ret addr
; lets get to rax the dst to copy
mov rax, [rbp + WORD_SIZE * 3]
mov r9, [rbp]
add rax, 3
shl rax, 3
add rax, rbp
; lets get to rdx the src to copy
mov rdx, [rsp + WORD_SIZE * 2]
mov r10, rdx
add rdx, 2
shl rdx, 3
add rdx, rsp
; lets get to rcx the number of iterations needed
lea rcx, [r10 + 3]
copy_stack177:

mov r11, [rdx]
mov [rax], r11
sub rax, 8
sub rdx, 8
loop copy_stack177
add rax, 8
mov rsp, rax
mov rbp, r9
jmp rbx
leave
ret
Lcont176: 

;back to applic: applic170
;assuming we get correct input, no need to check type closure 
CLOSURE_ENV rbx, rax ;rbx contains pointer to env
push rbx      ;push env pointer
CLOSURE_CODE rbx, rax 
call rbx
;clean stack
add rsp, WORD_SIZE *1 ; pop env
pop rbx               ; pop arg count
shl rbx, 3            ; rbx = rbx * 8
add rbx, WORD_SIZE    ; clean magic
add rsp, rbx          ; pop args
mov [fvar_tbl + 55 * WORD_SIZE], rax 
 lea rax, [const_tbl+1] 

	call write_sob_if_not_void

some_compiled_section240:
;define:
;applic:applic213
;push magic:
mov rbx, 0
push rbx
;free variable:
mov rax, qword [fvar_tbl + 24 * WORD_SIZE]

push rax
;free variable:
mov rax, qword [fvar_tbl + 3 * WORD_SIZE]

push rax
;free variable:
mov rax, qword [fvar_tbl + 4 * WORD_SIZE]

push rax
;back to applic: applic213
;push num of args: 
mov rbx,3
push rbx
;generate proc:
;simple lambda:
mov rbx, 0
shl rbx, 3
MALLOC rax, rbx
push rax; pushing ext_env for later 
;copying pointers:
mov rcx, 0
cmp rcx, 1
jle end_pointers_copy216
copy_pointers214:
push rcx
neg rcx
add rcx, 0
mov rbx, [rbp + WORD_SIZE * 2] ; getting pointer to old env
mov rdx, [rbx + rcx * WORD_SIZE] ; getting to rdx old_env[i]
inc rcx
mov [rax + WORD_SIZE * rcx], rdx ; putting env[i] (stored in rdx) into ext_env[i + 1]
pop rcx ; restoring counter
loop copy_pointers214
end_pointers_copy216:
mov rcx, [rbp + 3 * WORD_SIZE] ; getting to rcx the number of the current parameters 
inc rcx
shl rcx, 3
MALLOC rbx, rcx
mov qword [rax], rbx ; getting the new allocated memory pointer to ext_env[0]
mov rax, rbx ; more convinient with pointer to extenv[0] in rax 

mov rbx, rcx ; rbx will be constant and hold the size of params
; copying parameters to new env 
cmp rbx, 0
je end_parameters_copy217
copy_parameters215: 
push rcx
neg rcx
add rcx, rbx ; rcx starts high and decreases with iterations
lea rdx, [rbp + WORD_SIZE * rcx]
add rdx, 4 * WORD_SIZE ; now rdx has the address of param_i 
mov rdx, [rdx] ; now rdx has the param_i 
mov [rax + WORD_SIZE * rcx], rdx 
pop rcx
loop copy_parameters215
end_parameters_copy217:
pop rbx
MAKE_CLOSURE(rax, rbx, Lcode218)
jmp Lcont219
Lcode218: 
push rbp
mov rbp, rsp
;applicTp:
;constant
lea rax, [const_tbl+ 23]

push rax
;push num of args: 
mov rbx,1
push rbx
;generate proc:
;simple lambda:
mov rbx, 1
shl rbx, 3
MALLOC rax, rbx
push rax; pushing ext_env for later 
;copying pointers:
mov rcx, 1
cmp rcx, 1
jle end_pointers_copy223
copy_pointers221:
push rcx
neg rcx
add rcx, 1
mov rbx, [rbp + WORD_SIZE * 2] ; getting pointer to old env
mov rdx, [rbx + rcx * WORD_SIZE] ; getting to rdx old_env[i]
inc rcx
mov [rax + WORD_SIZE * rcx], rdx ; putting env[i] (stored in rdx) into ext_env[i + 1]
pop rcx ; restoring counter
loop copy_pointers221
end_pointers_copy223:
mov rcx, [rbp + 3 * WORD_SIZE] ; getting to rcx the number of the current parameters 
inc rcx
shl rcx, 3
MALLOC rbx, rcx
mov qword [rax], rbx ; getting the new allocated memory pointer to ext_env[0]
mov rax, rbx ; more convinient with pointer to extenv[0] in rax 

mov rbx, rcx ; rbx will be constant and hold the size of params
; copying parameters to new env 
cmp rbx, 0
je end_parameters_copy224
copy_parameters222: 
push rcx
neg rcx
add rcx, rbx ; rcx starts high and decreases with iterations
lea rdx, [rbp + WORD_SIZE * rcx]
add rdx, 4 * WORD_SIZE ; now rdx has the address of param_i 
mov rdx, [rdx] ; now rdx has the param_i 
mov [rax + WORD_SIZE * rcx], rdx 
pop rcx
loop copy_parameters222
end_parameters_copy224:
pop rbx
MAKE_CLOSURE(rax, rbx, Lcode225)
jmp Lcont226
Lcode225: 
push rbp
mov rbp, rsp
;sequence:
;set:
;simple lambda:
mov rbx, 2
shl rbx, 3
MALLOC rax, rbx
push rax; pushing ext_env for later 
;copying pointers:
mov rcx, 2
cmp rcx, 1
jle end_pointers_copy229
copy_pointers227:
push rcx
neg rcx
add rcx, 2
mov rbx, [rbp + WORD_SIZE * 2] ; getting pointer to old env
mov rdx, [rbx + rcx * WORD_SIZE] ; getting to rdx old_env[i]
inc rcx
mov [rax + WORD_SIZE * rcx], rdx ; putting env[i] (stored in rdx) into ext_env[i + 1]
pop rcx ; restoring counter
loop copy_pointers227
end_pointers_copy229:
mov rcx, [rbp + 3 * WORD_SIZE] ; getting to rcx the number of the current parameters 
inc rcx
shl rcx, 3
MALLOC rbx, rcx
mov qword [rax], rbx ; getting the new allocated memory pointer to ext_env[0]
mov rax, rbx ; more convinient with pointer to extenv[0] in rax 

mov rbx, rcx ; rbx will be constant and hold the size of params
; copying parameters to new env 
cmp rbx, 0
je end_parameters_copy230
copy_parameters228: 
push rcx
neg rcx
add rcx, rbx ; rcx starts high and decreases with iterations
lea rdx, [rbp + WORD_SIZE * rcx]
add rdx, 4 * WORD_SIZE ; now rdx has the address of param_i 
mov rdx, [rdx] ; now rdx has the param_i 
mov [rax + WORD_SIZE * rcx], rdx 
pop rcx
loop copy_parameters228
end_parameters_copy230:
pop rbx
MAKE_CLOSURE(rax, rbx, Lcode231)
jmp Lcont232
Lcode231: 
push rbp
mov rbp, rsp
;or:
;applic:applic233
;push magic:
mov rbx, 0
push rbx
;parameter variable:
mov rax, [rbp + WORD_SIZE * (4 + 0)]

push rax
;back to applic: applic233
;push num of args: 
mov rbx,1
push rbx
;generate proc:
;bound variable:
mov rbx, [rbp + WORD_SIZE * 2]
mov rbx, [rbx + WORD_SIZE * 1]
mov rax, [rbx + WORD_SIZE * 0]

;back to applic: applic233
;assuming we get correct input, no need to check type closure 
CLOSURE_ENV rbx, rax ;rbx contains pointer to env
push rbx      ;push env pointer
CLOSURE_CODE rbx, rax 
call rbx
;clean stack
add rsp, WORD_SIZE *1 ; pop env
pop rbx               ; pop arg count
shl rbx, 3            ; rbx = rbx * 8
add rbx, WORD_SIZE    ; clean magic
add rsp, rbx          ; pop args

 cmp rax, SOB_FALSE_ADDRESS 
 jne Lexit239
;if:
;applic:applic238
;push magic:
mov rbx, 0
push rbx
;parameter variable:
mov rax, [rbp + WORD_SIZE * (4 + 0)]

push rax
;back to applic: applic238
;push num of args: 
mov rbx,1
push rbx
;generate proc:
;bound variable:
mov rbx, [rbp + WORD_SIZE * 2]
mov rbx, [rbx + WORD_SIZE * 1]
mov rax, [rbx + WORD_SIZE * 1]

;back to applic: applic238
;assuming we get correct input, no need to check type closure 
CLOSURE_ENV rbx, rax ;rbx contains pointer to env
push rbx      ;push env pointer
CLOSURE_CODE rbx, rax 
call rbx
;clean stack
add rsp, WORD_SIZE *1 ; pop env
pop rbx               ; pop arg count
shl rbx, 3            ; rbx = rbx * 8
add rbx, WORD_SIZE    ; clean magic
add rsp, rbx          ; pop args

 cmp rax, SOB_FALSE_ADDRESS 
 je Lelse235 
;applicTp:
;applic:applic237
;push magic:
mov rbx, 0
push rbx
;parameter variable:
mov rax, [rbp + WORD_SIZE * (4 + 0)]

push rax
;back to applic: applic237
;push num of args: 
mov rbx,1
push rbx
;generate proc:
;bound variable:
mov rbx, [rbp + WORD_SIZE * 2]
mov rbx, [rbx + WORD_SIZE * 1]
mov rax, [rbx + WORD_SIZE * 2]

;back to applic: applic237
;assuming we get correct input, no need to check type closure 
CLOSURE_ENV rbx, rax ;rbx contains pointer to env
push rbx      ;push env pointer
CLOSURE_CODE rbx, rax 
call rbx
;clean stack
add rsp, WORD_SIZE *1 ; pop env
pop rbx               ; pop arg count
shl rbx, 3            ; rbx = rbx * 8
add rbx, WORD_SIZE    ; clean magic
add rsp, rbx          ; pop args

push rax
;push num of args: 
mov rbx,1
push rbx
;generate proc:
;free variable:
mov rax, qword [fvar_tbl + 53 * WORD_SIZE]

;assuming we get correct input, no need to check type closure 
add rax, TYPE_SIZE 
mov rbx, [rax] ;rbx contains pointer to env
push rbx      ;push env pointer
add rax, WORD_SIZE 
mov rbx, [rax] ;rbx contains pointer to code ; (rbx contains pointer to code)
;------------------------changes in opt - do not use rbx ---------------------
push qword [rbp + WORD_SIZE ] ; push old ret addr
; lets get to rax the dst to copy
mov rax, [rbp + WORD_SIZE * 3]
mov r9, [rbp]
add rax, 3
shl rax, 3
add rax, rbp
; lets get to rdx the src to copy
mov rdx, [rsp + WORD_SIZE * 2]
mov r10, rdx
add rdx, 2
shl rdx, 3
add rdx, rsp
; lets get to rcx the number of iterations needed
lea rcx, [r10 + 3]
copy_stack236:

mov r11, [rdx]
mov [rax], r11
sub rax, 8
sub rdx, 8
loop copy_stack236
add rax, 8
mov rsp, rax
mov rbp, r9
jmp rbx
 jmp Lexit234 
 Lelse235:
;constant
lea rax, [const_tbl+ 4]

 Lexit234: 

 Lexit239: 
leave
ret
Lcont232: 

mov qword [rbp + WORD_SIZE * (4 + 0)], rax
mov rax, SOB_VOID_ADDRESS 

;parameter variable:
mov rax, [rbp + WORD_SIZE * (4 + 0)]


leave
ret
Lcont226: 

;assuming we get correct input, no need to check type closure 
add rax, TYPE_SIZE 
mov rbx, [rax] ;rbx contains pointer to env
push rbx      ;push env pointer
add rax, WORD_SIZE 
mov rbx, [rax] ;rbx contains pointer to code ; (rbx contains pointer to code)
;------------------------changes in opt - do not use rbx ---------------------
push qword [rbp + WORD_SIZE ] ; push old ret addr
; lets get to rax the dst to copy
mov rax, [rbp + WORD_SIZE * 3]
mov r9, [rbp]
add rax, 3
shl rax, 3
add rax, rbp
; lets get to rdx the src to copy
mov rdx, [rsp + WORD_SIZE * 2]
mov r10, rdx
add rdx, 2
shl rdx, 3
add rdx, rsp
; lets get to rcx the number of iterations needed
lea rcx, [r10 + 3]
copy_stack220:

mov r11, [rdx]
mov [rax], r11
sub rax, 8
sub rdx, 8
loop copy_stack220
add rax, 8
mov rsp, rax
mov rbp, r9
jmp rbx
leave
ret
Lcont219: 

;back to applic: applic213
;assuming we get correct input, no need to check type closure 
CLOSURE_ENV rbx, rax ;rbx contains pointer to env
push rbx      ;push env pointer
CLOSURE_CODE rbx, rax 
call rbx
;clean stack
add rsp, WORD_SIZE *1 ; pop env
pop rbx               ; pop arg count
shl rbx, 3            ; rbx = rbx * 8
add rbx, WORD_SIZE    ; clean magic
add rsp, rbx          ; pop args
mov [fvar_tbl + 53 * WORD_SIZE], rax 
 lea rax, [const_tbl+1] 

	call write_sob_if_not_void

some_compiled_section259:
;define:
;applic:applic241
;push magic:
mov rbx, 0
push rbx
;free variable:
mov rax, qword [fvar_tbl + 17 * WORD_SIZE]

push rax
;free variable:
mov rax, qword [fvar_tbl + 47 * WORD_SIZE]

push rax
;back to applic: applic241
;push num of args: 
mov rbx,2
push rbx
;generate proc:
;simple lambda:
mov rbx, 0
shl rbx, 3
MALLOC rax, rbx
push rax; pushing ext_env for later 
;copying pointers:
mov rcx, 0
cmp rcx, 1
jle end_pointers_copy244
copy_pointers242:
push rcx
neg rcx
add rcx, 0
mov rbx, [rbp + WORD_SIZE * 2] ; getting pointer to old env
mov rdx, [rbx + rcx * WORD_SIZE] ; getting to rdx old_env[i]
inc rcx
mov [rax + WORD_SIZE * rcx], rdx ; putting env[i] (stored in rdx) into ext_env[i + 1]
pop rcx ; restoring counter
loop copy_pointers242
end_pointers_copy244:
mov rcx, [rbp + 3 * WORD_SIZE] ; getting to rcx the number of the current parameters 
inc rcx
shl rcx, 3
MALLOC rbx, rcx
mov qword [rax], rbx ; getting the new allocated memory pointer to ext_env[0]
mov rax, rbx ; more convinient with pointer to extenv[0] in rax 

mov rbx, rcx ; rbx will be constant and hold the size of params
; copying parameters to new env 
cmp rbx, 0
je end_parameters_copy245
copy_parameters243: 
push rcx
neg rcx
add rcx, rbx ; rcx starts high and decreases with iterations
lea rdx, [rbp + WORD_SIZE * rcx]
add rdx, 4 * WORD_SIZE ; now rdx has the address of param_i 
mov rdx, [rdx] ; now rdx has the param_i 
mov [rax + WORD_SIZE * rcx], rdx 
pop rcx
loop copy_parameters243
end_parameters_copy245:
pop rbx
MAKE_CLOSURE(rax, rbx, Lcode246)
jmp Lcont247
Lcode246: 
push rbp
mov rbp, rsp
; 
; lambda optional: 
mov rbx, 1
shl rbx, 3
MALLOC rax, rbx
push rax ; pushing ext_env for later 
;copying pointers:
mov rcx, 1
cmp rcx, 1
jle end_pointers_copy250
copy_pointers248:
push rcx
neg rcx
add rcx, 1
mov rbx, [rbp + WORD_SIZE * 2] ; getting pointer to old env
mov rdx, [rbx + rcx * WORD_SIZE] ; getting to rdx old_env[i]
inc rcx
mov [rax + WORD_SIZE * rcx], rdx ; putting env[i] (stored in rdx) into ext_env[i + 1]
pop rcx ; restoring counter
loop copy_pointers248
end_pointers_copy250:
mov rcx, [rbp + 3 * WORD_SIZE] ; getting to rcx the number of the current parameters 
inc rcx
shl rcx, 3
MALLOC rbx, rcx
mov qword [rax], rbx ; getting the new allocated memory pointer to ext_env[0]
mov rax, rbx ; more convinient with pointer to extenv[0] in rax 

mov rbx, rcx ; rbx will be constant and hold the size of params
; copying parameters to new env 
cmp rbx, 0
je end_parameters_copy251
copy_parameters249: 
push rcx
neg rcx
add rcx, rbx ; rcx starts high and decreases with iterations
lea rdx, [rbp + WORD_SIZE * rcx]
add rdx, 4 * WORD_SIZE ; now rdx has the address of param_i 
mov rdx, [rdx] ; now rdx has the param_i 
mov [rax + WORD_SIZE * rcx], rdx 
pop rcx
loop copy_parameters249
end_parameters_copy251:
pop rbx
MAKE_CLOSURE(rax, rbx, Lcode252)
jmp Lcont253
Lcode252: 
push rbp
mov rbp, rsp
mov rax, [rbp + WORD_SIZE * 3] ; rax <- n 
cmp rax, 0; n =? |must|
jne opt_list_creation255
lea rbx, [rbp + WORD_SIZE * (rax + 4)] ; magic <- Nil
mov qword [rbx], const_tbl
jmp actual_code254
opt_list_creation255:
mov rbx, const_tbl
dec rax ; rax <- n - 1
make_list_loop256: ; create list loop 
mov rcx, [rbp + WORD_SIZE * (4 + rax)] ; rcx <- params[i]
MAKE_PAIR(rdx, rcx, rbx)
mov rbx, rdx
dec rax
cmp rax, 0
jge make_list_loop256
mov rax, [rbp + WORD_SIZE * 3]
dec rax; rax <- n - 1
mov [rbp + WORD_SIZE * (4 + rax)], rbx; save optional list on the stack
sub rax, 0 ; constant rax <- n - 1 - |must| (offset to move)
jz actual_code254
lea rcx, [4 + 0] ; i <- must_length + 4 
stack_reduction257:

push rcx
dec rcx
mov rbx, [rbp + WORD_SIZE * rcx]
add rcx, rax
mov [rbp + WORD_SIZE * rcx], rbx
pop rcx
loop stack_reduction257
lea rsp, [rsp + WORD_SIZE * rax]
mov rbp, rsp
mov qword [rbp + WORD_SIZE * 3], 0
actual_code254:
;applicTp:
;parameter variable:
mov rax, [rbp + WORD_SIZE * (4 + 0)]

push rax
;constant
lea rax, [const_tbl+ 32]

push rax
;bound variable:
mov rbx, [rbp + WORD_SIZE * 2]
mov rbx, [rbx + WORD_SIZE * 0]
mov rax, [rbx + WORD_SIZE * 1]

push rax
;push num of args: 
mov rbx,3
push rbx
;generate proc:
;bound variable:
mov rbx, [rbp + WORD_SIZE * 2]
mov rbx, [rbx + WORD_SIZE * 0]
mov rax, [rbx + WORD_SIZE * 0]

;assuming we get correct input, no need to check type closure 
add rax, TYPE_SIZE 
mov rbx, [rax] ;rbx contains pointer to env
push rbx      ;push env pointer
add rax, WORD_SIZE 
mov rbx, [rax] ;rbx contains pointer to code ; (rbx contains pointer to code)
;------------------------changes in opt - do not use rbx ---------------------
push qword [rbp + WORD_SIZE ] ; push old ret addr
; lets get to rax the dst to copy
mov rax, [rbp + WORD_SIZE * 3]
mov r9, [rbp]
add rax, 3
shl rax, 3
add rax, rbp
; lets get to rdx the src to copy
mov rdx, [rsp + WORD_SIZE * 2]
mov r10, rdx
add rdx, 2
shl rdx, 3
add rdx, rsp
; lets get to rcx the number of iterations needed
lea rcx, [r10 + 3]
copy_stack258:

mov r11, [rdx]
mov [rax], r11
sub rax, 8
sub rdx, 8
loop copy_stack258
add rax, 8
mov rsp, rax
mov rbp, r9
jmp rbx
leave
ret
Lcont253: 

leave
ret
Lcont247: 

;back to applic: applic241
;assuming we get correct input, no need to check type closure 
CLOSURE_ENV rbx, rax ;rbx contains pointer to env
push rbx      ;push env pointer
CLOSURE_CODE rbx, rax 
call rbx
;clean stack
add rsp, WORD_SIZE *1 ; pop env
pop rbx               ; pop arg count
shl rbx, 3            ; rbx = rbx * 8
add rbx, WORD_SIZE    ; clean magic
add rsp, rbx          ; pop args
mov [fvar_tbl + 17 * WORD_SIZE], rax 
 lea rax, [const_tbl+1] 

	call write_sob_if_not_void

some_compiled_section281:
;define:
;applic:applic260
;push magic:
mov rbx, 0
push rbx
;free variable:
mov rax, qword [fvar_tbl + 17 * WORD_SIZE]

push rax
;free variable:
mov rax, qword [fvar_tbl + 47 * WORD_SIZE]

push rax
;back to applic: applic260
;push num of args: 
mov rbx,2
push rbx
;generate proc:
;simple lambda:
mov rbx, 0
shl rbx, 3
MALLOC rax, rbx
push rax; pushing ext_env for later 
;copying pointers:
mov rcx, 0
cmp rcx, 1
jle end_pointers_copy263
copy_pointers261:
push rcx
neg rcx
add rcx, 0
mov rbx, [rbp + WORD_SIZE * 2] ; getting pointer to old env
mov rdx, [rbx + rcx * WORD_SIZE] ; getting to rdx old_env[i]
inc rcx
mov [rax + WORD_SIZE * rcx], rdx ; putting env[i] (stored in rdx) into ext_env[i + 1]
pop rcx ; restoring counter
loop copy_pointers261
end_pointers_copy263:
mov rcx, [rbp + 3 * WORD_SIZE] ; getting to rcx the number of the current parameters 
inc rcx
shl rcx, 3
MALLOC rbx, rcx
mov qword [rax], rbx ; getting the new allocated memory pointer to ext_env[0]
mov rax, rbx ; more convinient with pointer to extenv[0] in rax 

mov rbx, rcx ; rbx will be constant and hold the size of params
; copying parameters to new env 
cmp rbx, 0
je end_parameters_copy264
copy_parameters262: 
push rcx
neg rcx
add rcx, rbx ; rcx starts high and decreases with iterations
lea rdx, [rbp + WORD_SIZE * rcx]
add rdx, 4 * WORD_SIZE ; now rdx has the address of param_i 
mov rdx, [rdx] ; now rdx has the param_i 
mov [rax + WORD_SIZE * rcx], rdx 
pop rcx
loop copy_parameters262
end_parameters_copy264:
pop rbx
MAKE_CLOSURE(rax, rbx, Lcode265)
jmp Lcont266
Lcode265: 
push rbp
mov rbp, rsp
;simple lambda:
mov rbx, 1
shl rbx, 3
MALLOC rax, rbx
push rax; pushing ext_env for later 
;copying pointers:
mov rcx, 1
cmp rcx, 1
jle end_pointers_copy269
copy_pointers267:
push rcx
neg rcx
add rcx, 1
mov rbx, [rbp + WORD_SIZE * 2] ; getting pointer to old env
mov rdx, [rbx + rcx * WORD_SIZE] ; getting to rdx old_env[i]
inc rcx
mov [rax + WORD_SIZE * rcx], rdx ; putting env[i] (stored in rdx) into ext_env[i + 1]
pop rcx ; restoring counter
loop copy_pointers267
end_pointers_copy269:
mov rcx, [rbp + 3 * WORD_SIZE] ; getting to rcx the number of the current parameters 
inc rcx
shl rcx, 3
MALLOC rbx, rcx
mov qword [rax], rbx ; getting the new allocated memory pointer to ext_env[0]
mov rax, rbx ; more convinient with pointer to extenv[0] in rax 

mov rbx, rcx ; rbx will be constant and hold the size of params
; copying parameters to new env 
cmp rbx, 0
je end_parameters_copy270
copy_parameters268: 
push rcx
neg rcx
add rcx, rbx ; rcx starts high and decreases with iterations
lea rdx, [rbp + WORD_SIZE * rcx]
add rdx, 4 * WORD_SIZE ; now rdx has the address of param_i 
mov rdx, [rdx] ; now rdx has the param_i 
mov [rax + WORD_SIZE * rcx], rdx 
pop rcx
loop copy_parameters268
end_parameters_copy270:
pop rbx
MAKE_CLOSURE(rax, rbx, Lcode271)
jmp Lcont272
Lcode271: 
push rbp
mov rbp, rsp
;applicTp:
;parameter variable:
mov rax, [rbp + WORD_SIZE * (4 + 0)]

push rax
;constant
lea rax, [const_tbl+ 32]

push rax
;simple lambda:
mov rbx, 2
shl rbx, 3
MALLOC rax, rbx
push rax; pushing ext_env for later 
;copying pointers:
mov rcx, 2
cmp rcx, 1
jle end_pointers_copy276
copy_pointers274:
push rcx
neg rcx
add rcx, 2
mov rbx, [rbp + WORD_SIZE * 2] ; getting pointer to old env
mov rdx, [rbx + rcx * WORD_SIZE] ; getting to rdx old_env[i]
inc rcx
mov [rax + WORD_SIZE * rcx], rdx ; putting env[i] (stored in rdx) into ext_env[i + 1]
pop rcx ; restoring counter
loop copy_pointers274
end_pointers_copy276:
mov rcx, [rbp + 3 * WORD_SIZE] ; getting to rcx the number of the current parameters 
inc rcx
shl rcx, 3
MALLOC rbx, rcx
mov qword [rax], rbx ; getting the new allocated memory pointer to ext_env[0]
mov rax, rbx ; more convinient with pointer to extenv[0] in rax 

mov rbx, rcx ; rbx will be constant and hold the size of params
; copying parameters to new env 
cmp rbx, 0
je end_parameters_copy277
copy_parameters275: 
push rcx
neg rcx
add rcx, rbx ; rcx starts high and decreases with iterations
lea rdx, [rbp + WORD_SIZE * rcx]
add rdx, 4 * WORD_SIZE ; now rdx has the address of param_i 
mov rdx, [rdx] ; now rdx has the param_i 
mov [rax + WORD_SIZE * rcx], rdx 
pop rcx
loop copy_parameters275
end_parameters_copy277:
pop rbx
MAKE_CLOSURE(rax, rbx, Lcode278)
jmp Lcont279
Lcode278: 
push rbp
mov rbp, rsp
;applicTp:
;constant
lea rax, [const_tbl+ 41]

push rax
;parameter variable:
mov rax, [rbp + WORD_SIZE * (4 + 0)]

push rax
;push num of args: 
mov rbx,2
push rbx
;generate proc:
;bound variable:
mov rbx, [rbp + WORD_SIZE * 2]
mov rbx, [rbx + WORD_SIZE * 1]
mov rax, [rbx + WORD_SIZE * 1]

;assuming we get correct input, no need to check type closure 
add rax, TYPE_SIZE 
mov rbx, [rax] ;rbx contains pointer to env
push rbx      ;push env pointer
add rax, WORD_SIZE 
mov rbx, [rax] ;rbx contains pointer to code ; (rbx contains pointer to code)
;------------------------changes in opt - do not use rbx ---------------------
push qword [rbp + WORD_SIZE ] ; push old ret addr
; lets get to rax the dst to copy
mov rax, [rbp + WORD_SIZE * 3]
mov r9, [rbp]
add rax, 3
shl rax, 3
add rax, rbp
; lets get to rdx the src to copy
mov rdx, [rsp + WORD_SIZE * 2]
mov r10, rdx
add rdx, 2
shl rdx, 3
add rdx, rsp
; lets get to rcx the number of iterations needed
lea rcx, [r10 + 3]
copy_stack280:

mov r11, [rdx]
mov [rax], r11
sub rax, 8
sub rdx, 8
loop copy_stack280
add rax, 8
mov rsp, rax
mov rbp, r9
jmp rbx
leave
ret
Lcont279: 

push rax
;push num of args: 
mov rbx,3
push rbx
;generate proc:
;bound variable:
mov rbx, [rbp + WORD_SIZE * 2]
mov rbx, [rbx + WORD_SIZE * 0]
mov rax, [rbx + WORD_SIZE * 0]

;assuming we get correct input, no need to check type closure 
add rax, TYPE_SIZE 
mov rbx, [rax] ;rbx contains pointer to env
push rbx      ;push env pointer
add rax, WORD_SIZE 
mov rbx, [rax] ;rbx contains pointer to code ; (rbx contains pointer to code)
;------------------------changes in opt - do not use rbx ---------------------
push qword [rbp + WORD_SIZE ] ; push old ret addr
; lets get to rax the dst to copy
mov rax, [rbp + WORD_SIZE * 3]
mov r9, [rbp]
add rax, 3
shl rax, 3
add rax, rbp
; lets get to rdx the src to copy
mov rdx, [rsp + WORD_SIZE * 2]
mov r10, rdx
add rdx, 2
shl rdx, 3
add rdx, rsp
; lets get to rcx the number of iterations needed
lea rcx, [r10 + 3]
copy_stack273:

mov r11, [rdx]
mov [rax], r11
sub rax, 8
sub rdx, 8
loop copy_stack273
add rax, 8
mov rsp, rax
mov rbp, r9
jmp rbx
leave
ret
Lcont272: 

leave
ret
Lcont266: 

;back to applic: applic260
;assuming we get correct input, no need to check type closure 
CLOSURE_ENV rbx, rax ;rbx contains pointer to env
push rbx      ;push env pointer
CLOSURE_CODE rbx, rax 
call rbx
;clean stack
add rsp, WORD_SIZE *1 ; pop env
pop rbx               ; pop arg count
shl rbx, 3            ; rbx = rbx * 8
add rbx, WORD_SIZE    ; clean magic
add rsp, rbx          ; pop args
mov [fvar_tbl + 51 * WORD_SIZE], rax 
 lea rax, [const_tbl+1] 

	call write_sob_if_not_void

some_compiled_section305:
;define:
;applic:applic282
;push magic:
mov rbx, 0
push rbx
;free variable:
mov rax, qword [fvar_tbl + 12 * WORD_SIZE]

push rax
;free variable:
mov rax, qword [fvar_tbl + 23 * WORD_SIZE]

push rax
;free variable:
mov rax, qword [fvar_tbl + 4 * WORD_SIZE]

push rax
;back to applic: applic282
;push num of args: 
mov rbx,3
push rbx
;generate proc:
;simple lambda:
mov rbx, 0
shl rbx, 3
MALLOC rax, rbx
push rax; pushing ext_env for later 
;copying pointers:
mov rcx, 0
cmp rcx, 1
jle end_pointers_copy285
copy_pointers283:
push rcx
neg rcx
add rcx, 0
mov rbx, [rbp + WORD_SIZE * 2] ; getting pointer to old env
mov rdx, [rbx + rcx * WORD_SIZE] ; getting to rdx old_env[i]
inc rcx
mov [rax + WORD_SIZE * rcx], rdx ; putting env[i] (stored in rdx) into ext_env[i + 1]
pop rcx ; restoring counter
loop copy_pointers283
end_pointers_copy285:
mov rcx, [rbp + 3 * WORD_SIZE] ; getting to rcx the number of the current parameters 
inc rcx
shl rcx, 3
MALLOC rbx, rcx
mov qword [rax], rbx ; getting the new allocated memory pointer to ext_env[0]
mov rax, rbx ; more convinient with pointer to extenv[0] in rax 

mov rbx, rcx ; rbx will be constant and hold the size of params
; copying parameters to new env 
cmp rbx, 0
je end_parameters_copy286
copy_parameters284: 
push rcx
neg rcx
add rcx, rbx ; rcx starts high and decreases with iterations
lea rdx, [rbp + WORD_SIZE * rcx]
add rdx, 4 * WORD_SIZE ; now rdx has the address of param_i 
mov rdx, [rdx] ; now rdx has the param_i 
mov [rax + WORD_SIZE * rcx], rdx 
pop rcx
loop copy_parameters284
end_parameters_copy286:
pop rbx
MAKE_CLOSURE(rax, rbx, Lcode287)
jmp Lcont288
Lcode287: 
push rbp
mov rbp, rsp
; , x
; lambda optional: 
mov rbx, 1
shl rbx, 3
MALLOC rax, rbx
push rax ; pushing ext_env for later 
;copying pointers:
mov rcx, 1
cmp rcx, 1
jle end_pointers_copy291
copy_pointers289:
push rcx
neg rcx
add rcx, 1
mov rbx, [rbp + WORD_SIZE * 2] ; getting pointer to old env
mov rdx, [rbx + rcx * WORD_SIZE] ; getting to rdx old_env[i]
inc rcx
mov [rax + WORD_SIZE * rcx], rdx ; putting env[i] (stored in rdx) into ext_env[i + 1]
pop rcx ; restoring counter
loop copy_pointers289
end_pointers_copy291:
mov rcx, [rbp + 3 * WORD_SIZE] ; getting to rcx the number of the current parameters 
inc rcx
shl rcx, 3
MALLOC rbx, rcx
mov qword [rax], rbx ; getting the new allocated memory pointer to ext_env[0]
mov rax, rbx ; more convinient with pointer to extenv[0] in rax 

mov rbx, rcx ; rbx will be constant and hold the size of params
; copying parameters to new env 
cmp rbx, 0
je end_parameters_copy292
copy_parameters290: 
push rcx
neg rcx
add rcx, rbx ; rcx starts high and decreases with iterations
lea rdx, [rbp + WORD_SIZE * rcx]
add rdx, 4 * WORD_SIZE ; now rdx has the address of param_i 
mov rdx, [rdx] ; now rdx has the param_i 
mov [rax + WORD_SIZE * rcx], rdx 
pop rcx
loop copy_parameters290
end_parameters_copy292:
pop rbx
MAKE_CLOSURE(rax, rbx, Lcode293)
jmp Lcont294
Lcode293: 
push rbp
mov rbp, rsp
mov rax, [rbp + WORD_SIZE * 3] ; rax <- n 
cmp rax, 1; n =? |must|
jne opt_list_creation296
lea rbx, [rbp + WORD_SIZE * (rax + 4)] ; magic <- Nil
mov qword [rbx], const_tbl
jmp actual_code295
opt_list_creation296:
mov rbx, const_tbl
dec rax ; rax <- n - 1
make_list_loop297: ; create list loop 
mov rcx, [rbp + WORD_SIZE * (4 + rax)] ; rcx <- params[i]
MAKE_PAIR(rdx, rcx, rbx)
mov rbx, rdx
dec rax
cmp rax, 1
jge make_list_loop297
mov rax, [rbp + WORD_SIZE * 3]
dec rax; rax <- n - 1
mov [rbp + WORD_SIZE * (4 + rax)], rbx; save optional list on the stack
sub rax, 1 ; constant rax <- n - 1 - |must| (offset to move)
jz actual_code295
lea rcx, [4 + 1] ; i <- must_length + 4 
stack_reduction298:

push rcx
dec rcx
mov rbx, [rbp + WORD_SIZE * rcx]
add rcx, rax
mov [rbp + WORD_SIZE * rcx], rbx
pop rcx
loop stack_reduction298
lea rsp, [rsp + WORD_SIZE * rax]
mov rbp, rsp
mov qword [rbp + WORD_SIZE * 3], 1
actual_code295:
;if:
;applic:applic304
;push magic:
mov rbx, 0
push rbx
;parameter variable:
mov rax, [rbp + WORD_SIZE * (4 + 1)]

push rax
;back to applic: applic304
;push num of args: 
mov rbx,1
push rbx
;generate proc:
;bound variable:
mov rbx, [rbp + WORD_SIZE * 2]
mov rbx, [rbx + WORD_SIZE * 0]
mov rax, [rbx + WORD_SIZE * 0]

;back to applic: applic304
;assuming we get correct input, no need to check type closure 
CLOSURE_ENV rbx, rax ;rbx contains pointer to env
push rbx      ;push env pointer
CLOSURE_CODE rbx, rax 
call rbx
;clean stack
add rsp, WORD_SIZE *1 ; pop env
pop rbx               ; pop arg count
shl rbx, 3            ; rbx = rbx * 8
add rbx, WORD_SIZE    ; clean magic
add rsp, rbx          ; pop args

 cmp rax, SOB_FALSE_ADDRESS 
 je Lelse300 
;applicTp:
;constant
lea rax, [const_tbl+ 50]

push rax
;parameter variable:
mov rax, [rbp + WORD_SIZE * (4 + 0)]

push rax
;push num of args: 
mov rbx,2
push rbx
;generate proc:
;bound variable:
mov rbx, [rbp + WORD_SIZE * 2]
mov rbx, [rbx + WORD_SIZE * 0]
mov rax, [rbx + WORD_SIZE * 2]

;assuming we get correct input, no need to check type closure 
add rax, TYPE_SIZE 
mov rbx, [rax] ;rbx contains pointer to env
push rbx      ;push env pointer
add rax, WORD_SIZE 
mov rbx, [rax] ;rbx contains pointer to code ; (rbx contains pointer to code)
;------------------------changes in opt - do not use rbx ---------------------
push qword [rbp + WORD_SIZE ] ; push old ret addr
; lets get to rax the dst to copy
mov rax, [rbp + WORD_SIZE * 3]
mov r9, [rbp]
add rax, 3
shl rax, 3
add rax, rbp
; lets get to rdx the src to copy
mov rdx, [rsp + WORD_SIZE * 2]
mov r10, rdx
add rdx, 2
shl rdx, 3
add rdx, rsp
; lets get to rcx the number of iterations needed
lea rcx, [r10 + 3]
copy_stack303:

mov r11, [rdx]
mov [rax], r11
sub rax, 8
sub rdx, 8
loop copy_stack303
add rax, 8
mov rsp, rax
mov rbp, r9
jmp rbx
 jmp Lexit299 
 Lelse300:
;applicTp:
;applic:applic302
;push magic:
mov rbx, 0
push rbx
;parameter variable:
mov rax, [rbp + WORD_SIZE * (4 + 1)]

push rax
;back to applic: applic302
;push num of args: 
mov rbx,1
push rbx
;generate proc:
;bound variable:
mov rbx, [rbp + WORD_SIZE * 2]
mov rbx, [rbx + WORD_SIZE * 0]
mov rax, [rbx + WORD_SIZE * 1]

;back to applic: applic302
;assuming we get correct input, no need to check type closure 
CLOSURE_ENV rbx, rax ;rbx contains pointer to env
push rbx      ;push env pointer
CLOSURE_CODE rbx, rax 
call rbx
;clean stack
add rsp, WORD_SIZE *1 ; pop env
pop rbx               ; pop arg count
shl rbx, 3            ; rbx = rbx * 8
add rbx, WORD_SIZE    ; clean magic
add rsp, rbx          ; pop args

push rax
;parameter variable:
mov rax, [rbp + WORD_SIZE * (4 + 0)]

push rax
;push num of args: 
mov rbx,2
push rbx
;generate proc:
;bound variable:
mov rbx, [rbp + WORD_SIZE * 2]
mov rbx, [rbx + WORD_SIZE * 0]
mov rax, [rbx + WORD_SIZE * 2]

;assuming we get correct input, no need to check type closure 
add rax, TYPE_SIZE 
mov rbx, [rax] ;rbx contains pointer to env
push rbx      ;push env pointer
add rax, WORD_SIZE 
mov rbx, [rax] ;rbx contains pointer to code ; (rbx contains pointer to code)
;------------------------changes in opt - do not use rbx ---------------------
push qword [rbp + WORD_SIZE ] ; push old ret addr
; lets get to rax the dst to copy
mov rax, [rbp + WORD_SIZE * 3]
mov r9, [rbp]
add rax, 3
shl rax, 3
add rax, rbp
; lets get to rdx the src to copy
mov rdx, [rsp + WORD_SIZE * 2]
mov r10, rdx
add rdx, 2
shl rdx, 3
add rdx, rsp
; lets get to rcx the number of iterations needed
lea rcx, [r10 + 3]
copy_stack301:

mov r11, [rdx]
mov [rax], r11
sub rax, 8
sub rdx, 8
loop copy_stack301
add rax, 8
mov rsp, rax
mov rbp, r9
jmp rbx
 Lexit299: 

leave
ret
Lcont294: 

leave
ret
Lcont288: 

;back to applic: applic282
;assuming we get correct input, no need to check type closure 
CLOSURE_ENV rbx, rax ;rbx contains pointer to env
push rbx      ;push env pointer
CLOSURE_CODE rbx, rax 
call rbx
;clean stack
add rsp, WORD_SIZE *1 ; pop env
pop rbx               ; pop arg count
shl rbx, 3            ; rbx = rbx * 8
add rbx, WORD_SIZE    ; clean magic
add rsp, rbx          ; pop args
mov [fvar_tbl + 12 * WORD_SIZE], rax 
 lea rax, [const_tbl+1] 

	call write_sob_if_not_void

some_compiled_section314:
;define:
;simple lambda:
mov rbx, 0
shl rbx, 3
MALLOC rax, rbx
push rax; pushing ext_env for later 
;copying pointers:
mov rcx, 0
cmp rcx, 1
jle end_pointers_copy308
copy_pointers306:
push rcx
neg rcx
add rcx, 0
mov rbx, [rbp + WORD_SIZE * 2] ; getting pointer to old env
mov rdx, [rbx + rcx * WORD_SIZE] ; getting to rdx old_env[i]
inc rcx
mov [rax + WORD_SIZE * rcx], rdx ; putting env[i] (stored in rdx) into ext_env[i + 1]
pop rcx ; restoring counter
loop copy_pointers306
end_pointers_copy308:
mov rcx, [rbp + 3 * WORD_SIZE] ; getting to rcx the number of the current parameters 
inc rcx
shl rcx, 3
MALLOC rbx, rcx
mov qword [rax], rbx ; getting the new allocated memory pointer to ext_env[0]
mov rax, rbx ; more convinient with pointer to extenv[0] in rax 

mov rbx, rcx ; rbx will be constant and hold the size of params
; copying parameters to new env 
cmp rbx, 0
je end_parameters_copy309
copy_parameters307: 
push rcx
neg rcx
add rcx, rbx ; rcx starts high and decreases with iterations
lea rdx, [rbp + WORD_SIZE * rcx]
add rdx, 4 * WORD_SIZE ; now rdx has the address of param_i 
mov rdx, [rdx] ; now rdx has the param_i 
mov [rax + WORD_SIZE * rcx], rdx 
pop rcx
loop copy_parameters307
end_parameters_copy309:
pop rbx
MAKE_CLOSURE(rax, rbx, Lcode310)
jmp Lcont311
Lcode310: 
push rbp
mov rbp, rsp
;if:
;parameter variable:
mov rax, [rbp + WORD_SIZE * (4 + 0)]

 cmp rax, SOB_FALSE_ADDRESS 
 je Lelse313 
;constant
lea rax, [const_tbl+ 4]

 jmp Lexit312 
 Lelse313:
;constant
lea rax, [const_tbl+ 2]

 Lexit312: 

leave
ret
Lcont311: 
mov [fvar_tbl + 56 * WORD_SIZE], rax 
 lea rax, [const_tbl+1] 

	call write_sob_if_not_void

some_compiled_section331:
;define:
;applic:applic315
;push magic:
mov rbx, 0
push rbx
;free variable:
mov rax, qword [fvar_tbl + 2 * WORD_SIZE]

push rax
;free variable:
mov rax, qword [fvar_tbl + 1 * WORD_SIZE]

push rax
;back to applic: applic315
;push num of args: 
mov rbx,2
push rbx
;generate proc:
;simple lambda:
mov rbx, 0
shl rbx, 3
MALLOC rax, rbx
push rax; pushing ext_env for later 
;copying pointers:
mov rcx, 0
cmp rcx, 1
jle end_pointers_copy318
copy_pointers316:
push rcx
neg rcx
add rcx, 0
mov rbx, [rbp + WORD_SIZE * 2] ; getting pointer to old env
mov rdx, [rbx + rcx * WORD_SIZE] ; getting to rdx old_env[i]
inc rcx
mov [rax + WORD_SIZE * rcx], rdx ; putting env[i] (stored in rdx) into ext_env[i + 1]
pop rcx ; restoring counter
loop copy_pointers316
end_pointers_copy318:
mov rcx, [rbp + 3 * WORD_SIZE] ; getting to rcx the number of the current parameters 
inc rcx
shl rcx, 3
MALLOC rbx, rcx
mov qword [rax], rbx ; getting the new allocated memory pointer to ext_env[0]
mov rax, rbx ; more convinient with pointer to extenv[0] in rax 

mov rbx, rcx ; rbx will be constant and hold the size of params
; copying parameters to new env 
cmp rbx, 0
je end_parameters_copy319
copy_parameters317: 
push rcx
neg rcx
add rcx, rbx ; rcx starts high and decreases with iterations
lea rdx, [rbp + WORD_SIZE * rcx]
add rdx, 4 * WORD_SIZE ; now rdx has the address of param_i 
mov rdx, [rdx] ; now rdx has the param_i 
mov [rax + WORD_SIZE * rcx], rdx 
pop rcx
loop copy_parameters317
end_parameters_copy319:
pop rbx
MAKE_CLOSURE(rax, rbx, Lcode320)
jmp Lcont321
Lcode320: 
push rbp
mov rbp, rsp
;simple lambda:
mov rbx, 1
shl rbx, 3
MALLOC rax, rbx
push rax; pushing ext_env for later 
;copying pointers:
mov rcx, 1
cmp rcx, 1
jle end_pointers_copy324
copy_pointers322:
push rcx
neg rcx
add rcx, 1
mov rbx, [rbp + WORD_SIZE * 2] ; getting pointer to old env
mov rdx, [rbx + rcx * WORD_SIZE] ; getting to rdx old_env[i]
inc rcx
mov [rax + WORD_SIZE * rcx], rdx ; putting env[i] (stored in rdx) into ext_env[i + 1]
pop rcx ; restoring counter
loop copy_pointers322
end_pointers_copy324:
mov rcx, [rbp + 3 * WORD_SIZE] ; getting to rcx the number of the current parameters 
inc rcx
shl rcx, 3
MALLOC rbx, rcx
mov qword [rax], rbx ; getting the new allocated memory pointer to ext_env[0]
mov rax, rbx ; more convinient with pointer to extenv[0] in rax 

mov rbx, rcx ; rbx will be constant and hold the size of params
; copying parameters to new env 
cmp rbx, 0
je end_parameters_copy325
copy_parameters323: 
push rcx
neg rcx
add rcx, rbx ; rcx starts high and decreases with iterations
lea rdx, [rbp + WORD_SIZE * rcx]
add rdx, 4 * WORD_SIZE ; now rdx has the address of param_i 
mov rdx, [rdx] ; now rdx has the param_i 
mov [rax + WORD_SIZE * rcx], rdx 
pop rcx
loop copy_parameters323
end_parameters_copy325:
pop rbx
MAKE_CLOSURE(rax, rbx, Lcode326)
jmp Lcont327
Lcode326: 
push rbp
mov rbp, rsp
;or:
;applic:applic328
;push magic:
mov rbx, 0
push rbx
;parameter variable:
mov rax, [rbp + WORD_SIZE * (4 + 0)]

push rax
;back to applic: applic328
;push num of args: 
mov rbx,1
push rbx
;generate proc:
;bound variable:
mov rbx, [rbp + WORD_SIZE * 2]
mov rbx, [rbx + WORD_SIZE * 0]
mov rax, [rbx + WORD_SIZE * 0]

;back to applic: applic328
;assuming we get correct input, no need to check type closure 
CLOSURE_ENV rbx, rax ;rbx contains pointer to env
push rbx      ;push env pointer
CLOSURE_CODE rbx, rax 
call rbx
;clean stack
add rsp, WORD_SIZE *1 ; pop env
pop rbx               ; pop arg count
shl rbx, 3            ; rbx = rbx * 8
add rbx, WORD_SIZE    ; clean magic
add rsp, rbx          ; pop args

 cmp rax, SOB_FALSE_ADDRESS 
 jne Lexit330
;applicTp:
;parameter variable:
mov rax, [rbp + WORD_SIZE * (4 + 0)]

push rax
;push num of args: 
mov rbx,1
push rbx
;generate proc:
;bound variable:
mov rbx, [rbp + WORD_SIZE * 2]
mov rbx, [rbx + WORD_SIZE * 0]
mov rax, [rbx + WORD_SIZE * 1]

;assuming we get correct input, no need to check type closure 
add rax, TYPE_SIZE 
mov rbx, [rax] ;rbx contains pointer to env
push rbx      ;push env pointer
add rax, WORD_SIZE 
mov rbx, [rax] ;rbx contains pointer to code ; (rbx contains pointer to code)
;------------------------changes in opt - do not use rbx ---------------------
push qword [rbp + WORD_SIZE ] ; push old ret addr
; lets get to rax the dst to copy
mov rax, [rbp + WORD_SIZE * 3]
mov r9, [rbp]
add rax, 3
shl rax, 3
add rax, rbp
; lets get to rdx the src to copy
mov rdx, [rsp + WORD_SIZE * 2]
mov r10, rdx
add rdx, 2
shl rdx, 3
add rdx, rsp
; lets get to rcx the number of iterations needed
lea rcx, [r10 + 3]
copy_stack329:

mov r11, [rdx]
mov [rax], r11
sub rax, 8
sub rdx, 8
loop copy_stack329
add rax, 8
mov rsp, rax
mov rbp, r9
jmp rbx
 Lexit330: 
leave
ret
Lcont327: 

leave
ret
Lcont321: 

;back to applic: applic315
;assuming we get correct input, no need to check type closure 
CLOSURE_ENV rbx, rax ;rbx contains pointer to env
push rbx      ;push env pointer
CLOSURE_CODE rbx, rax 
call rbx
;clean stack
add rsp, WORD_SIZE *1 ; pop env
pop rbx               ; pop arg count
shl rbx, 3            ; rbx = rbx * 8
add rbx, WORD_SIZE    ; clean magic
add rsp, rbx          ; pop args
mov [fvar_tbl + 58 * WORD_SIZE], rax 
 lea rax, [const_tbl+1] 

	call write_sob_if_not_void

some_compiled_section350:
;define:
;applic:applic332
;push magic:
mov rbx, 0
push rbx
;free variable:
mov rax, qword [fvar_tbl + 18 * WORD_SIZE]

push rax
;free variable:
mov rax, qword [fvar_tbl + 47 * WORD_SIZE]

push rax
;back to applic: applic332
;push num of args: 
mov rbx,2
push rbx
;generate proc:
;simple lambda:
mov rbx, 0
shl rbx, 3
MALLOC rax, rbx
push rax; pushing ext_env for later 
;copying pointers:
mov rcx, 0
cmp rcx, 1
jle end_pointers_copy335
copy_pointers333:
push rcx
neg rcx
add rcx, 0
mov rbx, [rbp + WORD_SIZE * 2] ; getting pointer to old env
mov rdx, [rbx + rcx * WORD_SIZE] ; getting to rdx old_env[i]
inc rcx
mov [rax + WORD_SIZE * rcx], rdx ; putting env[i] (stored in rdx) into ext_env[i + 1]
pop rcx ; restoring counter
loop copy_pointers333
end_pointers_copy335:
mov rcx, [rbp + 3 * WORD_SIZE] ; getting to rcx the number of the current parameters 
inc rcx
shl rcx, 3
MALLOC rbx, rcx
mov qword [rax], rbx ; getting the new allocated memory pointer to ext_env[0]
mov rax, rbx ; more convinient with pointer to extenv[0] in rax 

mov rbx, rcx ; rbx will be constant and hold the size of params
; copying parameters to new env 
cmp rbx, 0
je end_parameters_copy336
copy_parameters334: 
push rcx
neg rcx
add rcx, rbx ; rcx starts high and decreases with iterations
lea rdx, [rbp + WORD_SIZE * rcx]
add rdx, 4 * WORD_SIZE ; now rdx has the address of param_i 
mov rdx, [rdx] ; now rdx has the param_i 
mov [rax + WORD_SIZE * rcx], rdx 
pop rcx
loop copy_parameters334
end_parameters_copy336:
pop rbx
MAKE_CLOSURE(rax, rbx, Lcode337)
jmp Lcont338
Lcode337: 
push rbp
mov rbp, rsp
; 
; lambda optional: 
mov rbx, 1
shl rbx, 3
MALLOC rax, rbx
push rax ; pushing ext_env for later 
;copying pointers:
mov rcx, 1
cmp rcx, 1
jle end_pointers_copy341
copy_pointers339:
push rcx
neg rcx
add rcx, 1
mov rbx, [rbp + WORD_SIZE * 2] ; getting pointer to old env
mov rdx, [rbx + rcx * WORD_SIZE] ; getting to rdx old_env[i]
inc rcx
mov [rax + WORD_SIZE * rcx], rdx ; putting env[i] (stored in rdx) into ext_env[i + 1]
pop rcx ; restoring counter
loop copy_pointers339
end_pointers_copy341:
mov rcx, [rbp + 3 * WORD_SIZE] ; getting to rcx the number of the current parameters 
inc rcx
shl rcx, 3
MALLOC rbx, rcx
mov qword [rax], rbx ; getting the new allocated memory pointer to ext_env[0]
mov rax, rbx ; more convinient with pointer to extenv[0] in rax 

mov rbx, rcx ; rbx will be constant and hold the size of params
; copying parameters to new env 
cmp rbx, 0
je end_parameters_copy342
copy_parameters340: 
push rcx
neg rcx
add rcx, rbx ; rcx starts high and decreases with iterations
lea rdx, [rbp + WORD_SIZE * rcx]
add rdx, 4 * WORD_SIZE ; now rdx has the address of param_i 
mov rdx, [rdx] ; now rdx has the param_i 
mov [rax + WORD_SIZE * rcx], rdx 
pop rcx
loop copy_parameters340
end_parameters_copy342:
pop rbx
MAKE_CLOSURE(rax, rbx, Lcode343)
jmp Lcont344
Lcode343: 
push rbp
mov rbp, rsp
mov rax, [rbp + WORD_SIZE * 3] ; rax <- n 
cmp rax, 0; n =? |must|
jne opt_list_creation346
lea rbx, [rbp + WORD_SIZE * (rax + 4)] ; magic <- Nil
mov qword [rbx], const_tbl
jmp actual_code345
opt_list_creation346:
mov rbx, const_tbl
dec rax ; rax <- n - 1
make_list_loop347: ; create list loop 
mov rcx, [rbp + WORD_SIZE * (4 + rax)] ; rcx <- params[i]
MAKE_PAIR(rdx, rcx, rbx)
mov rbx, rdx
dec rax
cmp rax, 0
jge make_list_loop347
mov rax, [rbp + WORD_SIZE * 3]
dec rax; rax <- n - 1
mov [rbp + WORD_SIZE * (4 + rax)], rbx; save optional list on the stack
sub rax, 0 ; constant rax <- n - 1 - |must| (offset to move)
jz actual_code345
lea rcx, [4 + 0] ; i <- must_length + 4 
stack_reduction348:

push rcx
dec rcx
mov rbx, [rbp + WORD_SIZE * rcx]
add rcx, rax
mov [rbp + WORD_SIZE * rcx], rbx
pop rcx
loop stack_reduction348
lea rsp, [rsp + WORD_SIZE * rax]
mov rbp, rsp
mov qword [rbp + WORD_SIZE * 3], 0
actual_code345:
;applicTp:
;parameter variable:
mov rax, [rbp + WORD_SIZE * (4 + 0)]

push rax
;constant
lea rax, [const_tbl+ 41]

push rax
;bound variable:
mov rbx, [rbp + WORD_SIZE * 2]
mov rbx, [rbx + WORD_SIZE * 0]
mov rax, [rbx + WORD_SIZE * 1]

push rax
;push num of args: 
mov rbx,3
push rbx
;generate proc:
;bound variable:
mov rbx, [rbp + WORD_SIZE * 2]
mov rbx, [rbx + WORD_SIZE * 0]
mov rax, [rbx + WORD_SIZE * 0]

;assuming we get correct input, no need to check type closure 
add rax, TYPE_SIZE 
mov rbx, [rax] ;rbx contains pointer to env
push rbx      ;push env pointer
add rax, WORD_SIZE 
mov rbx, [rax] ;rbx contains pointer to code ; (rbx contains pointer to code)
;------------------------changes in opt - do not use rbx ---------------------
push qword [rbp + WORD_SIZE ] ; push old ret addr
; lets get to rax the dst to copy
mov rax, [rbp + WORD_SIZE * 3]
mov r9, [rbp]
add rax, 3
shl rax, 3
add rax, rbp
; lets get to rdx the src to copy
mov rdx, [rsp + WORD_SIZE * 2]
mov r10, rdx
add rdx, 2
shl rdx, 3
add rdx, rsp
; lets get to rcx the number of iterations needed
lea rcx, [r10 + 3]
copy_stack349:

mov r11, [rdx]
mov [rax], r11
sub rax, 8
sub rdx, 8
loop copy_stack349
add rax, 8
mov rsp, rax
mov rbp, r9
jmp rbx
leave
ret
Lcont344: 

leave
ret
Lcont338: 

;back to applic: applic332
;assuming we get correct input, no need to check type closure 
CLOSURE_ENV rbx, rax ;rbx contains pointer to env
push rbx      ;push env pointer
CLOSURE_CODE rbx, rax 
call rbx
;clean stack
add rsp, WORD_SIZE *1 ; pop env
pop rbx               ; pop arg count
shl rbx, 3            ; rbx = rbx * 8
add rbx, WORD_SIZE    ; clean magic
add rsp, rbx          ; pop args
mov [fvar_tbl + 18 * WORD_SIZE], rax 
 lea rax, [const_tbl+1] 

	call write_sob_if_not_void

some_compiled_section374:
;define:
;applic:applic351
;push magic:
mov rbx, 0
push rbx
;free variable:
mov rax, qword [fvar_tbl + 4 * WORD_SIZE]

push rax
;free variable:
mov rax, qword [fvar_tbl + 17 * WORD_SIZE]

push rax
;free variable:
mov rax, qword [fvar_tbl + 19 * WORD_SIZE]

push rax
;free variable:
mov rax, qword [fvar_tbl + 28 * WORD_SIZE]

push rax
;back to applic: applic351
;push num of args: 
mov rbx,4
push rbx
;generate proc:
;simple lambda:
mov rbx, 0
shl rbx, 3
MALLOC rax, rbx
push rax; pushing ext_env for later 
;copying pointers:
mov rcx, 0
cmp rcx, 1
jle end_pointers_copy354
copy_pointers352:
push rcx
neg rcx
add rcx, 0
mov rbx, [rbp + WORD_SIZE * 2] ; getting pointer to old env
mov rdx, [rbx + rcx * WORD_SIZE] ; getting to rdx old_env[i]
inc rcx
mov [rax + WORD_SIZE * rcx], rdx ; putting env[i] (stored in rdx) into ext_env[i + 1]
pop rcx ; restoring counter
loop copy_pointers352
end_pointers_copy354:
mov rcx, [rbp + 3 * WORD_SIZE] ; getting to rcx the number of the current parameters 
inc rcx
shl rcx, 3
MALLOC rbx, rcx
mov qword [rax], rbx ; getting the new allocated memory pointer to ext_env[0]
mov rax, rbx ; more convinient with pointer to extenv[0] in rax 

mov rbx, rcx ; rbx will be constant and hold the size of params
; copying parameters to new env 
cmp rbx, 0
je end_parameters_copy355
copy_parameters353: 
push rcx
neg rcx
add rcx, rbx ; rcx starts high and decreases with iterations
lea rdx, [rbp + WORD_SIZE * rcx]
add rdx, 4 * WORD_SIZE ; now rdx has the address of param_i 
mov rdx, [rdx] ; now rdx has the param_i 
mov [rax + WORD_SIZE * rcx], rdx 
pop rcx
loop copy_parameters353
end_parameters_copy355:
pop rbx
MAKE_CLOSURE(rax, rbx, Lcode356)
jmp Lcont357
Lcode356: 
push rbp
mov rbp, rsp
; , x
; lambda optional: 
mov rbx, 1
shl rbx, 3
MALLOC rax, rbx
push rax ; pushing ext_env for later 
;copying pointers:
mov rcx, 1
cmp rcx, 1
jle end_pointers_copy360
copy_pointers358:
push rcx
neg rcx
add rcx, 1
mov rbx, [rbp + WORD_SIZE * 2] ; getting pointer to old env
mov rdx, [rbx + rcx * WORD_SIZE] ; getting to rdx old_env[i]
inc rcx
mov [rax + WORD_SIZE * rcx], rdx ; putting env[i] (stored in rdx) into ext_env[i + 1]
pop rcx ; restoring counter
loop copy_pointers358
end_pointers_copy360:
mov rcx, [rbp + 3 * WORD_SIZE] ; getting to rcx the number of the current parameters 
inc rcx
shl rcx, 3
MALLOC rbx, rcx
mov qword [rax], rbx ; getting the new allocated memory pointer to ext_env[0]
mov rax, rbx ; more convinient with pointer to extenv[0] in rax 

mov rbx, rcx ; rbx will be constant and hold the size of params
; copying parameters to new env 
cmp rbx, 0
je end_parameters_copy361
copy_parameters359: 
push rcx
neg rcx
add rcx, rbx ; rcx starts high and decreases with iterations
lea rdx, [rbp + WORD_SIZE * rcx]
add rdx, 4 * WORD_SIZE ; now rdx has the address of param_i 
mov rdx, [rdx] ; now rdx has the param_i 
mov [rax + WORD_SIZE * rcx], rdx 
pop rcx
loop copy_parameters359
end_parameters_copy361:
pop rbx
MAKE_CLOSURE(rax, rbx, Lcode362)
jmp Lcont363
Lcode362: 
push rbp
mov rbp, rsp
mov rax, [rbp + WORD_SIZE * 3] ; rax <- n 
cmp rax, 1; n =? |must|
jne opt_list_creation365
lea rbx, [rbp + WORD_SIZE * (rax + 4)] ; magic <- Nil
mov qword [rbx], const_tbl
jmp actual_code364
opt_list_creation365:
mov rbx, const_tbl
dec rax ; rax <- n - 1
make_list_loop366: ; create list loop 
mov rcx, [rbp + WORD_SIZE * (4 + rax)] ; rcx <- params[i]
MAKE_PAIR(rdx, rcx, rbx)
mov rbx, rdx
dec rax
cmp rax, 1
jge make_list_loop366
mov rax, [rbp + WORD_SIZE * 3]
dec rax; rax <- n - 1
mov [rbp + WORD_SIZE * (4 + rax)], rbx; save optional list on the stack
sub rax, 1 ; constant rax <- n - 1 - |must| (offset to move)
jz actual_code364
lea rcx, [4 + 1] ; i <- must_length + 4 
stack_reduction367:

push rcx
dec rcx
mov rbx, [rbp + WORD_SIZE * rcx]
add rcx, rax
mov [rbp + WORD_SIZE * rcx], rbx
pop rcx
loop stack_reduction367
lea rsp, [rsp + WORD_SIZE * rax]
mov rbp, rsp
mov qword [rbp + WORD_SIZE * 3], 1
actual_code364:
;if:
;applic:applic373
;push magic:
mov rbx, 0
push rbx
;parameter variable:
mov rax, [rbp + WORD_SIZE * (4 + 1)]

push rax
;back to applic: applic373
;push num of args: 
mov rbx,1
push rbx
;generate proc:
;bound variable:
mov rbx, [rbp + WORD_SIZE * 2]
mov rbx, [rbx + WORD_SIZE * 0]
mov rax, [rbx + WORD_SIZE * 3]

;back to applic: applic373
;assuming we get correct input, no need to check type closure 
CLOSURE_ENV rbx, rax ;rbx contains pointer to env
push rbx      ;push env pointer
CLOSURE_CODE rbx, rax 
call rbx
;clean stack
add rsp, WORD_SIZE *1 ; pop env
pop rbx               ; pop arg count
shl rbx, 3            ; rbx = rbx * 8
add rbx, WORD_SIZE    ; clean magic
add rsp, rbx          ; pop args

 cmp rax, SOB_FALSE_ADDRESS 
 je Lelse369 
;applicTp:
;parameter variable:
mov rax, [rbp + WORD_SIZE * (4 + 0)]

push rax
;constant
lea rax, [const_tbl+ 32]

push rax
;push num of args: 
mov rbx,2
push rbx
;generate proc:
;bound variable:
mov rbx, [rbp + WORD_SIZE * 2]
mov rbx, [rbx + WORD_SIZE * 0]
mov rax, [rbx + WORD_SIZE * 1]

;assuming we get correct input, no need to check type closure 
add rax, TYPE_SIZE 
mov rbx, [rax] ;rbx contains pointer to env
push rbx      ;push env pointer
add rax, WORD_SIZE 
mov rbx, [rax] ;rbx contains pointer to code ; (rbx contains pointer to code)
;------------------------changes in opt - do not use rbx ---------------------
push qword [rbp + WORD_SIZE ] ; push old ret addr
; lets get to rax the dst to copy
mov rax, [rbp + WORD_SIZE * 3]
mov r9, [rbp]
add rax, 3
shl rax, 3
add rax, rbp
; lets get to rdx the src to copy
mov rdx, [rsp + WORD_SIZE * 2]
mov r10, rdx
add rdx, 2
shl rdx, 3
add rdx, rsp
; lets get to rcx the number of iterations needed
lea rcx, [r10 + 3]
copy_stack372:

mov r11, [rdx]
mov [rax], r11
sub rax, 8
sub rdx, 8
loop copy_stack372
add rax, 8
mov rsp, rax
mov rbp, r9
jmp rbx
 jmp Lexit368 
 Lelse369:
;applicTp:
;applic:applic371
;push magic:
mov rbx, 0
push rbx
;parameter variable:
mov rax, [rbp + WORD_SIZE * (4 + 1)]

push rax
;bound variable:
mov rbx, [rbp + WORD_SIZE * 2]
mov rbx, [rbx + WORD_SIZE * 0]
mov rax, [rbx + WORD_SIZE * 2]

push rax
;back to applic: applic371
;push num of args: 
mov rbx,2
push rbx
;generate proc:
;bound variable:
mov rbx, [rbp + WORD_SIZE * 2]
mov rbx, [rbx + WORD_SIZE * 0]
mov rax, [rbx + WORD_SIZE * 0]

;back to applic: applic371
;assuming we get correct input, no need to check type closure 
CLOSURE_ENV rbx, rax ;rbx contains pointer to env
push rbx      ;push env pointer
CLOSURE_CODE rbx, rax 
call rbx
;clean stack
add rsp, WORD_SIZE *1 ; pop env
pop rbx               ; pop arg count
shl rbx, 3            ; rbx = rbx * 8
add rbx, WORD_SIZE    ; clean magic
add rsp, rbx          ; pop args

push rax
;parameter variable:
mov rax, [rbp + WORD_SIZE * (4 + 0)]

push rax
;push num of args: 
mov rbx,2
push rbx
;generate proc:
;bound variable:
mov rbx, [rbp + WORD_SIZE * 2]
mov rbx, [rbx + WORD_SIZE * 0]
mov rax, [rbx + WORD_SIZE * 1]

;assuming we get correct input, no need to check type closure 
add rax, TYPE_SIZE 
mov rbx, [rax] ;rbx contains pointer to env
push rbx      ;push env pointer
add rax, WORD_SIZE 
mov rbx, [rax] ;rbx contains pointer to code ; (rbx contains pointer to code)
;------------------------changes in opt - do not use rbx ---------------------
push qword [rbp + WORD_SIZE ] ; push old ret addr
; lets get to rax the dst to copy
mov rax, [rbp + WORD_SIZE * 3]
mov r9, [rbp]
add rax, 3
shl rax, 3
add rax, rbp
; lets get to rdx the src to copy
mov rdx, [rsp + WORD_SIZE * 2]
mov r10, rdx
add rdx, 2
shl rdx, 3
add rdx, rsp
; lets get to rcx the number of iterations needed
lea rcx, [r10 + 3]
copy_stack370:

mov r11, [rdx]
mov [rax], r11
sub rax, 8
sub rdx, 8
loop copy_stack370
add rax, 8
mov rsp, rax
mov rbp, r9
jmp rbx
 Lexit368: 

leave
ret
Lcont363: 

leave
ret
Lcont357: 

;back to applic: applic351
;assuming we get correct input, no need to check type closure 
CLOSURE_ENV rbx, rax ;rbx contains pointer to env
push rbx      ;push env pointer
CLOSURE_CODE rbx, rax 
call rbx
;clean stack
add rsp, WORD_SIZE *1 ; pop env
pop rbx               ; pop arg count
shl rbx, 3            ; rbx = rbx * 8
add rbx, WORD_SIZE    ; clean magic
add rsp, rbx          ; pop args
mov [fvar_tbl + 19 * WORD_SIZE], rax 
 lea rax, [const_tbl+1] 

	call write_sob_if_not_void

some_compiled_section398:
;define:
;applic:applic375
;push magic:
mov rbx, 0
push rbx
;free variable:
mov rax, qword [fvar_tbl + 4 * WORD_SIZE]

push rax
;free variable:
mov rax, qword [fvar_tbl + 18 * WORD_SIZE]

push rax
;free variable:
mov rax, qword [fvar_tbl + 20 * WORD_SIZE]

push rax
;free variable:
mov rax, qword [fvar_tbl + 28 * WORD_SIZE]

push rax
;back to applic: applic375
;push num of args: 
mov rbx,4
push rbx
;generate proc:
;simple lambda:
mov rbx, 0
shl rbx, 3
MALLOC rax, rbx
push rax; pushing ext_env for later 
;copying pointers:
mov rcx, 0
cmp rcx, 1
jle end_pointers_copy378
copy_pointers376:
push rcx
neg rcx
add rcx, 0
mov rbx, [rbp + WORD_SIZE * 2] ; getting pointer to old env
mov rdx, [rbx + rcx * WORD_SIZE] ; getting to rdx old_env[i]
inc rcx
mov [rax + WORD_SIZE * rcx], rdx ; putting env[i] (stored in rdx) into ext_env[i + 1]
pop rcx ; restoring counter
loop copy_pointers376
end_pointers_copy378:
mov rcx, [rbp + 3 * WORD_SIZE] ; getting to rcx the number of the current parameters 
inc rcx
shl rcx, 3
MALLOC rbx, rcx
mov qword [rax], rbx ; getting the new allocated memory pointer to ext_env[0]
mov rax, rbx ; more convinient with pointer to extenv[0] in rax 

mov rbx, rcx ; rbx will be constant and hold the size of params
; copying parameters to new env 
cmp rbx, 0
je end_parameters_copy379
copy_parameters377: 
push rcx
neg rcx
add rcx, rbx ; rcx starts high and decreases with iterations
lea rdx, [rbp + WORD_SIZE * rcx]
add rdx, 4 * WORD_SIZE ; now rdx has the address of param_i 
mov rdx, [rdx] ; now rdx has the param_i 
mov [rax + WORD_SIZE * rcx], rdx 
pop rcx
loop copy_parameters377
end_parameters_copy379:
pop rbx
MAKE_CLOSURE(rax, rbx, Lcode380)
jmp Lcont381
Lcode380: 
push rbp
mov rbp, rsp
; , x
; lambda optional: 
mov rbx, 1
shl rbx, 3
MALLOC rax, rbx
push rax ; pushing ext_env for later 
;copying pointers:
mov rcx, 1
cmp rcx, 1
jle end_pointers_copy384
copy_pointers382:
push rcx
neg rcx
add rcx, 1
mov rbx, [rbp + WORD_SIZE * 2] ; getting pointer to old env
mov rdx, [rbx + rcx * WORD_SIZE] ; getting to rdx old_env[i]
inc rcx
mov [rax + WORD_SIZE * rcx], rdx ; putting env[i] (stored in rdx) into ext_env[i + 1]
pop rcx ; restoring counter
loop copy_pointers382
end_pointers_copy384:
mov rcx, [rbp + 3 * WORD_SIZE] ; getting to rcx the number of the current parameters 
inc rcx
shl rcx, 3
MALLOC rbx, rcx
mov qword [rax], rbx ; getting the new allocated memory pointer to ext_env[0]
mov rax, rbx ; more convinient with pointer to extenv[0] in rax 

mov rbx, rcx ; rbx will be constant and hold the size of params
; copying parameters to new env 
cmp rbx, 0
je end_parameters_copy385
copy_parameters383: 
push rcx
neg rcx
add rcx, rbx ; rcx starts high and decreases with iterations
lea rdx, [rbp + WORD_SIZE * rcx]
add rdx, 4 * WORD_SIZE ; now rdx has the address of param_i 
mov rdx, [rdx] ; now rdx has the param_i 
mov [rax + WORD_SIZE * rcx], rdx 
pop rcx
loop copy_parameters383
end_parameters_copy385:
pop rbx
MAKE_CLOSURE(rax, rbx, Lcode386)
jmp Lcont387
Lcode386: 
push rbp
mov rbp, rsp
mov rax, [rbp + WORD_SIZE * 3] ; rax <- n 
cmp rax, 1; n =? |must|
jne opt_list_creation389
lea rbx, [rbp + WORD_SIZE * (rax + 4)] ; magic <- Nil
mov qword [rbx], const_tbl
jmp actual_code388
opt_list_creation389:
mov rbx, const_tbl
dec rax ; rax <- n - 1
make_list_loop390: ; create list loop 
mov rcx, [rbp + WORD_SIZE * (4 + rax)] ; rcx <- params[i]
MAKE_PAIR(rdx, rcx, rbx)
mov rbx, rdx
dec rax
cmp rax, 1
jge make_list_loop390
mov rax, [rbp + WORD_SIZE * 3]
dec rax; rax <- n - 1
mov [rbp + WORD_SIZE * (4 + rax)], rbx; save optional list on the stack
sub rax, 1 ; constant rax <- n - 1 - |must| (offset to move)
jz actual_code388
lea rcx, [4 + 1] ; i <- must_length + 4 
stack_reduction391:

push rcx
dec rcx
mov rbx, [rbp + WORD_SIZE * rcx]
add rcx, rax
mov [rbp + WORD_SIZE * rcx], rbx
pop rcx
loop stack_reduction391
lea rsp, [rsp + WORD_SIZE * rax]
mov rbp, rsp
mov qword [rbp + WORD_SIZE * 3], 1
actual_code388:
;if:
;applic:applic397
;push magic:
mov rbx, 0
push rbx
;parameter variable:
mov rax, [rbp + WORD_SIZE * (4 + 1)]

push rax
;back to applic: applic397
;push num of args: 
mov rbx,1
push rbx
;generate proc:
;bound variable:
mov rbx, [rbp + WORD_SIZE * 2]
mov rbx, [rbx + WORD_SIZE * 0]
mov rax, [rbx + WORD_SIZE * 3]

;back to applic: applic397
;assuming we get correct input, no need to check type closure 
CLOSURE_ENV rbx, rax ;rbx contains pointer to env
push rbx      ;push env pointer
CLOSURE_CODE rbx, rax 
call rbx
;clean stack
add rsp, WORD_SIZE *1 ; pop env
pop rbx               ; pop arg count
shl rbx, 3            ; rbx = rbx * 8
add rbx, WORD_SIZE    ; clean magic
add rsp, rbx          ; pop args

 cmp rax, SOB_FALSE_ADDRESS 
 je Lelse393 
;applicTp:
;parameter variable:
mov rax, [rbp + WORD_SIZE * (4 + 0)]

push rax
;constant
lea rax, [const_tbl+ 32]

push rax
;push num of args: 
mov rbx,2
push rbx
;generate proc:
;bound variable:
mov rbx, [rbp + WORD_SIZE * 2]
mov rbx, [rbx + WORD_SIZE * 0]
mov rax, [rbx + WORD_SIZE * 1]

;assuming we get correct input, no need to check type closure 
add rax, TYPE_SIZE 
mov rbx, [rax] ;rbx contains pointer to env
push rbx      ;push env pointer
add rax, WORD_SIZE 
mov rbx, [rax] ;rbx contains pointer to code ; (rbx contains pointer to code)
;------------------------changes in opt - do not use rbx ---------------------
push qword [rbp + WORD_SIZE ] ; push old ret addr
; lets get to rax the dst to copy
mov rax, [rbp + WORD_SIZE * 3]
mov r9, [rbp]
add rax, 3
shl rax, 3
add rax, rbp
; lets get to rdx the src to copy
mov rdx, [rsp + WORD_SIZE * 2]
mov r10, rdx
add rdx, 2
shl rdx, 3
add rdx, rsp
; lets get to rcx the number of iterations needed
lea rcx, [r10 + 3]
copy_stack396:

mov r11, [rdx]
mov [rax], r11
sub rax, 8
sub rdx, 8
loop copy_stack396
add rax, 8
mov rsp, rax
mov rbp, r9
jmp rbx
 jmp Lexit392 
 Lelse393:
;applicTp:
;applic:applic395
;push magic:
mov rbx, 0
push rbx
;parameter variable:
mov rax, [rbp + WORD_SIZE * (4 + 1)]

push rax
;bound variable:
mov rbx, [rbp + WORD_SIZE * 2]
mov rbx, [rbx + WORD_SIZE * 0]
mov rax, [rbx + WORD_SIZE * 2]

push rax
;back to applic: applic395
;push num of args: 
mov rbx,2
push rbx
;generate proc:
;bound variable:
mov rbx, [rbp + WORD_SIZE * 2]
mov rbx, [rbx + WORD_SIZE * 0]
mov rax, [rbx + WORD_SIZE * 0]

;back to applic: applic395
;assuming we get correct input, no need to check type closure 
CLOSURE_ENV rbx, rax ;rbx contains pointer to env
push rbx      ;push env pointer
CLOSURE_CODE rbx, rax 
call rbx
;clean stack
add rsp, WORD_SIZE *1 ; pop env
pop rbx               ; pop arg count
shl rbx, 3            ; rbx = rbx * 8
add rbx, WORD_SIZE    ; clean magic
add rsp, rbx          ; pop args

push rax
;parameter variable:
mov rax, [rbp + WORD_SIZE * (4 + 0)]

push rax
;push num of args: 
mov rbx,2
push rbx
;generate proc:
;bound variable:
mov rbx, [rbp + WORD_SIZE * 2]
mov rbx, [rbx + WORD_SIZE * 0]
mov rax, [rbx + WORD_SIZE * 1]

;assuming we get correct input, no need to check type closure 
add rax, TYPE_SIZE 
mov rbx, [rax] ;rbx contains pointer to env
push rbx      ;push env pointer
add rax, WORD_SIZE 
mov rbx, [rax] ;rbx contains pointer to code ; (rbx contains pointer to code)
;------------------------changes in opt - do not use rbx ---------------------
push qword [rbp + WORD_SIZE ] ; push old ret addr
; lets get to rax the dst to copy
mov rax, [rbp + WORD_SIZE * 3]
mov r9, [rbp]
add rax, 3
shl rax, 3
add rax, rbp
; lets get to rdx the src to copy
mov rdx, [rsp + WORD_SIZE * 2]
mov r10, rdx
add rdx, 2
shl rdx, 3
add rdx, rsp
; lets get to rcx the number of iterations needed
lea rcx, [r10 + 3]
copy_stack394:

mov r11, [rdx]
mov [rax], r11
sub rax, 8
sub rdx, 8
loop copy_stack394
add rax, 8
mov rsp, rax
mov rbp, r9
jmp rbx
 Lexit392: 

leave
ret
Lcont387: 

leave
ret
Lcont381: 

;back to applic: applic375
;assuming we get correct input, no need to check type closure 
CLOSURE_ENV rbx, rax ;rbx contains pointer to env
push rbx      ;push env pointer
CLOSURE_CODE rbx, rax 
call rbx
;clean stack
add rsp, WORD_SIZE *1 ; pop env
pop rbx               ; pop arg count
shl rbx, 3            ; rbx = rbx * 8
add rbx, WORD_SIZE    ; clean magic
add rsp, rbx          ; pop args
mov [fvar_tbl + 20 * WORD_SIZE], rax 
 lea rax, [const_tbl+1] 

	call write_sob_if_not_void

some_compiled_section432:
;define:
;applic:applic399
;push magic:
mov rbx, 0
push rbx
;free variable:
mov rax, qword [fvar_tbl + 28 * WORD_SIZE]

push rax
;free variable:
mov rax, qword [fvar_tbl + 24 * WORD_SIZE]

push rax
;free variable:
mov rax, qword [fvar_tbl + 23 * WORD_SIZE]

push rax
;free variable:
mov rax, qword [fvar_tbl + 4 * WORD_SIZE]

push rax
;free variable:
mov rax, qword [fvar_tbl + 22 * WORD_SIZE]

push rax
;back to applic: applic399
;push num of args: 
mov rbx,5
push rbx
;generate proc:
;simple lambda:
mov rbx, 0
shl rbx, 3
MALLOC rax, rbx
push rax; pushing ext_env for later 
;copying pointers:
mov rcx, 0
cmp rcx, 1
jle end_pointers_copy402
copy_pointers400:
push rcx
neg rcx
add rcx, 0
mov rbx, [rbp + WORD_SIZE * 2] ; getting pointer to old env
mov rdx, [rbx + rcx * WORD_SIZE] ; getting to rdx old_env[i]
inc rcx
mov [rax + WORD_SIZE * rcx], rdx ; putting env[i] (stored in rdx) into ext_env[i + 1]
pop rcx ; restoring counter
loop copy_pointers400
end_pointers_copy402:
mov rcx, [rbp + 3 * WORD_SIZE] ; getting to rcx the number of the current parameters 
inc rcx
shl rcx, 3
MALLOC rbx, rcx
mov qword [rax], rbx ; getting the new allocated memory pointer to ext_env[0]
mov rax, rbx ; more convinient with pointer to extenv[0] in rax 

mov rbx, rcx ; rbx will be constant and hold the size of params
; copying parameters to new env 
cmp rbx, 0
je end_parameters_copy403
copy_parameters401: 
push rcx
neg rcx
add rcx, rbx ; rcx starts high and decreases with iterations
lea rdx, [rbp + WORD_SIZE * rcx]
add rdx, 4 * WORD_SIZE ; now rdx has the address of param_i 
mov rdx, [rdx] ; now rdx has the param_i 
mov [rax + WORD_SIZE * rcx], rdx 
pop rcx
loop copy_parameters401
end_parameters_copy403:
pop rbx
MAKE_CLOSURE(rax, rbx, Lcode404)
jmp Lcont405
Lcode404: 
push rbp
mov rbp, rsp
;applicTp:
;constant
lea rax, [const_tbl+ 23]

push rax
;push num of args: 
mov rbx,1
push rbx
;generate proc:
;simple lambda:
mov rbx, 1
shl rbx, 3
MALLOC rax, rbx
push rax; pushing ext_env for later 
;copying pointers:
mov rcx, 1
cmp rcx, 1
jle end_pointers_copy409
copy_pointers407:
push rcx
neg rcx
add rcx, 1
mov rbx, [rbp + WORD_SIZE * 2] ; getting pointer to old env
mov rdx, [rbx + rcx * WORD_SIZE] ; getting to rdx old_env[i]
inc rcx
mov [rax + WORD_SIZE * rcx], rdx ; putting env[i] (stored in rdx) into ext_env[i + 1]
pop rcx ; restoring counter
loop copy_pointers407
end_pointers_copy409:
mov rcx, [rbp + 3 * WORD_SIZE] ; getting to rcx the number of the current parameters 
inc rcx
shl rcx, 3
MALLOC rbx, rcx
mov qword [rax], rbx ; getting the new allocated memory pointer to ext_env[0]
mov rax, rbx ; more convinient with pointer to extenv[0] in rax 

mov rbx, rcx ; rbx will be constant and hold the size of params
; copying parameters to new env 
cmp rbx, 0
je end_parameters_copy410
copy_parameters408: 
push rcx
neg rcx
add rcx, rbx ; rcx starts high and decreases with iterations
lea rdx, [rbp + WORD_SIZE * rcx]
add rdx, 4 * WORD_SIZE ; now rdx has the address of param_i 
mov rdx, [rdx] ; now rdx has the param_i 
mov [rax + WORD_SIZE * rcx], rdx 
pop rcx
loop copy_parameters408
end_parameters_copy410:
pop rbx
MAKE_CLOSURE(rax, rbx, Lcode411)
jmp Lcont412
Lcode411: 
push rbp
mov rbp, rsp
;sequence:
;set:
; Box:
lea rcx, [4 + 0]
MALLOC rax, WORD_SIZE
mov rbx, [rbp + WORD_SIZE * rcx]
mov [rax], rbx

mov qword [rbp + WORD_SIZE * (4 + 0)], rax
mov rax, SOB_VOID_ADDRESS 

;sequence:
;box set:
; , x
; lambda optional: 
mov rbx, 2
shl rbx, 3
MALLOC rax, rbx
push rax ; pushing ext_env for later 
;copying pointers:
mov rcx, 2
cmp rcx, 1
jle end_pointers_copy415
copy_pointers413:
push rcx
neg rcx
add rcx, 2
mov rbx, [rbp + WORD_SIZE * 2] ; getting pointer to old env
mov rdx, [rbx + rcx * WORD_SIZE] ; getting to rdx old_env[i]
inc rcx
mov [rax + WORD_SIZE * rcx], rdx ; putting env[i] (stored in rdx) into ext_env[i + 1]
pop rcx ; restoring counter
loop copy_pointers413
end_pointers_copy415:
mov rcx, [rbp + 3 * WORD_SIZE] ; getting to rcx the number of the current parameters 
inc rcx
shl rcx, 3
MALLOC rbx, rcx
mov qword [rax], rbx ; getting the new allocated memory pointer to ext_env[0]
mov rax, rbx ; more convinient with pointer to extenv[0] in rax 

mov rbx, rcx ; rbx will be constant and hold the size of params
; copying parameters to new env 
cmp rbx, 0
je end_parameters_copy416
copy_parameters414: 
push rcx
neg rcx
add rcx, rbx ; rcx starts high and decreases with iterations
lea rdx, [rbp + WORD_SIZE * rcx]
add rdx, 4 * WORD_SIZE ; now rdx has the address of param_i 
mov rdx, [rdx] ; now rdx has the param_i 
mov [rax + WORD_SIZE * rcx], rdx 
pop rcx
loop copy_parameters414
end_parameters_copy416:
pop rbx
MAKE_CLOSURE(rax, rbx, Lcode417)
jmp Lcont418
Lcode417: 
push rbp
mov rbp, rsp
mov rax, [rbp + WORD_SIZE * 3] ; rax <- n 
cmp rax, 1; n =? |must|
jne opt_list_creation420
lea rbx, [rbp + WORD_SIZE * (rax + 4)] ; magic <- Nil
mov qword [rbx], const_tbl
jmp actual_code419
opt_list_creation420:
mov rbx, const_tbl
dec rax ; rax <- n - 1
make_list_loop421: ; create list loop 
mov rcx, [rbp + WORD_SIZE * (4 + rax)] ; rcx <- params[i]
MAKE_PAIR(rdx, rcx, rbx)
mov rbx, rdx
dec rax
cmp rax, 1
jge make_list_loop421
mov rax, [rbp + WORD_SIZE * 3]
dec rax; rax <- n - 1
mov [rbp + WORD_SIZE * (4 + rax)], rbx; save optional list on the stack
sub rax, 1 ; constant rax <- n - 1 - |must| (offset to move)
jz actual_code419
lea rcx, [4 + 1] ; i <- must_length + 4 
stack_reduction422:

push rcx
dec rcx
mov rbx, [rbp + WORD_SIZE * rcx]
add rcx, rax
mov [rbp + WORD_SIZE * rcx], rbx
pop rcx
loop stack_reduction422
lea rsp, [rsp + WORD_SIZE * rax]
mov rbp, rsp
mov qword [rbp + WORD_SIZE * 3], 1
actual_code419:
;if:
;applic:applic431
;push magic:
mov rbx, 0
push rbx
;parameter variable:
mov rax, [rbp + WORD_SIZE * (4 + 1)]

push rax
;back to applic: applic431
;push num of args: 
mov rbx,1
push rbx
;generate proc:
;bound variable:
mov rbx, [rbp + WORD_SIZE * 2]
mov rbx, [rbx + WORD_SIZE * 1]
mov rax, [rbx + WORD_SIZE * 1]

;back to applic: applic431
;assuming we get correct input, no need to check type closure 
CLOSURE_ENV rbx, rax ;rbx contains pointer to env
push rbx      ;push env pointer
CLOSURE_CODE rbx, rax 
call rbx
;clean stack
add rsp, WORD_SIZE *1 ; pop env
pop rbx               ; pop arg count
shl rbx, 3            ; rbx = rbx * 8
add rbx, WORD_SIZE    ; clean magic
add rsp, rbx          ; pop args

 cmp rax, SOB_FALSE_ADDRESS 
 je Lelse424 
;constant
lea rax, [const_tbl+ 2]

 jmp Lexit423 
 Lelse424:
;if:
;applic:applic429
;push magic:
mov rbx, 0
push rbx
;applic:applic430
;push magic:
mov rbx, 0
push rbx
;parameter variable:
mov rax, [rbp + WORD_SIZE * (4 + 1)]

push rax
;back to applic: applic430
;push num of args: 
mov rbx,1
push rbx
;generate proc:
;bound variable:
mov rbx, [rbp + WORD_SIZE * 2]
mov rbx, [rbx + WORD_SIZE * 1]
mov rax, [rbx + WORD_SIZE * 2]

;back to applic: applic430
;assuming we get correct input, no need to check type closure 
CLOSURE_ENV rbx, rax ;rbx contains pointer to env
push rbx      ;push env pointer
CLOSURE_CODE rbx, rax 
call rbx
;clean stack
add rsp, WORD_SIZE *1 ; pop env
pop rbx               ; pop arg count
shl rbx, 3            ; rbx = rbx * 8
add rbx, WORD_SIZE    ; clean magic
add rsp, rbx          ; pop args

push rax
;parameter variable:
mov rax, [rbp + WORD_SIZE * (4 + 0)]

push rax
;back to applic: applic429
;push num of args: 
mov rbx,2
push rbx
;generate proc:
;bound variable:
mov rbx, [rbp + WORD_SIZE * 2]
mov rbx, [rbx + WORD_SIZE * 1]
mov rax, [rbx + WORD_SIZE * 0]

;back to applic: applic429
;assuming we get correct input, no need to check type closure 
CLOSURE_ENV rbx, rax ;rbx contains pointer to env
push rbx      ;push env pointer
CLOSURE_CODE rbx, rax 
call rbx
;clean stack
add rsp, WORD_SIZE *1 ; pop env
pop rbx               ; pop arg count
shl rbx, 3            ; rbx = rbx * 8
add rbx, WORD_SIZE    ; clean magic
add rsp, rbx          ; pop args

 cmp rax, SOB_FALSE_ADDRESS 
 je Lelse426 
;applicTp:
;applic:applic428
;push magic:
mov rbx, 0
push rbx
;parameter variable:
mov rax, [rbp + WORD_SIZE * (4 + 1)]

push rax
;back to applic: applic428
;push num of args: 
mov rbx,1
push rbx
;generate proc:
;bound variable:
mov rbx, [rbp + WORD_SIZE * 2]
mov rbx, [rbx + WORD_SIZE * 1]
mov rax, [rbx + WORD_SIZE * 3]

;back to applic: applic428
;assuming we get correct input, no need to check type closure 
CLOSURE_ENV rbx, rax ;rbx contains pointer to env
push rbx      ;push env pointer
CLOSURE_CODE rbx, rax 
call rbx
;clean stack
add rsp, WORD_SIZE *1 ; pop env
pop rbx               ; pop arg count
shl rbx, 3            ; rbx = rbx * 8
add rbx, WORD_SIZE    ; clean magic
add rsp, rbx          ; pop args

push rax
;parameter variable:
mov rax, [rbp + WORD_SIZE * (4 + 0)]

push rax
;box get:
;bound variable:
mov rbx, [rbp + WORD_SIZE * 2]
mov rbx, [rbx + WORD_SIZE * 0]
mov rax, [rbx + WORD_SIZE * 0]

mov qword rax, [rax]

push rax
;push num of args: 
mov rbx,3
push rbx
;generate proc:
;bound variable:
mov rbx, [rbp + WORD_SIZE * 2]
mov rbx, [rbx + WORD_SIZE * 1]
mov rax, [rbx + WORD_SIZE * 4]

;assuming we get correct input, no need to check type closure 
add rax, TYPE_SIZE 
mov rbx, [rax] ;rbx contains pointer to env
push rbx      ;push env pointer
add rax, WORD_SIZE 
mov rbx, [rax] ;rbx contains pointer to code ; (rbx contains pointer to code)
;------------------------changes in opt - do not use rbx ---------------------
push qword [rbp + WORD_SIZE ] ; push old ret addr
; lets get to rax the dst to copy
mov rax, [rbp + WORD_SIZE * 3]
mov r9, [rbp]
add rax, 3
shl rax, 3
add rax, rbp
; lets get to rdx the src to copy
mov rdx, [rsp + WORD_SIZE * 2]
mov r10, rdx
add rdx, 2
shl rdx, 3
add rdx, rsp
; lets get to rcx the number of iterations needed
lea rcx, [r10 + 3]
copy_stack427:

mov r11, [rdx]
mov [rax], r11
sub rax, 8
sub rdx, 8
loop copy_stack427
add rax, 8
mov rsp, rax
mov rbp, r9
jmp rbx
 jmp Lexit425 
 Lelse426:
;constant
lea rax, [const_tbl+ 4]

 Lexit425: 

 Lexit423: 

leave
ret
Lcont418: 

push rax
;parameter variable:
mov rax, [rbp + WORD_SIZE * (4 + 0)]

pop rbx
mov qword [rax], rbx
;box get:
;parameter variable:
mov rax, [rbp + WORD_SIZE * (4 + 0)]

mov qword rax, [rax]



leave
ret
Lcont412: 

;assuming we get correct input, no need to check type closure 
add rax, TYPE_SIZE 
mov rbx, [rax] ;rbx contains pointer to env
push rbx      ;push env pointer
add rax, WORD_SIZE 
mov rbx, [rax] ;rbx contains pointer to code ; (rbx contains pointer to code)
;------------------------changes in opt - do not use rbx ---------------------
push qword [rbp + WORD_SIZE ] ; push old ret addr
; lets get to rax the dst to copy
mov rax, [rbp + WORD_SIZE * 3]
mov r9, [rbp]
add rax, 3
shl rax, 3
add rax, rbp
; lets get to rdx the src to copy
mov rdx, [rsp + WORD_SIZE * 2]
mov r10, rdx
add rdx, 2
shl rdx, 3
add rdx, rsp
; lets get to rcx the number of iterations needed
lea rcx, [r10 + 3]
copy_stack406:

mov r11, [rdx]
mov [rax], r11
sub rax, 8
sub rdx, 8
loop copy_stack406
add rax, 8
mov rsp, rax
mov rbp, r9
jmp rbx
leave
ret
Lcont405: 

;back to applic: applic399
;assuming we get correct input, no need to check type closure 
CLOSURE_ENV rbx, rax ;rbx contains pointer to env
push rbx      ;push env pointer
CLOSURE_CODE rbx, rax 
call rbx
;clean stack
add rsp, WORD_SIZE *1 ; pop env
pop rbx               ; pop arg count
shl rbx, 3            ; rbx = rbx * 8
add rbx, WORD_SIZE    ; clean magic
add rsp, rbx          ; pop args
mov [fvar_tbl + 22 * WORD_SIZE], rax 
 lea rax, [const_tbl+1] 

	call write_sob_if_not_void

some_compiled_section474:
;define:
;applic:applic433
;push magic:
mov rbx, 0
push rbx
;free variable:
mov rax, qword [fvar_tbl + 24 * WORD_SIZE]

push rax
;free variable:
mov rax, qword [fvar_tbl + 23 * WORD_SIZE]

push rax
;free variable:
mov rax, qword [fvar_tbl + 21 * WORD_SIZE]

push rax
;free variable:
mov rax, qword [fvar_tbl + 4 * WORD_SIZE]

push rax
;back to applic: applic433
;push num of args: 
mov rbx,4
push rbx
;generate proc:
;simple lambda:
mov rbx, 0
shl rbx, 3
MALLOC rax, rbx
push rax; pushing ext_env for later 
;copying pointers:
mov rcx, 0
cmp rcx, 1
jle end_pointers_copy436
copy_pointers434:
push rcx
neg rcx
add rcx, 0
mov rbx, [rbp + WORD_SIZE * 2] ; getting pointer to old env
mov rdx, [rbx + rcx * WORD_SIZE] ; getting to rdx old_env[i]
inc rcx
mov [rax + WORD_SIZE * rcx], rdx ; putting env[i] (stored in rdx) into ext_env[i + 1]
pop rcx ; restoring counter
loop copy_pointers434
end_pointers_copy436:
mov rcx, [rbp + 3 * WORD_SIZE] ; getting to rcx the number of the current parameters 
inc rcx
shl rcx, 3
MALLOC rbx, rcx
mov qword [rax], rbx ; getting the new allocated memory pointer to ext_env[0]
mov rax, rbx ; more convinient with pointer to extenv[0] in rax 

mov rbx, rcx ; rbx will be constant and hold the size of params
; copying parameters to new env 
cmp rbx, 0
je end_parameters_copy437
copy_parameters435: 
push rcx
neg rcx
add rcx, rbx ; rcx starts high and decreases with iterations
lea rdx, [rbp + WORD_SIZE * rcx]
add rdx, 4 * WORD_SIZE ; now rdx has the address of param_i 
mov rdx, [rdx] ; now rdx has the param_i 
mov [rax + WORD_SIZE * rcx], rdx 
pop rcx
loop copy_parameters435
end_parameters_copy437:
pop rbx
MAKE_CLOSURE(rax, rbx, Lcode438)
jmp Lcont439
Lcode438: 
push rbp
mov rbp, rsp
;applicTp:
;constant
lea rax, [const_tbl+ 23]

push rax
;push num of args: 
mov rbx,1
push rbx
;generate proc:
;simple lambda:
mov rbx, 1
shl rbx, 3
MALLOC rax, rbx
push rax; pushing ext_env for later 
;copying pointers:
mov rcx, 1
cmp rcx, 1
jle end_pointers_copy443
copy_pointers441:
push rcx
neg rcx
add rcx, 1
mov rbx, [rbp + WORD_SIZE * 2] ; getting pointer to old env
mov rdx, [rbx + rcx * WORD_SIZE] ; getting to rdx old_env[i]
inc rcx
mov [rax + WORD_SIZE * rcx], rdx ; putting env[i] (stored in rdx) into ext_env[i + 1]
pop rcx ; restoring counter
loop copy_pointers441
end_pointers_copy443:
mov rcx, [rbp + 3 * WORD_SIZE] ; getting to rcx the number of the current parameters 
inc rcx
shl rcx, 3
MALLOC rbx, rcx
mov qword [rax], rbx ; getting the new allocated memory pointer to ext_env[0]
mov rax, rbx ; more convinient with pointer to extenv[0] in rax 

mov rbx, rcx ; rbx will be constant and hold the size of params
; copying parameters to new env 
cmp rbx, 0
je end_parameters_copy444
copy_parameters442: 
push rcx
neg rcx
add rcx, rbx ; rcx starts high and decreases with iterations
lea rdx, [rbp + WORD_SIZE * rcx]
add rdx, 4 * WORD_SIZE ; now rdx has the address of param_i 
mov rdx, [rdx] ; now rdx has the param_i 
mov [rax + WORD_SIZE * rcx], rdx 
pop rcx
loop copy_parameters442
end_parameters_copy444:
pop rbx
MAKE_CLOSURE(rax, rbx, Lcode445)
jmp Lcont446
Lcode445: 
push rbp
mov rbp, rsp
;sequence:
;set:
; Box:
lea rcx, [4 + 0]
MALLOC rax, WORD_SIZE
mov rbx, [rbp + WORD_SIZE * rcx]
mov [rax], rbx

mov qword [rbp + WORD_SIZE * (4 + 0)], rax
mov rax, SOB_VOID_ADDRESS 

;sequence:
;box set:
;simple lambda:
mov rbx, 2
shl rbx, 3
MALLOC rax, rbx
push rax; pushing ext_env for later 
;copying pointers:
mov rcx, 2
cmp rcx, 1
jle end_pointers_copy449
copy_pointers447:
push rcx
neg rcx
add rcx, 2
mov rbx, [rbp + WORD_SIZE * 2] ; getting pointer to old env
mov rdx, [rbx + rcx * WORD_SIZE] ; getting to rdx old_env[i]
inc rcx
mov [rax + WORD_SIZE * rcx], rdx ; putting env[i] (stored in rdx) into ext_env[i + 1]
pop rcx ; restoring counter
loop copy_pointers447
end_pointers_copy449:
mov rcx, [rbp + 3 * WORD_SIZE] ; getting to rcx the number of the current parameters 
inc rcx
shl rcx, 3
MALLOC rbx, rcx
mov qword [rax], rbx ; getting the new allocated memory pointer to ext_env[0]
mov rax, rbx ; more convinient with pointer to extenv[0] in rax 

mov rbx, rcx ; rbx will be constant and hold the size of params
; copying parameters to new env 
cmp rbx, 0
je end_parameters_copy450
copy_parameters448: 
push rcx
neg rcx
add rcx, rbx ; rcx starts high and decreases with iterations
lea rdx, [rbp + WORD_SIZE * rcx]
add rdx, 4 * WORD_SIZE ; now rdx has the address of param_i 
mov rdx, [rdx] ; now rdx has the param_i 
mov [rax + WORD_SIZE * rcx], rdx 
pop rcx
loop copy_parameters448
end_parameters_copy450:
pop rbx
MAKE_CLOSURE(rax, rbx, Lcode451)
jmp Lcont452
Lcode451: 
push rbp
mov rbp, rsp
;if:
;applic:applic462
;push magic:
mov rbx, 0
push rbx
;parameter variable:
mov rax, [rbp + WORD_SIZE * (4 + 1)]

push rax
;back to applic: applic462
;push num of args: 
mov rbx,1
push rbx
;generate proc:
;bound variable:
mov rbx, [rbp + WORD_SIZE * 2]
mov rbx, [rbx + WORD_SIZE * 1]
mov rax, [rbx + WORD_SIZE * 0]

;back to applic: applic462
;assuming we get correct input, no need to check type closure 
CLOSURE_ENV rbx, rax ;rbx contains pointer to env
push rbx      ;push env pointer
CLOSURE_CODE rbx, rax 
call rbx
;clean stack
add rsp, WORD_SIZE *1 ; pop env
pop rbx               ; pop arg count
shl rbx, 3            ; rbx = rbx * 8
add rbx, WORD_SIZE    ; clean magic
add rsp, rbx          ; pop args

 cmp rax, SOB_FALSE_ADDRESS 
 je Lelse454 
;constant
lea rax, [const_tbl+ 2]

 jmp Lexit453 
 Lelse454:
;if:
;applic:applic460
;push magic:
mov rbx, 0
push rbx
;applic:applic461
;push magic:
mov rbx, 0
push rbx
;parameter variable:
mov rax, [rbp + WORD_SIZE * (4 + 1)]

push rax
;back to applic: applic461
;push num of args: 
mov rbx,1
push rbx
;generate proc:
;bound variable:
mov rbx, [rbp + WORD_SIZE * 2]
mov rbx, [rbx + WORD_SIZE * 1]
mov rax, [rbx + WORD_SIZE * 2]

;back to applic: applic461
;assuming we get correct input, no need to check type closure 
CLOSURE_ENV rbx, rax ;rbx contains pointer to env
push rbx      ;push env pointer
CLOSURE_CODE rbx, rax 
call rbx
;clean stack
add rsp, WORD_SIZE *1 ; pop env
pop rbx               ; pop arg count
shl rbx, 3            ; rbx = rbx * 8
add rbx, WORD_SIZE    ; clean magic
add rsp, rbx          ; pop args

push rax
;parameter variable:
mov rax, [rbp + WORD_SIZE * (4 + 0)]

push rax
;back to applic: applic460
;push num of args: 
mov rbx,2
push rbx
;generate proc:
;bound variable:
mov rbx, [rbp + WORD_SIZE * 2]
mov rbx, [rbx + WORD_SIZE * 1]
mov rax, [rbx + WORD_SIZE * 1]

;back to applic: applic460
;assuming we get correct input, no need to check type closure 
CLOSURE_ENV rbx, rax ;rbx contains pointer to env
push rbx      ;push env pointer
CLOSURE_CODE rbx, rax 
call rbx
;clean stack
add rsp, WORD_SIZE *1 ; pop env
pop rbx               ; pop arg count
shl rbx, 3            ; rbx = rbx * 8
add rbx, WORD_SIZE    ; clean magic
add rsp, rbx          ; pop args

 cmp rax, SOB_FALSE_ADDRESS 
 je Lelse456 
;applicTp:
;applic:applic458
;push magic:
mov rbx, 0
push rbx
;parameter variable:
mov rax, [rbp + WORD_SIZE * (4 + 1)]

push rax
;back to applic: applic458
;push num of args: 
mov rbx,1
push rbx
;generate proc:
;bound variable:
mov rbx, [rbp + WORD_SIZE * 2]
mov rbx, [rbx + WORD_SIZE * 1]
mov rax, [rbx + WORD_SIZE * 3]

;back to applic: applic458
;assuming we get correct input, no need to check type closure 
CLOSURE_ENV rbx, rax ;rbx contains pointer to env
push rbx      ;push env pointer
CLOSURE_CODE rbx, rax 
call rbx
;clean stack
add rsp, WORD_SIZE *1 ; pop env
pop rbx               ; pop arg count
shl rbx, 3            ; rbx = rbx * 8
add rbx, WORD_SIZE    ; clean magic
add rsp, rbx          ; pop args

push rax
;applic:applic459
;push magic:
mov rbx, 0
push rbx
;parameter variable:
mov rax, [rbp + WORD_SIZE * (4 + 1)]

push rax
;back to applic: applic459
;push num of args: 
mov rbx,1
push rbx
;generate proc:
;bound variable:
mov rbx, [rbp + WORD_SIZE * 2]
mov rbx, [rbx + WORD_SIZE * 1]
mov rax, [rbx + WORD_SIZE * 2]

;back to applic: applic459
;assuming we get correct input, no need to check type closure 
CLOSURE_ENV rbx, rax ;rbx contains pointer to env
push rbx      ;push env pointer
CLOSURE_CODE rbx, rax 
call rbx
;clean stack
add rsp, WORD_SIZE *1 ; pop env
pop rbx               ; pop arg count
shl rbx, 3            ; rbx = rbx * 8
add rbx, WORD_SIZE    ; clean magic
add rsp, rbx          ; pop args

push rax
;push num of args: 
mov rbx,2
push rbx
;generate proc:
;box get:
;bound variable:
mov rbx, [rbp + WORD_SIZE * 2]
mov rbx, [rbx + WORD_SIZE * 0]
mov rax, [rbx + WORD_SIZE * 0]

mov qword rax, [rax]

;assuming we get correct input, no need to check type closure 
add rax, TYPE_SIZE 
mov rbx, [rax] ;rbx contains pointer to env
push rbx      ;push env pointer
add rax, WORD_SIZE 
mov rbx, [rax] ;rbx contains pointer to code ; (rbx contains pointer to code)
;------------------------changes in opt - do not use rbx ---------------------
push qword [rbp + WORD_SIZE ] ; push old ret addr
; lets get to rax the dst to copy
mov rax, [rbp + WORD_SIZE * 3]
mov r9, [rbp]
add rax, 3
shl rax, 3
add rax, rbp
; lets get to rdx the src to copy
mov rdx, [rsp + WORD_SIZE * 2]
mov r10, rdx
add rdx, 2
shl rdx, 3
add rdx, rsp
; lets get to rcx the number of iterations needed
lea rcx, [r10 + 3]
copy_stack457:

mov r11, [rdx]
mov [rax], r11
sub rax, 8
sub rdx, 8
loop copy_stack457
add rax, 8
mov rsp, rax
mov rbp, r9
jmp rbx
 jmp Lexit455 
 Lelse456:
;constant
lea rax, [const_tbl+ 4]

 Lexit455: 

 Lexit453: 

leave
ret
Lcont452: 

push rax
;parameter variable:
mov rax, [rbp + WORD_SIZE * (4 + 0)]

pop rbx
mov qword [rax], rbx
; , x
; lambda optional: 
mov rbx, 2
shl rbx, 3
MALLOC rax, rbx
push rax ; pushing ext_env for later 
;copying pointers:
mov rcx, 2
cmp rcx, 1
jle end_pointers_copy465
copy_pointers463:
push rcx
neg rcx
add rcx, 2
mov rbx, [rbp + WORD_SIZE * 2] ; getting pointer to old env
mov rdx, [rbx + rcx * WORD_SIZE] ; getting to rdx old_env[i]
inc rcx
mov [rax + WORD_SIZE * rcx], rdx ; putting env[i] (stored in rdx) into ext_env[i + 1]
pop rcx ; restoring counter
loop copy_pointers463
end_pointers_copy465:
mov rcx, [rbp + 3 * WORD_SIZE] ; getting to rcx the number of the current parameters 
inc rcx
shl rcx, 3
MALLOC rbx, rcx
mov qword [rax], rbx ; getting the new allocated memory pointer to ext_env[0]
mov rax, rbx ; more convinient with pointer to extenv[0] in rax 

mov rbx, rcx ; rbx will be constant and hold the size of params
; copying parameters to new env 
cmp rbx, 0
je end_parameters_copy466
copy_parameters464: 
push rcx
neg rcx
add rcx, rbx ; rcx starts high and decreases with iterations
lea rdx, [rbp + WORD_SIZE * rcx]
add rdx, 4 * WORD_SIZE ; now rdx has the address of param_i 
mov rdx, [rdx] ; now rdx has the param_i 
mov [rax + WORD_SIZE * rcx], rdx 
pop rcx
loop copy_parameters464
end_parameters_copy466:
pop rbx
MAKE_CLOSURE(rax, rbx, Lcode467)
jmp Lcont468
Lcode467: 
push rbp
mov rbp, rsp
mov rax, [rbp + WORD_SIZE * 3] ; rax <- n 
cmp rax, 1; n =? |must|
jne opt_list_creation470
lea rbx, [rbp + WORD_SIZE * (rax + 4)] ; magic <- Nil
mov qword [rbx], const_tbl
jmp actual_code469
opt_list_creation470:
mov rbx, const_tbl
dec rax ; rax <- n - 1
make_list_loop471: ; create list loop 
mov rcx, [rbp + WORD_SIZE * (4 + rax)] ; rcx <- params[i]
MAKE_PAIR(rdx, rcx, rbx)
mov rbx, rdx
dec rax
cmp rax, 1
jge make_list_loop471
mov rax, [rbp + WORD_SIZE * 3]
dec rax; rax <- n - 1
mov [rbp + WORD_SIZE * (4 + rax)], rbx; save optional list on the stack
sub rax, 1 ; constant rax <- n - 1 - |must| (offset to move)
jz actual_code469
lea rcx, [4 + 1] ; i <- must_length + 4 
stack_reduction472:

push rcx
dec rcx
mov rbx, [rbp + WORD_SIZE * rcx]
add rcx, rax
mov [rbp + WORD_SIZE * rcx], rbx
pop rcx
loop stack_reduction472
lea rsp, [rsp + WORD_SIZE * rax]
mov rbp, rsp
mov qword [rbp + WORD_SIZE * 3], 1
actual_code469:
;applicTp:
;parameter variable:
mov rax, [rbp + WORD_SIZE * (4 + 1)]

push rax
;parameter variable:
mov rax, [rbp + WORD_SIZE * (4 + 0)]

push rax
;push num of args: 
mov rbx,2
push rbx
;generate proc:
;box get:
;bound variable:
mov rbx, [rbp + WORD_SIZE * 2]
mov rbx, [rbx + WORD_SIZE * 0]
mov rax, [rbx + WORD_SIZE * 0]

mov qword rax, [rax]

;assuming we get correct input, no need to check type closure 
add rax, TYPE_SIZE 
mov rbx, [rax] ;rbx contains pointer to env
push rbx      ;push env pointer
add rax, WORD_SIZE 
mov rbx, [rax] ;rbx contains pointer to code ; (rbx contains pointer to code)
;------------------------changes in opt - do not use rbx ---------------------
push qword [rbp + WORD_SIZE ] ; push old ret addr
; lets get to rax the dst to copy
mov rax, [rbp + WORD_SIZE * 3]
mov r9, [rbp]
add rax, 3
shl rax, 3
add rax, rbp
; lets get to rdx the src to copy
mov rdx, [rsp + WORD_SIZE * 2]
mov r10, rdx
add rdx, 2
shl rdx, 3
add rdx, rsp
; lets get to rcx the number of iterations needed
lea rcx, [r10 + 3]
copy_stack473:

mov r11, [rdx]
mov [rax], r11
sub rax, 8
sub rdx, 8
loop copy_stack473
add rax, 8
mov rsp, rax
mov rbp, r9
jmp rbx
leave
ret
Lcont468: 



leave
ret
Lcont446: 

;assuming we get correct input, no need to check type closure 
add rax, TYPE_SIZE 
mov rbx, [rax] ;rbx contains pointer to env
push rbx      ;push env pointer
add rax, WORD_SIZE 
mov rbx, [rax] ;rbx contains pointer to code ; (rbx contains pointer to code)
;------------------------changes in opt - do not use rbx ---------------------
push qword [rbp + WORD_SIZE ] ; push old ret addr
; lets get to rax the dst to copy
mov rax, [rbp + WORD_SIZE * 3]
mov r9, [rbp]
add rax, 3
shl rax, 3
add rax, rbp
; lets get to rdx the src to copy
mov rdx, [rsp + WORD_SIZE * 2]
mov r10, rdx
add rdx, 2
shl rdx, 3
add rdx, rsp
; lets get to rcx the number of iterations needed
lea rcx, [r10 + 3]
copy_stack440:

mov r11, [rdx]
mov [rax], r11
sub rax, 8
sub rdx, 8
loop copy_stack440
add rax, 8
mov rsp, rax
mov rbp, r9
jmp rbx
leave
ret
Lcont439: 

;back to applic: applic433
;assuming we get correct input, no need to check type closure 
CLOSURE_ENV rbx, rax ;rbx contains pointer to env
push rbx      ;push env pointer
CLOSURE_CODE rbx, rax 
call rbx
;clean stack
add rsp, WORD_SIZE *1 ; pop env
pop rbx               ; pop arg count
shl rbx, 3            ; rbx = rbx * 8
add rbx, WORD_SIZE    ; clean magic
add rsp, rbx          ; pop args
mov [fvar_tbl + 21 * WORD_SIZE], rax 
 lea rax, [const_tbl+1] 

	call write_sob_if_not_void

some_compiled_section520:
;define:
;applic:applic475
;push magic:
mov rbx, 0
push rbx
;free variable:
mov rax, qword [fvar_tbl + 24 * WORD_SIZE]

push rax
;free variable:
mov rax, qword [fvar_tbl + 23 * WORD_SIZE]

push rax
;free variable:
mov rax, qword [fvar_tbl + 56 * WORD_SIZE]

push rax
;free variable:
mov rax, qword [fvar_tbl + 22 * WORD_SIZE]

push rax
;free variable:
mov rax, qword [fvar_tbl + 21 * WORD_SIZE]

push rax
;free variable:
mov rax, qword [fvar_tbl + 4 * WORD_SIZE]

push rax
;back to applic: applic475
;push num of args: 
mov rbx,6
push rbx
;generate proc:
;simple lambda:
mov rbx, 0
shl rbx, 3
MALLOC rax, rbx
push rax; pushing ext_env for later 
;copying pointers:
mov rcx, 0
cmp rcx, 1
jle end_pointers_copy478
copy_pointers476:
push rcx
neg rcx
add rcx, 0
mov rbx, [rbp + WORD_SIZE * 2] ; getting pointer to old env
mov rdx, [rbx + rcx * WORD_SIZE] ; getting to rdx old_env[i]
inc rcx
mov [rax + WORD_SIZE * rcx], rdx ; putting env[i] (stored in rdx) into ext_env[i + 1]
pop rcx ; restoring counter
loop copy_pointers476
end_pointers_copy478:
mov rcx, [rbp + 3 * WORD_SIZE] ; getting to rcx the number of the current parameters 
inc rcx
shl rcx, 3
MALLOC rbx, rcx
mov qword [rax], rbx ; getting the new allocated memory pointer to ext_env[0]
mov rax, rbx ; more convinient with pointer to extenv[0] in rax 

mov rbx, rcx ; rbx will be constant and hold the size of params
; copying parameters to new env 
cmp rbx, 0
je end_parameters_copy479
copy_parameters477: 
push rcx
neg rcx
add rcx, rbx ; rcx starts high and decreases with iterations
lea rdx, [rbp + WORD_SIZE * rcx]
add rdx, 4 * WORD_SIZE ; now rdx has the address of param_i 
mov rdx, [rdx] ; now rdx has the param_i 
mov [rax + WORD_SIZE * rcx], rdx 
pop rcx
loop copy_parameters477
end_parameters_copy479:
pop rbx
MAKE_CLOSURE(rax, rbx, Lcode480)
jmp Lcont481
Lcode480: 
push rbp
mov rbp, rsp
;applicTp:
;constant
lea rax, [const_tbl+ 23]

push rax
;push num of args: 
mov rbx,1
push rbx
;generate proc:
;simple lambda:
mov rbx, 1
shl rbx, 3
MALLOC rax, rbx
push rax; pushing ext_env for later 
;copying pointers:
mov rcx, 1
cmp rcx, 1
jle end_pointers_copy485
copy_pointers483:
push rcx
neg rcx
add rcx, 1
mov rbx, [rbp + WORD_SIZE * 2] ; getting pointer to old env
mov rdx, [rbx + rcx * WORD_SIZE] ; getting to rdx old_env[i]
inc rcx
mov [rax + WORD_SIZE * rcx], rdx ; putting env[i] (stored in rdx) into ext_env[i + 1]
pop rcx ; restoring counter
loop copy_pointers483
end_pointers_copy485:
mov rcx, [rbp + 3 * WORD_SIZE] ; getting to rcx the number of the current parameters 
inc rcx
shl rcx, 3
MALLOC rbx, rcx
mov qword [rax], rbx ; getting the new allocated memory pointer to ext_env[0]
mov rax, rbx ; more convinient with pointer to extenv[0] in rax 

mov rbx, rcx ; rbx will be constant and hold the size of params
; copying parameters to new env 
cmp rbx, 0
je end_parameters_copy486
copy_parameters484: 
push rcx
neg rcx
add rcx, rbx ; rcx starts high and decreases with iterations
lea rdx, [rbp + WORD_SIZE * rcx]
add rdx, 4 * WORD_SIZE ; now rdx has the address of param_i 
mov rdx, [rdx] ; now rdx has the param_i 
mov [rax + WORD_SIZE * rcx], rdx 
pop rcx
loop copy_parameters484
end_parameters_copy486:
pop rbx
MAKE_CLOSURE(rax, rbx, Lcode487)
jmp Lcont488
Lcode487: 
push rbp
mov rbp, rsp
;sequence:
;set:
; Box:
lea rcx, [4 + 0]
MALLOC rax, WORD_SIZE
mov rbx, [rbp + WORD_SIZE * rcx]
mov [rax], rbx

mov qword [rbp + WORD_SIZE * (4 + 0)], rax
mov rax, SOB_VOID_ADDRESS 

;sequence:
;box set:
;simple lambda:
mov rbx, 2
shl rbx, 3
MALLOC rax, rbx
push rax; pushing ext_env for later 
;copying pointers:
mov rcx, 2
cmp rcx, 1
jle end_pointers_copy491
copy_pointers489:
push rcx
neg rcx
add rcx, 2
mov rbx, [rbp + WORD_SIZE * 2] ; getting pointer to old env
mov rdx, [rbx + rcx * WORD_SIZE] ; getting to rdx old_env[i]
inc rcx
mov [rax + WORD_SIZE * rcx], rdx ; putting env[i] (stored in rdx) into ext_env[i + 1]
pop rcx ; restoring counter
loop copy_pointers489
end_pointers_copy491:
mov rcx, [rbp + 3 * WORD_SIZE] ; getting to rcx the number of the current parameters 
inc rcx
shl rcx, 3
MALLOC rbx, rcx
mov qword [rax], rbx ; getting the new allocated memory pointer to ext_env[0]
mov rax, rbx ; more convinient with pointer to extenv[0] in rax 

mov rbx, rcx ; rbx will be constant and hold the size of params
; copying parameters to new env 
cmp rbx, 0
je end_parameters_copy492
copy_parameters490: 
push rcx
neg rcx
add rcx, rbx ; rcx starts high and decreases with iterations
lea rdx, [rbp + WORD_SIZE * rcx]
add rdx, 4 * WORD_SIZE ; now rdx has the address of param_i 
mov rdx, [rdx] ; now rdx has the param_i 
mov [rax + WORD_SIZE * rcx], rdx 
pop rcx
loop copy_parameters490
end_parameters_copy492:
pop rbx
MAKE_CLOSURE(rax, rbx, Lcode493)
jmp Lcont494
Lcode493: 
push rbp
mov rbp, rsp
;if:
;applic:applic508
;push magic:
mov rbx, 0
push rbx
;parameter variable:
mov rax, [rbp + WORD_SIZE * (4 + 1)]

push rax
;back to applic: applic508
;push num of args: 
mov rbx,1
push rbx
;generate proc:
;bound variable:
mov rbx, [rbp + WORD_SIZE * 2]
mov rbx, [rbx + WORD_SIZE * 1]
mov rax, [rbx + WORD_SIZE * 0]

;back to applic: applic508
;assuming we get correct input, no need to check type closure 
CLOSURE_ENV rbx, rax ;rbx contains pointer to env
push rbx      ;push env pointer
CLOSURE_CODE rbx, rax 
call rbx
;clean stack
add rsp, WORD_SIZE *1 ; pop env
pop rbx               ; pop arg count
shl rbx, 3            ; rbx = rbx * 8
add rbx, WORD_SIZE    ; clean magic
add rsp, rbx          ; pop args

 cmp rax, SOB_FALSE_ADDRESS 
 je Lelse496 
;constant
lea rax, [const_tbl+ 2]

 jmp Lexit495 
 Lelse496:
;if:
;applic:applic502
;push magic:
mov rbx, 0
push rbx
;or:
;applic:applic503
;push magic:
mov rbx, 0
push rbx
;applic:applic504
;push magic:
mov rbx, 0
push rbx
;parameter variable:
mov rax, [rbp + WORD_SIZE * (4 + 1)]

push rax
;back to applic: applic504
;push num of args: 
mov rbx,1
push rbx
;generate proc:
;bound variable:
mov rbx, [rbp + WORD_SIZE * 2]
mov rbx, [rbx + WORD_SIZE * 1]
mov rax, [rbx + WORD_SIZE * 4]

;back to applic: applic504
;assuming we get correct input, no need to check type closure 
CLOSURE_ENV rbx, rax ;rbx contains pointer to env
push rbx      ;push env pointer
CLOSURE_CODE rbx, rax 
call rbx
;clean stack
add rsp, WORD_SIZE *1 ; pop env
pop rbx               ; pop arg count
shl rbx, 3            ; rbx = rbx * 8
add rbx, WORD_SIZE    ; clean magic
add rsp, rbx          ; pop args

push rax
;parameter variable:
mov rax, [rbp + WORD_SIZE * (4 + 0)]

push rax
;back to applic: applic503
;push num of args: 
mov rbx,2
push rbx
;generate proc:
;bound variable:
mov rbx, [rbp + WORD_SIZE * 2]
mov rbx, [rbx + WORD_SIZE * 1]
mov rax, [rbx + WORD_SIZE * 1]

;back to applic: applic503
;assuming we get correct input, no need to check type closure 
CLOSURE_ENV rbx, rax ;rbx contains pointer to env
push rbx      ;push env pointer
CLOSURE_CODE rbx, rax 
call rbx
;clean stack
add rsp, WORD_SIZE *1 ; pop env
pop rbx               ; pop arg count
shl rbx, 3            ; rbx = rbx * 8
add rbx, WORD_SIZE    ; clean magic
add rsp, rbx          ; pop args

 cmp rax, SOB_FALSE_ADDRESS 
 jne Lexit507
;applic:applic505
;push magic:
mov rbx, 0
push rbx
;applic:applic506
;push magic:
mov rbx, 0
push rbx
;parameter variable:
mov rax, [rbp + WORD_SIZE * (4 + 1)]

push rax
;back to applic: applic506
;push num of args: 
mov rbx,1
push rbx
;generate proc:
;bound variable:
mov rbx, [rbp + WORD_SIZE * 2]
mov rbx, [rbx + WORD_SIZE * 1]
mov rax, [rbx + WORD_SIZE * 4]

;back to applic: applic506
;assuming we get correct input, no need to check type closure 
CLOSURE_ENV rbx, rax ;rbx contains pointer to env
push rbx      ;push env pointer
CLOSURE_CODE rbx, rax 
call rbx
;clean stack
add rsp, WORD_SIZE *1 ; pop env
pop rbx               ; pop arg count
shl rbx, 3            ; rbx = rbx * 8
add rbx, WORD_SIZE    ; clean magic
add rsp, rbx          ; pop args

push rax
;parameter variable:
mov rax, [rbp + WORD_SIZE * (4 + 0)]

push rax
;back to applic: applic505
;push num of args: 
mov rbx,2
push rbx
;generate proc:
;bound variable:
mov rbx, [rbp + WORD_SIZE * 2]
mov rbx, [rbx + WORD_SIZE * 1]
mov rax, [rbx + WORD_SIZE * 2]

;back to applic: applic505
;assuming we get correct input, no need to check type closure 
CLOSURE_ENV rbx, rax ;rbx contains pointer to env
push rbx      ;push env pointer
CLOSURE_CODE rbx, rax 
call rbx
;clean stack
add rsp, WORD_SIZE *1 ; pop env
pop rbx               ; pop arg count
shl rbx, 3            ; rbx = rbx * 8
add rbx, WORD_SIZE    ; clean magic
add rsp, rbx          ; pop args

 Lexit507: 
push rax
;back to applic: applic502
;push num of args: 
mov rbx,1
push rbx
;generate proc:
;bound variable:
mov rbx, [rbp + WORD_SIZE * 2]
mov rbx, [rbx + WORD_SIZE * 1]
mov rax, [rbx + WORD_SIZE * 3]

;back to applic: applic502
;assuming we get correct input, no need to check type closure 
CLOSURE_ENV rbx, rax ;rbx contains pointer to env
push rbx      ;push env pointer
CLOSURE_CODE rbx, rax 
call rbx
;clean stack
add rsp, WORD_SIZE *1 ; pop env
pop rbx               ; pop arg count
shl rbx, 3            ; rbx = rbx * 8
add rbx, WORD_SIZE    ; clean magic
add rsp, rbx          ; pop args

 cmp rax, SOB_FALSE_ADDRESS 
 je Lelse498 
;applicTp:
;applic:applic500
;push magic:
mov rbx, 0
push rbx
;parameter variable:
mov rax, [rbp + WORD_SIZE * (4 + 1)]

push rax
;back to applic: applic500
;push num of args: 
mov rbx,1
push rbx
;generate proc:
;bound variable:
mov rbx, [rbp + WORD_SIZE * 2]
mov rbx, [rbx + WORD_SIZE * 1]
mov rax, [rbx + WORD_SIZE * 5]

;back to applic: applic500
;assuming we get correct input, no need to check type closure 
CLOSURE_ENV rbx, rax ;rbx contains pointer to env
push rbx      ;push env pointer
CLOSURE_CODE rbx, rax 
call rbx
;clean stack
add rsp, WORD_SIZE *1 ; pop env
pop rbx               ; pop arg count
shl rbx, 3            ; rbx = rbx * 8
add rbx, WORD_SIZE    ; clean magic
add rsp, rbx          ; pop args

push rax
;applic:applic501
;push magic:
mov rbx, 0
push rbx
;parameter variable:
mov rax, [rbp + WORD_SIZE * (4 + 1)]

push rax
;back to applic: applic501
;push num of args: 
mov rbx,1
push rbx
;generate proc:
;bound variable:
mov rbx, [rbp + WORD_SIZE * 2]
mov rbx, [rbx + WORD_SIZE * 1]
mov rax, [rbx + WORD_SIZE * 4]

;back to applic: applic501
;assuming we get correct input, no need to check type closure 
CLOSURE_ENV rbx, rax ;rbx contains pointer to env
push rbx      ;push env pointer
CLOSURE_CODE rbx, rax 
call rbx
;clean stack
add rsp, WORD_SIZE *1 ; pop env
pop rbx               ; pop arg count
shl rbx, 3            ; rbx = rbx * 8
add rbx, WORD_SIZE    ; clean magic
add rsp, rbx          ; pop args

push rax
;push num of args: 
mov rbx,2
push rbx
;generate proc:
;box get:
;bound variable:
mov rbx, [rbp + WORD_SIZE * 2]
mov rbx, [rbx + WORD_SIZE * 0]
mov rax, [rbx + WORD_SIZE * 0]

mov qword rax, [rax]

;assuming we get correct input, no need to check type closure 
add rax, TYPE_SIZE 
mov rbx, [rax] ;rbx contains pointer to env
push rbx      ;push env pointer
add rax, WORD_SIZE 
mov rbx, [rax] ;rbx contains pointer to code ; (rbx contains pointer to code)
;------------------------changes in opt - do not use rbx ---------------------
push qword [rbp + WORD_SIZE ] ; push old ret addr
; lets get to rax the dst to copy
mov rax, [rbp + WORD_SIZE * 3]
mov r9, [rbp]
add rax, 3
shl rax, 3
add rax, rbp
; lets get to rdx the src to copy
mov rdx, [rsp + WORD_SIZE * 2]
mov r10, rdx
add rdx, 2
shl rdx, 3
add rdx, rsp
; lets get to rcx the number of iterations needed
lea rcx, [r10 + 3]
copy_stack499:

mov r11, [rdx]
mov [rax], r11
sub rax, 8
sub rdx, 8
loop copy_stack499
add rax, 8
mov rsp, rax
mov rbp, r9
jmp rbx
 jmp Lexit497 
 Lelse498:
;constant
lea rax, [const_tbl+ 4]

 Lexit497: 

 Lexit495: 

leave
ret
Lcont494: 

push rax
;parameter variable:
mov rax, [rbp + WORD_SIZE * (4 + 0)]

pop rbx
mov qword [rax], rbx
; , x
; lambda optional: 
mov rbx, 2
shl rbx, 3
MALLOC rax, rbx
push rax ; pushing ext_env for later 
;copying pointers:
mov rcx, 2
cmp rcx, 1
jle end_pointers_copy511
copy_pointers509:
push rcx
neg rcx
add rcx, 2
mov rbx, [rbp + WORD_SIZE * 2] ; getting pointer to old env
mov rdx, [rbx + rcx * WORD_SIZE] ; getting to rdx old_env[i]
inc rcx
mov [rax + WORD_SIZE * rcx], rdx ; putting env[i] (stored in rdx) into ext_env[i + 1]
pop rcx ; restoring counter
loop copy_pointers509
end_pointers_copy511:
mov rcx, [rbp + 3 * WORD_SIZE] ; getting to rcx the number of the current parameters 
inc rcx
shl rcx, 3
MALLOC rbx, rcx
mov qword [rax], rbx ; getting the new allocated memory pointer to ext_env[0]
mov rax, rbx ; more convinient with pointer to extenv[0] in rax 

mov rbx, rcx ; rbx will be constant and hold the size of params
; copying parameters to new env 
cmp rbx, 0
je end_parameters_copy512
copy_parameters510: 
push rcx
neg rcx
add rcx, rbx ; rcx starts high and decreases with iterations
lea rdx, [rbp + WORD_SIZE * rcx]
add rdx, 4 * WORD_SIZE ; now rdx has the address of param_i 
mov rdx, [rdx] ; now rdx has the param_i 
mov [rax + WORD_SIZE * rcx], rdx 
pop rcx
loop copy_parameters510
end_parameters_copy512:
pop rbx
MAKE_CLOSURE(rax, rbx, Lcode513)
jmp Lcont514
Lcode513: 
push rbp
mov rbp, rsp
mov rax, [rbp + WORD_SIZE * 3] ; rax <- n 
cmp rax, 1; n =? |must|
jne opt_list_creation516
lea rbx, [rbp + WORD_SIZE * (rax + 4)] ; magic <- Nil
mov qword [rbx], const_tbl
jmp actual_code515
opt_list_creation516:
mov rbx, const_tbl
dec rax ; rax <- n - 1
make_list_loop517: ; create list loop 
mov rcx, [rbp + WORD_SIZE * (4 + rax)] ; rcx <- params[i]
MAKE_PAIR(rdx, rcx, rbx)
mov rbx, rdx
dec rax
cmp rax, 1
jge make_list_loop517
mov rax, [rbp + WORD_SIZE * 3]
dec rax; rax <- n - 1
mov [rbp + WORD_SIZE * (4 + rax)], rbx; save optional list on the stack
sub rax, 1 ; constant rax <- n - 1 - |must| (offset to move)
jz actual_code515
lea rcx, [4 + 1] ; i <- must_length + 4 
stack_reduction518:

push rcx
dec rcx
mov rbx, [rbp + WORD_SIZE * rcx]
add rcx, rax
mov [rbp + WORD_SIZE * rcx], rbx
pop rcx
loop stack_reduction518
lea rsp, [rsp + WORD_SIZE * rax]
mov rbp, rsp
mov qword [rbp + WORD_SIZE * 3], 1
actual_code515:
;applicTp:
;parameter variable:
mov rax, [rbp + WORD_SIZE * (4 + 1)]

push rax
;parameter variable:
mov rax, [rbp + WORD_SIZE * (4 + 0)]

push rax
;push num of args: 
mov rbx,2
push rbx
;generate proc:
;box get:
;bound variable:
mov rbx, [rbp + WORD_SIZE * 2]
mov rbx, [rbx + WORD_SIZE * 0]
mov rax, [rbx + WORD_SIZE * 0]

mov qword rax, [rax]

;assuming we get correct input, no need to check type closure 
add rax, TYPE_SIZE 
mov rbx, [rax] ;rbx contains pointer to env
push rbx      ;push env pointer
add rax, WORD_SIZE 
mov rbx, [rax] ;rbx contains pointer to code ; (rbx contains pointer to code)
;------------------------changes in opt - do not use rbx ---------------------
push qword [rbp + WORD_SIZE ] ; push old ret addr
; lets get to rax the dst to copy
mov rax, [rbp + WORD_SIZE * 3]
mov r9, [rbp]
add rax, 3
shl rax, 3
add rax, rbp
; lets get to rdx the src to copy
mov rdx, [rsp + WORD_SIZE * 2]
mov r10, rdx
add rdx, 2
shl rdx, 3
add rdx, rsp
; lets get to rcx the number of iterations needed
lea rcx, [r10 + 3]
copy_stack519:

mov r11, [rdx]
mov [rax], r11
sub rax, 8
sub rdx, 8
loop copy_stack519
add rax, 8
mov rsp, rax
mov rbp, r9
jmp rbx
leave
ret
Lcont514: 



leave
ret
Lcont488: 

;assuming we get correct input, no need to check type closure 
add rax, TYPE_SIZE 
mov rbx, [rax] ;rbx contains pointer to env
push rbx      ;push env pointer
add rax, WORD_SIZE 
mov rbx, [rax] ;rbx contains pointer to code ; (rbx contains pointer to code)
;------------------------changes in opt - do not use rbx ---------------------
push qword [rbp + WORD_SIZE ] ; push old ret addr
; lets get to rax the dst to copy
mov rax, [rbp + WORD_SIZE * 3]
mov r9, [rbp]
add rax, 3
shl rax, 3
add rax, rbp
; lets get to rdx the src to copy
mov rdx, [rsp + WORD_SIZE * 2]
mov r10, rdx
add rdx, 2
shl rdx, 3
add rdx, rsp
; lets get to rcx the number of iterations needed
lea rcx, [r10 + 3]
copy_stack482:

mov r11, [rdx]
mov [rax], r11
sub rax, 8
sub rdx, 8
loop copy_stack482
add rax, 8
mov rsp, rax
mov rbp, r9
jmp rbx
leave
ret
Lcont481: 

;back to applic: applic475
;assuming we get correct input, no need to check type closure 
CLOSURE_ENV rbx, rax ;rbx contains pointer to env
push rbx      ;push env pointer
CLOSURE_CODE rbx, rax 
call rbx
;clean stack
add rsp, WORD_SIZE *1 ; pop env
pop rbx               ; pop arg count
shl rbx, 3            ; rbx = rbx * 8
add rbx, WORD_SIZE    ; clean magic
add rsp, rbx          ; pop args
mov [fvar_tbl + 35 * WORD_SIZE], rax 
 lea rax, [const_tbl+1] 

	call write_sob_if_not_void

some_compiled_section535:
;define:
;applic:applic521
;push magic:
mov rbx, 0
push rbx
;free variable:
mov rax, qword [fvar_tbl + 22 * WORD_SIZE]

push rax
;back to applic: applic521
;push num of args: 
mov rbx,1
push rbx
;generate proc:
;simple lambda:
mov rbx, 0
shl rbx, 3
MALLOC rax, rbx
push rax; pushing ext_env for later 
;copying pointers:
mov rcx, 0
cmp rcx, 1
jle end_pointers_copy524
copy_pointers522:
push rcx
neg rcx
add rcx, 0
mov rbx, [rbp + WORD_SIZE * 2] ; getting pointer to old env
mov rdx, [rbx + rcx * WORD_SIZE] ; getting to rdx old_env[i]
inc rcx
mov [rax + WORD_SIZE * rcx], rdx ; putting env[i] (stored in rdx) into ext_env[i + 1]
pop rcx ; restoring counter
loop copy_pointers522
end_pointers_copy524:
mov rcx, [rbp + 3 * WORD_SIZE] ; getting to rcx the number of the current parameters 
inc rcx
shl rcx, 3
MALLOC rbx, rcx
mov qword [rax], rbx ; getting the new allocated memory pointer to ext_env[0]
mov rax, rbx ; more convinient with pointer to extenv[0] in rax 

mov rbx, rcx ; rbx will be constant and hold the size of params
; copying parameters to new env 
cmp rbx, 0
je end_parameters_copy525
copy_parameters523: 
push rcx
neg rcx
add rcx, rbx ; rcx starts high and decreases with iterations
lea rdx, [rbp + WORD_SIZE * rcx]
add rdx, 4 * WORD_SIZE ; now rdx has the address of param_i 
mov rdx, [rdx] ; now rdx has the param_i 
mov [rax + WORD_SIZE * rcx], rdx 
pop rcx
loop copy_parameters523
end_parameters_copy525:
pop rbx
MAKE_CLOSURE(rax, rbx, Lcode526)
jmp Lcont527
Lcode526: 
push rbp
mov rbp, rsp
;simple lambda:
mov rbx, 1
shl rbx, 3
MALLOC rax, rbx
push rax; pushing ext_env for later 
;copying pointers:
mov rcx, 1
cmp rcx, 1
jle end_pointers_copy530
copy_pointers528:
push rcx
neg rcx
add rcx, 1
mov rbx, [rbp + WORD_SIZE * 2] ; getting pointer to old env
mov rdx, [rbx + rcx * WORD_SIZE] ; getting to rdx old_env[i]
inc rcx
mov [rax + WORD_SIZE * rcx], rdx ; putting env[i] (stored in rdx) into ext_env[i + 1]
pop rcx ; restoring counter
loop copy_pointers528
end_pointers_copy530:
mov rcx, [rbp + 3 * WORD_SIZE] ; getting to rcx the number of the current parameters 
inc rcx
shl rcx, 3
MALLOC rbx, rcx
mov qword [rax], rbx ; getting the new allocated memory pointer to ext_env[0]
mov rax, rbx ; more convinient with pointer to extenv[0] in rax 

mov rbx, rcx ; rbx will be constant and hold the size of params
; copying parameters to new env 
cmp rbx, 0
je end_parameters_copy531
copy_parameters529: 
push rcx
neg rcx
add rcx, rbx ; rcx starts high and decreases with iterations
lea rdx, [rbp + WORD_SIZE * rcx]
add rdx, 4 * WORD_SIZE ; now rdx has the address of param_i 
mov rdx, [rdx] ; now rdx has the param_i 
mov [rax + WORD_SIZE * rcx], rdx 
pop rcx
loop copy_parameters529
end_parameters_copy531:
pop rbx
MAKE_CLOSURE(rax, rbx, Lcode532)
jmp Lcont533
Lcode532: 
push rbp
mov rbp, rsp
;applicTp:
;constant
lea rax, [const_tbl+ 32]

push rax
;parameter variable:
mov rax, [rbp + WORD_SIZE * (4 + 0)]

push rax
;push num of args: 
mov rbx,2
push rbx
;generate proc:
;bound variable:
mov rbx, [rbp + WORD_SIZE * 2]
mov rbx, [rbx + WORD_SIZE * 0]
mov rax, [rbx + WORD_SIZE * 0]

;assuming we get correct input, no need to check type closure 
add rax, TYPE_SIZE 
mov rbx, [rax] ;rbx contains pointer to env
push rbx      ;push env pointer
add rax, WORD_SIZE 
mov rbx, [rax] ;rbx contains pointer to code ; (rbx contains pointer to code)
;------------------------changes in opt - do not use rbx ---------------------
push qword [rbp + WORD_SIZE ] ; push old ret addr
; lets get to rax the dst to copy
mov rax, [rbp + WORD_SIZE * 3]
mov r9, [rbp]
add rax, 3
shl rax, 3
add rax, rbp
; lets get to rdx the src to copy
mov rdx, [rsp + WORD_SIZE * 2]
mov r10, rdx
add rdx, 2
shl rdx, 3
add rdx, rsp
; lets get to rcx the number of iterations needed
lea rcx, [r10 + 3]
copy_stack534:

mov r11, [rdx]
mov [rax], r11
sub rax, 8
sub rdx, 8
loop copy_stack534
add rax, 8
mov rsp, rax
mov rbp, r9
jmp rbx
leave
ret
Lcont533: 

leave
ret
Lcont527: 

;back to applic: applic521
;assuming we get correct input, no need to check type closure 
CLOSURE_ENV rbx, rax ;rbx contains pointer to env
push rbx      ;push env pointer
CLOSURE_CODE rbx, rax 
call rbx
;clean stack
add rsp, WORD_SIZE *1 ; pop env
pop rbx               ; pop arg count
shl rbx, 3            ; rbx = rbx * 8
add rbx, WORD_SIZE    ; clean magic
add rsp, rbx          ; pop args
mov [fvar_tbl + 64 * WORD_SIZE], rax 
 lea rax, [const_tbl+1] 

	call write_sob_if_not_void

some_compiled_section572:
;define:
;applic:applic536
;push magic:
mov rbx, 0
push rbx
;free variable:
mov rax, qword [fvar_tbl + 19 * WORD_SIZE]

push rax
;free variable:
mov rax, qword [fvar_tbl + 21 * WORD_SIZE]

push rax
;free variable:
mov rax, qword [fvar_tbl + 9 * WORD_SIZE]

push rax
;free variable:
mov rax, qword [fvar_tbl + 10 * WORD_SIZE]

push rax
;back to applic: applic536
;push num of args: 
mov rbx,4
push rbx
;generate proc:
;simple lambda:
mov rbx, 0
shl rbx, 3
MALLOC rax, rbx
push rax; pushing ext_env for later 
;copying pointers:
mov rcx, 0
cmp rcx, 1
jle end_pointers_copy539
copy_pointers537:
push rcx
neg rcx
add rcx, 0
mov rbx, [rbp + WORD_SIZE * 2] ; getting pointer to old env
mov rdx, [rbx + rcx * WORD_SIZE] ; getting to rdx old_env[i]
inc rcx
mov [rax + WORD_SIZE * rcx], rdx ; putting env[i] (stored in rdx) into ext_env[i + 1]
pop rcx ; restoring counter
loop copy_pointers537
end_pointers_copy539:
mov rcx, [rbp + 3 * WORD_SIZE] ; getting to rcx the number of the current parameters 
inc rcx
shl rcx, 3
MALLOC rbx, rcx
mov qword [rax], rbx ; getting the new allocated memory pointer to ext_env[0]
mov rax, rbx ; more convinient with pointer to extenv[0] in rax 

mov rbx, rcx ; rbx will be constant and hold the size of params
; copying parameters to new env 
cmp rbx, 0
je end_parameters_copy540
copy_parameters538: 
push rcx
neg rcx
add rcx, rbx ; rcx starts high and decreases with iterations
lea rdx, [rbp + WORD_SIZE * rcx]
add rdx, 4 * WORD_SIZE ; now rdx has the address of param_i 
mov rdx, [rdx] ; now rdx has the param_i 
mov [rax + WORD_SIZE * rcx], rdx 
pop rcx
loop copy_parameters538
end_parameters_copy540:
pop rbx
MAKE_CLOSURE(rax, rbx, Lcode541)
jmp Lcont542
Lcode541: 
push rbp
mov rbp, rsp
;simple lambda:
mov rbx, 1
shl rbx, 3
MALLOC rax, rbx
push rax; pushing ext_env for later 
;copying pointers:
mov rcx, 1
cmp rcx, 1
jle end_pointers_copy545
copy_pointers543:
push rcx
neg rcx
add rcx, 1
mov rbx, [rbp + WORD_SIZE * 2] ; getting pointer to old env
mov rdx, [rbx + rcx * WORD_SIZE] ; getting to rdx old_env[i]
inc rcx
mov [rax + WORD_SIZE * rcx], rdx ; putting env[i] (stored in rdx) into ext_env[i + 1]
pop rcx ; restoring counter
loop copy_pointers543
end_pointers_copy545:
mov rcx, [rbp + 3 * WORD_SIZE] ; getting to rcx the number of the current parameters 
inc rcx
shl rcx, 3
MALLOC rbx, rcx
mov qword [rax], rbx ; getting the new allocated memory pointer to ext_env[0]
mov rax, rbx ; more convinient with pointer to extenv[0] in rax 

mov rbx, rcx ; rbx will be constant and hold the size of params
; copying parameters to new env 
cmp rbx, 0
je end_parameters_copy546
copy_parameters544: 
push rcx
neg rcx
add rcx, rbx ; rcx starts high and decreases with iterations
lea rdx, [rbp + WORD_SIZE * rcx]
add rdx, 4 * WORD_SIZE ; now rdx has the address of param_i 
mov rdx, [rdx] ; now rdx has the param_i 
mov [rax + WORD_SIZE * rcx], rdx 
pop rcx
loop copy_parameters544
end_parameters_copy546:
pop rbx
MAKE_CLOSURE(rax, rbx, Lcode547)
jmp Lcont548
Lcode547: 
push rbp
mov rbp, rsp
;applicTp:
;constant
lea rax, [const_tbl+ 23]

push rax
;push num of args: 
mov rbx,1
push rbx
;generate proc:
;simple lambda:
mov rbx, 2
shl rbx, 3
MALLOC rax, rbx
push rax; pushing ext_env for later 
;copying pointers:
mov rcx, 2
cmp rcx, 1
jle end_pointers_copy552
copy_pointers550:
push rcx
neg rcx
add rcx, 2
mov rbx, [rbp + WORD_SIZE * 2] ; getting pointer to old env
mov rdx, [rbx + rcx * WORD_SIZE] ; getting to rdx old_env[i]
inc rcx
mov [rax + WORD_SIZE * rcx], rdx ; putting env[i] (stored in rdx) into ext_env[i + 1]
pop rcx ; restoring counter
loop copy_pointers550
end_pointers_copy552:
mov rcx, [rbp + 3 * WORD_SIZE] ; getting to rcx the number of the current parameters 
inc rcx
shl rcx, 3
MALLOC rbx, rcx
mov qword [rax], rbx ; getting the new allocated memory pointer to ext_env[0]
mov rax, rbx ; more convinient with pointer to extenv[0] in rax 

mov rbx, rcx ; rbx will be constant and hold the size of params
; copying parameters to new env 
cmp rbx, 0
je end_parameters_copy553
copy_parameters551: 
push rcx
neg rcx
add rcx, rbx ; rcx starts high and decreases with iterations
lea rdx, [rbp + WORD_SIZE * rcx]
add rdx, 4 * WORD_SIZE ; now rdx has the address of param_i 
mov rdx, [rdx] ; now rdx has the param_i 
mov [rax + WORD_SIZE * rcx], rdx 
pop rcx
loop copy_parameters551
end_parameters_copy553:
pop rbx
MAKE_CLOSURE(rax, rbx, Lcode554)
jmp Lcont555
Lcode554: 
push rbp
mov rbp, rsp
;sequence:
;set:
; Box:
lea rcx, [4 + 0]
MALLOC rax, WORD_SIZE
mov rbx, [rbp + WORD_SIZE * rcx]
mov [rax], rbx

mov qword [rbp + WORD_SIZE * (4 + 0)], rax
mov rax, SOB_VOID_ADDRESS 

;sequence:
;box set:
;simple lambda:
mov rbx, 3
shl rbx, 3
MALLOC rax, rbx
push rax; pushing ext_env for later 
;copying pointers:
mov rcx, 3
cmp rcx, 1
jle end_pointers_copy558
copy_pointers556:
push rcx
neg rcx
add rcx, 3
mov rbx, [rbp + WORD_SIZE * 2] ; getting pointer to old env
mov rdx, [rbx + rcx * WORD_SIZE] ; getting to rdx old_env[i]
inc rcx
mov [rax + WORD_SIZE * rcx], rdx ; putting env[i] (stored in rdx) into ext_env[i + 1]
pop rcx ; restoring counter
loop copy_pointers556
end_pointers_copy558:
mov rcx, [rbp + 3 * WORD_SIZE] ; getting to rcx the number of the current parameters 
inc rcx
shl rcx, 3
MALLOC rbx, rcx
mov qword [rax], rbx ; getting the new allocated memory pointer to ext_env[0]
mov rax, rbx ; more convinient with pointer to extenv[0] in rax 

mov rbx, rcx ; rbx will be constant and hold the size of params
; copying parameters to new env 
cmp rbx, 0
je end_parameters_copy559
copy_parameters557: 
push rcx
neg rcx
add rcx, rbx ; rcx starts high and decreases with iterations
lea rdx, [rbp + WORD_SIZE * rcx]
add rdx, 4 * WORD_SIZE ; now rdx has the address of param_i 
mov rdx, [rdx] ; now rdx has the param_i 
mov [rax + WORD_SIZE * rcx], rdx 
pop rcx
loop copy_parameters557
end_parameters_copy559:
pop rbx
MAKE_CLOSURE(rax, rbx, Lcode560)
jmp Lcont561
Lcode560: 
push rbp
mov rbp, rsp
;if:
;applic:applic568
;push magic:
mov rbx, 0
push rbx
;constant
lea rax, [const_tbl+ 32]

push rax
;parameter variable:
mov rax, [rbp + WORD_SIZE * (4 + 0)]

push rax
;back to applic: applic568
;push num of args: 
mov rbx,2
push rbx
;generate proc:
;bound variable:
mov rbx, [rbp + WORD_SIZE * 2]
mov rbx, [rbx + WORD_SIZE * 2]
mov rax, [rbx + WORD_SIZE * 2]

;back to applic: applic568
;assuming we get correct input, no need to check type closure 
CLOSURE_ENV rbx, rax ;rbx contains pointer to env
push rbx      ;push env pointer
CLOSURE_CODE rbx, rax 
call rbx
;clean stack
add rsp, WORD_SIZE *1 ; pop env
pop rbx               ; pop arg count
shl rbx, 3            ; rbx = rbx * 8
add rbx, WORD_SIZE    ; clean magic
add rsp, rbx          ; pop args

 cmp rax, SOB_FALSE_ADDRESS 
 je Lelse563 
;parameter variable:
mov rax, [rbp + WORD_SIZE * (4 + 1)]

 jmp Lexit562 
 Lelse563:
;applicTp:
;applic:applic565
;push magic:
mov rbx, 0
push rbx
;parameter variable:
mov rax, [rbp + WORD_SIZE * (4 + 1)]

push rax
;applic:applic566
;push magic:
mov rbx, 0
push rbx
;parameter variable:
mov rax, [rbp + WORD_SIZE * (4 + 0)]

push rax
;bound variable:
mov rbx, [rbp + WORD_SIZE * 2]
mov rbx, [rbx + WORD_SIZE * 1]
mov rax, [rbx + WORD_SIZE * 0]

push rax
;back to applic: applic566
;push num of args: 
mov rbx,2
push rbx
;generate proc:
;bound variable:
mov rbx, [rbp + WORD_SIZE * 2]
mov rbx, [rbx + WORD_SIZE * 2]
mov rax, [rbx + WORD_SIZE * 0]

;back to applic: applic566
;assuming we get correct input, no need to check type closure 
CLOSURE_ENV rbx, rax ;rbx contains pointer to env
push rbx      ;push env pointer
CLOSURE_CODE rbx, rax 
call rbx
;clean stack
add rsp, WORD_SIZE *1 ; pop env
pop rbx               ; pop arg count
shl rbx, 3            ; rbx = rbx * 8
add rbx, WORD_SIZE    ; clean magic
add rsp, rbx          ; pop args

push rax
;back to applic: applic565
;push num of args: 
mov rbx,2
push rbx
;generate proc:
;free variable:
mov rax, qword [fvar_tbl + 25 * WORD_SIZE]

;back to applic: applic565
;assuming we get correct input, no need to check type closure 
CLOSURE_ENV rbx, rax ;rbx contains pointer to env
push rbx      ;push env pointer
CLOSURE_CODE rbx, rax 
call rbx
;clean stack
add rsp, WORD_SIZE *1 ; pop env
pop rbx               ; pop arg count
shl rbx, 3            ; rbx = rbx * 8
add rbx, WORD_SIZE    ; clean magic
add rsp, rbx          ; pop args

push rax
;applic:applic567
;push magic:
mov rbx, 0
push rbx
;constant
lea rax, [const_tbl+ 41]

push rax
;parameter variable:
mov rax, [rbp + WORD_SIZE * (4 + 0)]

push rax
;back to applic: applic567
;push num of args: 
mov rbx,2
push rbx
;generate proc:
;bound variable:
mov rbx, [rbp + WORD_SIZE * 2]
mov rbx, [rbx + WORD_SIZE * 2]
mov rax, [rbx + WORD_SIZE * 3]

;back to applic: applic567
;assuming we get correct input, no need to check type closure 
CLOSURE_ENV rbx, rax ;rbx contains pointer to env
push rbx      ;push env pointer
CLOSURE_CODE rbx, rax 
call rbx
;clean stack
add rsp, WORD_SIZE *1 ; pop env
pop rbx               ; pop arg count
shl rbx, 3            ; rbx = rbx * 8
add rbx, WORD_SIZE    ; clean magic
add rsp, rbx          ; pop args

push rax
;push num of args: 
mov rbx,2
push rbx
;generate proc:
;box get:
;bound variable:
mov rbx, [rbp + WORD_SIZE * 2]
mov rbx, [rbx + WORD_SIZE * 0]
mov rax, [rbx + WORD_SIZE * 0]

mov qword rax, [rax]

;assuming we get correct input, no need to check type closure 
add rax, TYPE_SIZE 
mov rbx, [rax] ;rbx contains pointer to env
push rbx      ;push env pointer
add rax, WORD_SIZE 
mov rbx, [rax] ;rbx contains pointer to code ; (rbx contains pointer to code)
;------------------------changes in opt - do not use rbx ---------------------
push qword [rbp + WORD_SIZE ] ; push old ret addr
; lets get to rax the dst to copy
mov rax, [rbp + WORD_SIZE * 3]
mov r9, [rbp]
add rax, 3
shl rax, 3
add rax, rbp
; lets get to rdx the src to copy
mov rdx, [rsp + WORD_SIZE * 2]
mov r10, rdx
add rdx, 2
shl rdx, 3
add rdx, rsp
; lets get to rcx the number of iterations needed
lea rcx, [r10 + 3]
copy_stack564:

mov r11, [rdx]
mov [rax], r11
sub rax, 8
sub rdx, 8
loop copy_stack564
add rax, 8
mov rsp, rax
mov rbp, r9
jmp rbx
 Lexit562: 

leave
ret
Lcont561: 

push rax
;parameter variable:
mov rax, [rbp + WORD_SIZE * (4 + 0)]

pop rbx
mov qword [rax], rbx
;applicTp:
;constant
lea rax, [const_tbl+ 0]

push rax
;applic:applic570
;push magic:
mov rbx, 0
push rbx
;constant
lea rax, [const_tbl+ 41]

push rax
;applic:applic571
;push magic:
mov rbx, 0
push rbx
;bound variable:
mov rbx, [rbp + WORD_SIZE * 2]
mov rbx, [rbx + WORD_SIZE * 0]
mov rax, [rbx + WORD_SIZE * 0]

push rax
;back to applic: applic571
;push num of args: 
mov rbx,1
push rbx
;generate proc:
;bound variable:
mov rbx, [rbp + WORD_SIZE * 2]
mov rbx, [rbx + WORD_SIZE * 1]
mov rax, [rbx + WORD_SIZE * 1]

;back to applic: applic571
;assuming we get correct input, no need to check type closure 
CLOSURE_ENV rbx, rax ;rbx contains pointer to env
push rbx      ;push env pointer
CLOSURE_CODE rbx, rax 
call rbx
;clean stack
add rsp, WORD_SIZE *1 ; pop env
pop rbx               ; pop arg count
shl rbx, 3            ; rbx = rbx * 8
add rbx, WORD_SIZE    ; clean magic
add rsp, rbx          ; pop args

push rax
;back to applic: applic570
;push num of args: 
mov rbx,2
push rbx
;generate proc:
;bound variable:
mov rbx, [rbp + WORD_SIZE * 2]
mov rbx, [rbx + WORD_SIZE * 1]
mov rax, [rbx + WORD_SIZE * 3]

;back to applic: applic570
;assuming we get correct input, no need to check type closure 
CLOSURE_ENV rbx, rax ;rbx contains pointer to env
push rbx      ;push env pointer
CLOSURE_CODE rbx, rax 
call rbx
;clean stack
add rsp, WORD_SIZE *1 ; pop env
pop rbx               ; pop arg count
shl rbx, 3            ; rbx = rbx * 8
add rbx, WORD_SIZE    ; clean magic
add rsp, rbx          ; pop args

push rax
;push num of args: 
mov rbx,2
push rbx
;generate proc:
;box get:
;parameter variable:
mov rax, [rbp + WORD_SIZE * (4 + 0)]

mov qword rax, [rax]

;assuming we get correct input, no need to check type closure 
add rax, TYPE_SIZE 
mov rbx, [rax] ;rbx contains pointer to env
push rbx      ;push env pointer
add rax, WORD_SIZE 
mov rbx, [rax] ;rbx contains pointer to code ; (rbx contains pointer to code)
;------------------------changes in opt - do not use rbx ---------------------
push qword [rbp + WORD_SIZE ] ; push old ret addr
; lets get to rax the dst to copy
mov rax, [rbp + WORD_SIZE * 3]
mov r9, [rbp]
add rax, 3
shl rax, 3
add rax, rbp
; lets get to rdx the src to copy
mov rdx, [rsp + WORD_SIZE * 2]
mov r10, rdx
add rdx, 2
shl rdx, 3
add rdx, rsp
; lets get to rcx the number of iterations needed
lea rcx, [r10 + 3]
copy_stack569:

mov r11, [rdx]
mov [rax], r11
sub rax, 8
sub rdx, 8
loop copy_stack569
add rax, 8
mov rsp, rax
mov rbp, r9
jmp rbx


leave
ret
Lcont555: 

;assuming we get correct input, no need to check type closure 
add rax, TYPE_SIZE 
mov rbx, [rax] ;rbx contains pointer to env
push rbx      ;push env pointer
add rax, WORD_SIZE 
mov rbx, [rax] ;rbx contains pointer to code ; (rbx contains pointer to code)
;------------------------changes in opt - do not use rbx ---------------------
push qword [rbp + WORD_SIZE ] ; push old ret addr
; lets get to rax the dst to copy
mov rax, [rbp + WORD_SIZE * 3]
mov r9, [rbp]
add rax, 3
shl rax, 3
add rax, rbp
; lets get to rdx the src to copy
mov rdx, [rsp + WORD_SIZE * 2]
mov r10, rdx
add rdx, 2
shl rdx, 3
add rdx, rsp
; lets get to rcx the number of iterations needed
lea rcx, [r10 + 3]
copy_stack549:

mov r11, [rdx]
mov [rax], r11
sub rax, 8
sub rdx, 8
loop copy_stack549
add rax, 8
mov rsp, rax
mov rbp, r9
jmp rbx
leave
ret
Lcont548: 

leave
ret
Lcont542: 

;back to applic: applic536
;assuming we get correct input, no need to check type closure 
CLOSURE_ENV rbx, rax ;rbx contains pointer to env
push rbx      ;push env pointer
CLOSURE_CODE rbx, rax 
call rbx
;clean stack
add rsp, WORD_SIZE *1 ; pop env
pop rbx               ; pop arg count
shl rbx, 3            ; rbx = rbx * 8
add rbx, WORD_SIZE    ; clean magic
add rsp, rbx          ; pop args
mov [fvar_tbl + 60 * WORD_SIZE], rax 
 lea rax, [const_tbl+1] 

	call write_sob_if_not_void

some_compiled_section641:
;define:
;applic:applic573
;push magic:
mov rbx, 0
push rbx
;free variable:
mov rax, qword [fvar_tbl + 14 * WORD_SIZE]

push rax
;free variable:
mov rax, qword [fvar_tbl + 24 * WORD_SIZE]

push rax
;free variable:
mov rax, qword [fvar_tbl + 23 * WORD_SIZE]

push rax
;free variable:
mov rax, qword [fvar_tbl + 16 * WORD_SIZE]

push rax
;free variable:
mov rax, qword [fvar_tbl + 6 * WORD_SIZE]

push rax
;free variable:
mov rax, qword [fvar_tbl + 5 * WORD_SIZE]

push rax
;free variable:
mov rax, qword [fvar_tbl + 3 * WORD_SIZE]

push rax
;free variable:
mov rax, qword [fvar_tbl + 1 * WORD_SIZE]

push rax
;free variable:
mov rax, qword [fvar_tbl + 2 * WORD_SIZE]

push rax
;free variable:
mov rax, qword [fvar_tbl + 60 * WORD_SIZE]

push rax
;free variable:
mov rax, qword [fvar_tbl + 22 * WORD_SIZE]

push rax
;back to applic: applic573
;push num of args: 
mov rbx,11
push rbx
;generate proc:
;simple lambda:
mov rbx, 0
shl rbx, 3
MALLOC rax, rbx
push rax; pushing ext_env for later 
;copying pointers:
mov rcx, 0
cmp rcx, 1
jle end_pointers_copy576
copy_pointers574:
push rcx
neg rcx
add rcx, 0
mov rbx, [rbp + WORD_SIZE * 2] ; getting pointer to old env
mov rdx, [rbx + rcx * WORD_SIZE] ; getting to rdx old_env[i]
inc rcx
mov [rax + WORD_SIZE * rcx], rdx ; putting env[i] (stored in rdx) into ext_env[i + 1]
pop rcx ; restoring counter
loop copy_pointers574
end_pointers_copy576:
mov rcx, [rbp + 3 * WORD_SIZE] ; getting to rcx the number of the current parameters 
inc rcx
shl rcx, 3
MALLOC rbx, rcx
mov qword [rax], rbx ; getting the new allocated memory pointer to ext_env[0]
mov rax, rbx ; more convinient with pointer to extenv[0] in rax 

mov rbx, rcx ; rbx will be constant and hold the size of params
; copying parameters to new env 
cmp rbx, 0
je end_parameters_copy577
copy_parameters575: 
push rcx
neg rcx
add rcx, rbx ; rcx starts high and decreases with iterations
lea rdx, [rbp + WORD_SIZE * rcx]
add rdx, 4 * WORD_SIZE ; now rdx has the address of param_i 
mov rdx, [rdx] ; now rdx has the param_i 
mov [rax + WORD_SIZE * rcx], rdx 
pop rcx
loop copy_parameters575
end_parameters_copy577:
pop rbx
MAKE_CLOSURE(rax, rbx, Lcode578)
jmp Lcont579
Lcode578: 
push rbp
mov rbp, rsp
;applicTp:
;constant
lea rax, [const_tbl+ 23]

push rax
;push num of args: 
mov rbx,1
push rbx
;generate proc:
;simple lambda:
mov rbx, 1
shl rbx, 3
MALLOC rax, rbx
push rax; pushing ext_env for later 
;copying pointers:
mov rcx, 1
cmp rcx, 1
jle end_pointers_copy583
copy_pointers581:
push rcx
neg rcx
add rcx, 1
mov rbx, [rbp + WORD_SIZE * 2] ; getting pointer to old env
mov rdx, [rbx + rcx * WORD_SIZE] ; getting to rdx old_env[i]
inc rcx
mov [rax + WORD_SIZE * rcx], rdx ; putting env[i] (stored in rdx) into ext_env[i + 1]
pop rcx ; restoring counter
loop copy_pointers581
end_pointers_copy583:
mov rcx, [rbp + 3 * WORD_SIZE] ; getting to rcx the number of the current parameters 
inc rcx
shl rcx, 3
MALLOC rbx, rcx
mov qword [rax], rbx ; getting the new allocated memory pointer to ext_env[0]
mov rax, rbx ; more convinient with pointer to extenv[0] in rax 

mov rbx, rcx ; rbx will be constant and hold the size of params
; copying parameters to new env 
cmp rbx, 0
je end_parameters_copy584
copy_parameters582: 
push rcx
neg rcx
add rcx, rbx ; rcx starts high and decreases with iterations
lea rdx, [rbp + WORD_SIZE * rcx]
add rdx, 4 * WORD_SIZE ; now rdx has the address of param_i 
mov rdx, [rdx] ; now rdx has the param_i 
mov [rax + WORD_SIZE * rcx], rdx 
pop rcx
loop copy_parameters582
end_parameters_copy584:
pop rbx
MAKE_CLOSURE(rax, rbx, Lcode585)
jmp Lcont586
Lcode585: 
push rbp
mov rbp, rsp
;sequence:
;set:
; Box:
lea rcx, [4 + 0]
MALLOC rax, WORD_SIZE
mov rbx, [rbp + WORD_SIZE * rcx]
mov [rax], rbx

mov qword [rbp + WORD_SIZE * (4 + 0)], rax
mov rax, SOB_VOID_ADDRESS 

;sequence:
;box set:
;simple lambda:
mov rbx, 2
shl rbx, 3
MALLOC rax, rbx
push rax; pushing ext_env for later 
;copying pointers:
mov rcx, 2
cmp rcx, 1
jle end_pointers_copy589
copy_pointers587:
push rcx
neg rcx
add rcx, 2
mov rbx, [rbp + WORD_SIZE * 2] ; getting pointer to old env
mov rdx, [rbx + rcx * WORD_SIZE] ; getting to rdx old_env[i]
inc rcx
mov [rax + WORD_SIZE * rcx], rdx ; putting env[i] (stored in rdx) into ext_env[i + 1]
pop rcx ; restoring counter
loop copy_pointers587
end_pointers_copy589:
mov rcx, [rbp + 3 * WORD_SIZE] ; getting to rcx the number of the current parameters 
inc rcx
shl rcx, 3
MALLOC rbx, rcx
mov qword [rax], rbx ; getting the new allocated memory pointer to ext_env[0]
mov rax, rbx ; more convinient with pointer to extenv[0] in rax 

mov rbx, rcx ; rbx will be constant and hold the size of params
; copying parameters to new env 
cmp rbx, 0
je end_parameters_copy590
copy_parameters588: 
push rcx
neg rcx
add rcx, rbx ; rcx starts high and decreases with iterations
lea rdx, [rbp + WORD_SIZE * rcx]
add rdx, 4 * WORD_SIZE ; now rdx has the address of param_i 
mov rdx, [rdx] ; now rdx has the param_i 
mov [rax + WORD_SIZE * rcx], rdx 
pop rcx
loop copy_parameters588
end_parameters_copy590:
pop rbx
MAKE_CLOSURE(rax, rbx, Lcode591)
jmp Lcont592
Lcode591: 
push rbp
mov rbp, rsp
;or:
;if:
;applic:applic599
;push magic:
mov rbx, 0
push rbx
;parameter variable:
mov rax, [rbp + WORD_SIZE * (4 + 0)]

push rax
;back to applic: applic599
;push num of args: 
mov rbx,1
push rbx
;generate proc:
;bound variable:
mov rbx, [rbp + WORD_SIZE * 2]
mov rbx, [rbx + WORD_SIZE * 1]
mov rax, [rbx + WORD_SIZE * 2]

;back to applic: applic599
;assuming we get correct input, no need to check type closure 
CLOSURE_ENV rbx, rax ;rbx contains pointer to env
push rbx      ;push env pointer
CLOSURE_CODE rbx, rax 
call rbx
;clean stack
add rsp, WORD_SIZE *1 ; pop env
pop rbx               ; pop arg count
shl rbx, 3            ; rbx = rbx * 8
add rbx, WORD_SIZE    ; clean magic
add rsp, rbx          ; pop args

 cmp rax, SOB_FALSE_ADDRESS 
 je Lelse594 
;if:
;applic:applic598
;push magic:
mov rbx, 0
push rbx
;parameter variable:
mov rax, [rbp + WORD_SIZE * (4 + 1)]

push rax
;back to applic: applic598
;push num of args: 
mov rbx,1
push rbx
;generate proc:
;bound variable:
mov rbx, [rbp + WORD_SIZE * 2]
mov rbx, [rbx + WORD_SIZE * 1]
mov rax, [rbx + WORD_SIZE * 2]

;back to applic: applic598
;assuming we get correct input, no need to check type closure 
CLOSURE_ENV rbx, rax ;rbx contains pointer to env
push rbx      ;push env pointer
CLOSURE_CODE rbx, rax 
call rbx
;clean stack
add rsp, WORD_SIZE *1 ; pop env
pop rbx               ; pop arg count
shl rbx, 3            ; rbx = rbx * 8
add rbx, WORD_SIZE    ; clean magic
add rsp, rbx          ; pop args

 cmp rax, SOB_FALSE_ADDRESS 
 je Lelse596 
;applic:applic597
;push magic:
mov rbx, 0
push rbx
;parameter variable:
mov rax, [rbp + WORD_SIZE * (4 + 1)]

push rax
;parameter variable:
mov rax, [rbp + WORD_SIZE * (4 + 0)]

push rax
;back to applic: applic597
;push num of args: 
mov rbx,2
push rbx
;generate proc:
;bound variable:
mov rbx, [rbp + WORD_SIZE * 2]
mov rbx, [rbx + WORD_SIZE * 1]
mov rax, [rbx + WORD_SIZE * 0]

;back to applic: applic597
;assuming we get correct input, no need to check type closure 
CLOSURE_ENV rbx, rax ;rbx contains pointer to env
push rbx      ;push env pointer
CLOSURE_CODE rbx, rax 
call rbx
;clean stack
add rsp, WORD_SIZE *1 ; pop env
pop rbx               ; pop arg count
shl rbx, 3            ; rbx = rbx * 8
add rbx, WORD_SIZE    ; clean magic
add rsp, rbx          ; pop args

 jmp Lexit595 
 Lelse596:
;constant
lea rax, [const_tbl+ 4]

 Lexit595: 

 jmp Lexit593 
 Lelse594:
;constant
lea rax, [const_tbl+ 4]

 Lexit593: 

 cmp rax, SOB_FALSE_ADDRESS 
 jne Lexit640
;if:
;applic:applic606
;push magic:
mov rbx, 0
push rbx
;parameter variable:
mov rax, [rbp + WORD_SIZE * (4 + 0)]

push rax
;back to applic: applic606
;push num of args: 
mov rbx,1
push rbx
;generate proc:
;bound variable:
mov rbx, [rbp + WORD_SIZE * 2]
mov rbx, [rbx + WORD_SIZE * 1]
mov rax, [rbx + WORD_SIZE * 3]

;back to applic: applic606
;assuming we get correct input, no need to check type closure 
CLOSURE_ENV rbx, rax ;rbx contains pointer to env
push rbx      ;push env pointer
CLOSURE_CODE rbx, rax 
call rbx
;clean stack
add rsp, WORD_SIZE *1 ; pop env
pop rbx               ; pop arg count
shl rbx, 3            ; rbx = rbx * 8
add rbx, WORD_SIZE    ; clean magic
add rsp, rbx          ; pop args

 cmp rax, SOB_FALSE_ADDRESS 
 je Lelse601 
;if:
;applic:applic605
;push magic:
mov rbx, 0
push rbx
;parameter variable:
mov rax, [rbp + WORD_SIZE * (4 + 1)]

push rax
;back to applic: applic605
;push num of args: 
mov rbx,1
push rbx
;generate proc:
;bound variable:
mov rbx, [rbp + WORD_SIZE * 2]
mov rbx, [rbx + WORD_SIZE * 1]
mov rax, [rbx + WORD_SIZE * 3]

;back to applic: applic605
;assuming we get correct input, no need to check type closure 
CLOSURE_ENV rbx, rax ;rbx contains pointer to env
push rbx      ;push env pointer
CLOSURE_CODE rbx, rax 
call rbx
;clean stack
add rsp, WORD_SIZE *1 ; pop env
pop rbx               ; pop arg count
shl rbx, 3            ; rbx = rbx * 8
add rbx, WORD_SIZE    ; clean magic
add rsp, rbx          ; pop args

 cmp rax, SOB_FALSE_ADDRESS 
 je Lelse603 
;applic:applic604
;push magic:
mov rbx, 0
push rbx
;parameter variable:
mov rax, [rbp + WORD_SIZE * (4 + 1)]

push rax
;parameter variable:
mov rax, [rbp + WORD_SIZE * (4 + 0)]

push rax
;back to applic: applic604
;push num of args: 
mov rbx,2
push rbx
;generate proc:
;bound variable:
mov rbx, [rbp + WORD_SIZE * 2]
mov rbx, [rbx + WORD_SIZE * 1]
mov rax, [rbx + WORD_SIZE * 0]

;back to applic: applic604
;assuming we get correct input, no need to check type closure 
CLOSURE_ENV rbx, rax ;rbx contains pointer to env
push rbx      ;push env pointer
CLOSURE_CODE rbx, rax 
call rbx
;clean stack
add rsp, WORD_SIZE *1 ; pop env
pop rbx               ; pop arg count
shl rbx, 3            ; rbx = rbx * 8
add rbx, WORD_SIZE    ; clean magic
add rsp, rbx          ; pop args

 jmp Lexit602 
 Lelse603:
;constant
lea rax, [const_tbl+ 4]

 Lexit602: 

 jmp Lexit600 
 Lelse601:
;constant
lea rax, [const_tbl+ 4]

 Lexit600: 

 cmp rax, SOB_FALSE_ADDRESS 
 jne Lexit640
;if:
;applic:applic620
;push magic:
mov rbx, 0
push rbx
;parameter variable:
mov rax, [rbp + WORD_SIZE * (4 + 0)]

push rax
;back to applic: applic620
;push num of args: 
mov rbx,1
push rbx
;generate proc:
;bound variable:
mov rbx, [rbp + WORD_SIZE * 2]
mov rbx, [rbx + WORD_SIZE * 1]
mov rax, [rbx + WORD_SIZE * 4]

;back to applic: applic620
;assuming we get correct input, no need to check type closure 
CLOSURE_ENV rbx, rax ;rbx contains pointer to env
push rbx      ;push env pointer
CLOSURE_CODE rbx, rax 
call rbx
;clean stack
add rsp, WORD_SIZE *1 ; pop env
pop rbx               ; pop arg count
shl rbx, 3            ; rbx = rbx * 8
add rbx, WORD_SIZE    ; clean magic
add rsp, rbx          ; pop args

 cmp rax, SOB_FALSE_ADDRESS 
 je Lelse608 
;if:
;applic:applic619
;push magic:
mov rbx, 0
push rbx
;parameter variable:
mov rax, [rbp + WORD_SIZE * (4 + 1)]

push rax
;back to applic: applic619
;push num of args: 
mov rbx,1
push rbx
;generate proc:
;bound variable:
mov rbx, [rbp + WORD_SIZE * 2]
mov rbx, [rbx + WORD_SIZE * 1]
mov rax, [rbx + WORD_SIZE * 4]

;back to applic: applic619
;assuming we get correct input, no need to check type closure 
CLOSURE_ENV rbx, rax ;rbx contains pointer to env
push rbx      ;push env pointer
CLOSURE_CODE rbx, rax 
call rbx
;clean stack
add rsp, WORD_SIZE *1 ; pop env
pop rbx               ; pop arg count
shl rbx, 3            ; rbx = rbx * 8
add rbx, WORD_SIZE    ; clean magic
add rsp, rbx          ; pop args

 cmp rax, SOB_FALSE_ADDRESS 
 je Lelse610 
;if:
;applic:applic616
;push magic:
mov rbx, 0
push rbx
;applic:applic617
;push magic:
mov rbx, 0
push rbx
;parameter variable:
mov rax, [rbp + WORD_SIZE * (4 + 1)]

push rax
;back to applic: applic617
;push num of args: 
mov rbx,1
push rbx
;generate proc:
;bound variable:
mov rbx, [rbp + WORD_SIZE * 2]
mov rbx, [rbx + WORD_SIZE * 1]
mov rax, [rbx + WORD_SIZE * 8]

;back to applic: applic617
;assuming we get correct input, no need to check type closure 
CLOSURE_ENV rbx, rax ;rbx contains pointer to env
push rbx      ;push env pointer
CLOSURE_CODE rbx, rax 
call rbx
;clean stack
add rsp, WORD_SIZE *1 ; pop env
pop rbx               ; pop arg count
shl rbx, 3            ; rbx = rbx * 8
add rbx, WORD_SIZE    ; clean magic
add rsp, rbx          ; pop args

push rax
;applic:applic618
;push magic:
mov rbx, 0
push rbx
;parameter variable:
mov rax, [rbp + WORD_SIZE * (4 + 0)]

push rax
;back to applic: applic618
;push num of args: 
mov rbx,1
push rbx
;generate proc:
;bound variable:
mov rbx, [rbp + WORD_SIZE * 2]
mov rbx, [rbx + WORD_SIZE * 1]
mov rax, [rbx + WORD_SIZE * 8]

;back to applic: applic618
;assuming we get correct input, no need to check type closure 
CLOSURE_ENV rbx, rax ;rbx contains pointer to env
push rbx      ;push env pointer
CLOSURE_CODE rbx, rax 
call rbx
;clean stack
add rsp, WORD_SIZE *1 ; pop env
pop rbx               ; pop arg count
shl rbx, 3            ; rbx = rbx * 8
add rbx, WORD_SIZE    ; clean magic
add rsp, rbx          ; pop args

push rax
;back to applic: applic616
;push num of args: 
mov rbx,2
push rbx
;generate proc:
;box get:
;bound variable:
mov rbx, [rbp + WORD_SIZE * 2]
mov rbx, [rbx + WORD_SIZE * 0]
mov rax, [rbx + WORD_SIZE * 0]

mov qword rax, [rax]

;back to applic: applic616
;assuming we get correct input, no need to check type closure 
CLOSURE_ENV rbx, rax ;rbx contains pointer to env
push rbx      ;push env pointer
CLOSURE_CODE rbx, rax 
call rbx
;clean stack
add rsp, WORD_SIZE *1 ; pop env
pop rbx               ; pop arg count
shl rbx, 3            ; rbx = rbx * 8
add rbx, WORD_SIZE    ; clean magic
add rsp, rbx          ; pop args

 cmp rax, SOB_FALSE_ADDRESS 
 je Lelse612 
;applic:applic613
;push magic:
mov rbx, 0
push rbx
;applic:applic614
;push magic:
mov rbx, 0
push rbx
;parameter variable:
mov rax, [rbp + WORD_SIZE * (4 + 1)]

push rax
;back to applic: applic614
;push num of args: 
mov rbx,1
push rbx
;generate proc:
;bound variable:
mov rbx, [rbp + WORD_SIZE * 2]
mov rbx, [rbx + WORD_SIZE * 1]
mov rax, [rbx + WORD_SIZE * 9]

;back to applic: applic614
;assuming we get correct input, no need to check type closure 
CLOSURE_ENV rbx, rax ;rbx contains pointer to env
push rbx      ;push env pointer
CLOSURE_CODE rbx, rax 
call rbx
;clean stack
add rsp, WORD_SIZE *1 ; pop env
pop rbx               ; pop arg count
shl rbx, 3            ; rbx = rbx * 8
add rbx, WORD_SIZE    ; clean magic
add rsp, rbx          ; pop args

push rax
;applic:applic615
;push magic:
mov rbx, 0
push rbx
;parameter variable:
mov rax, [rbp + WORD_SIZE * (4 + 0)]

push rax
;back to applic: applic615
;push num of args: 
mov rbx,1
push rbx
;generate proc:
;bound variable:
mov rbx, [rbp + WORD_SIZE * 2]
mov rbx, [rbx + WORD_SIZE * 1]
mov rax, [rbx + WORD_SIZE * 9]

;back to applic: applic615
;assuming we get correct input, no need to check type closure 
CLOSURE_ENV rbx, rax ;rbx contains pointer to env
push rbx      ;push env pointer
CLOSURE_CODE rbx, rax 
call rbx
;clean stack
add rsp, WORD_SIZE *1 ; pop env
pop rbx               ; pop arg count
shl rbx, 3            ; rbx = rbx * 8
add rbx, WORD_SIZE    ; clean magic
add rsp, rbx          ; pop args

push rax
;back to applic: applic613
;push num of args: 
mov rbx,2
push rbx
;generate proc:
;box get:
;bound variable:
mov rbx, [rbp + WORD_SIZE * 2]
mov rbx, [rbx + WORD_SIZE * 0]
mov rax, [rbx + WORD_SIZE * 0]

mov qword rax, [rax]

;back to applic: applic613
;assuming we get correct input, no need to check type closure 
CLOSURE_ENV rbx, rax ;rbx contains pointer to env
push rbx      ;push env pointer
CLOSURE_CODE rbx, rax 
call rbx
;clean stack
add rsp, WORD_SIZE *1 ; pop env
pop rbx               ; pop arg count
shl rbx, 3            ; rbx = rbx * 8
add rbx, WORD_SIZE    ; clean magic
add rsp, rbx          ; pop args

 jmp Lexit611 
 Lelse612:
;constant
lea rax, [const_tbl+ 4]

 Lexit611: 

 jmp Lexit609 
 Lelse610:
;constant
lea rax, [const_tbl+ 4]

 Lexit609: 

 jmp Lexit607 
 Lelse608:
;constant
lea rax, [const_tbl+ 4]

 Lexit607: 

 cmp rax, SOB_FALSE_ADDRESS 
 jne Lexit640
;if:
;applic:applic629
;push magic:
mov rbx, 0
push rbx
;parameter variable:
mov rax, [rbp + WORD_SIZE * (4 + 0)]

push rax
;back to applic: applic629
;push num of args: 
mov rbx,1
push rbx
;generate proc:
;bound variable:
mov rbx, [rbp + WORD_SIZE * 2]
mov rbx, [rbx + WORD_SIZE * 1]
mov rax, [rbx + WORD_SIZE * 5]

;back to applic: applic629
;assuming we get correct input, no need to check type closure 
CLOSURE_ENV rbx, rax ;rbx contains pointer to env
push rbx      ;push env pointer
CLOSURE_CODE rbx, rax 
call rbx
;clean stack
add rsp, WORD_SIZE *1 ; pop env
pop rbx               ; pop arg count
shl rbx, 3            ; rbx = rbx * 8
add rbx, WORD_SIZE    ; clean magic
add rsp, rbx          ; pop args

 cmp rax, SOB_FALSE_ADDRESS 
 je Lelse622 
;if:
;applic:applic628
;push magic:
mov rbx, 0
push rbx
;parameter variable:
mov rax, [rbp + WORD_SIZE * (4 + 1)]

push rax
;back to applic: applic628
;push num of args: 
mov rbx,1
push rbx
;generate proc:
;bound variable:
mov rbx, [rbp + WORD_SIZE * 2]
mov rbx, [rbx + WORD_SIZE * 1]
mov rax, [rbx + WORD_SIZE * 5]

;back to applic: applic628
;assuming we get correct input, no need to check type closure 
CLOSURE_ENV rbx, rax ;rbx contains pointer to env
push rbx      ;push env pointer
CLOSURE_CODE rbx, rax 
call rbx
;clean stack
add rsp, WORD_SIZE *1 ; pop env
pop rbx               ; pop arg count
shl rbx, 3            ; rbx = rbx * 8
add rbx, WORD_SIZE    ; clean magic
add rsp, rbx          ; pop args

 cmp rax, SOB_FALSE_ADDRESS 
 je Lelse624 
;applic:applic625
;push magic:
mov rbx, 0
push rbx
;applic:applic626
;push magic:
mov rbx, 0
push rbx
;parameter variable:
mov rax, [rbp + WORD_SIZE * (4 + 1)]

push rax
;back to applic: applic626
;push num of args: 
mov rbx,1
push rbx
;generate proc:
;bound variable:
mov rbx, [rbp + WORD_SIZE * 2]
mov rbx, [rbx + WORD_SIZE * 1]
mov rax, [rbx + WORD_SIZE * 10]

;back to applic: applic626
;assuming we get correct input, no need to check type closure 
CLOSURE_ENV rbx, rax ;rbx contains pointer to env
push rbx      ;push env pointer
CLOSURE_CODE rbx, rax 
call rbx
;clean stack
add rsp, WORD_SIZE *1 ; pop env
pop rbx               ; pop arg count
shl rbx, 3            ; rbx = rbx * 8
add rbx, WORD_SIZE    ; clean magic
add rsp, rbx          ; pop args

push rax
;applic:applic627
;push magic:
mov rbx, 0
push rbx
;parameter variable:
mov rax, [rbp + WORD_SIZE * (4 + 0)]

push rax
;back to applic: applic627
;push num of args: 
mov rbx,1
push rbx
;generate proc:
;bound variable:
mov rbx, [rbp + WORD_SIZE * 2]
mov rbx, [rbx + WORD_SIZE * 1]
mov rax, [rbx + WORD_SIZE * 10]

;back to applic: applic627
;assuming we get correct input, no need to check type closure 
CLOSURE_ENV rbx, rax ;rbx contains pointer to env
push rbx      ;push env pointer
CLOSURE_CODE rbx, rax 
call rbx
;clean stack
add rsp, WORD_SIZE *1 ; pop env
pop rbx               ; pop arg count
shl rbx, 3            ; rbx = rbx * 8
add rbx, WORD_SIZE    ; clean magic
add rsp, rbx          ; pop args

push rax
;back to applic: applic625
;push num of args: 
mov rbx,2
push rbx
;generate proc:
;bound variable:
mov rbx, [rbp + WORD_SIZE * 2]
mov rbx, [rbx + WORD_SIZE * 1]
mov rax, [rbx + WORD_SIZE * 0]

;back to applic: applic625
;assuming we get correct input, no need to check type closure 
CLOSURE_ENV rbx, rax ;rbx contains pointer to env
push rbx      ;push env pointer
CLOSURE_CODE rbx, rax 
call rbx
;clean stack
add rsp, WORD_SIZE *1 ; pop env
pop rbx               ; pop arg count
shl rbx, 3            ; rbx = rbx * 8
add rbx, WORD_SIZE    ; clean magic
add rsp, rbx          ; pop args

 jmp Lexit623 
 Lelse624:
;constant
lea rax, [const_tbl+ 4]

 Lexit623: 

 jmp Lexit621 
 Lelse622:
;constant
lea rax, [const_tbl+ 4]

 Lexit621: 

 cmp rax, SOB_FALSE_ADDRESS 
 jne Lexit640
;if:
;applic:applic638
;push magic:
mov rbx, 0
push rbx
;parameter variable:
mov rax, [rbp + WORD_SIZE * (4 + 0)]

push rax
;back to applic: applic638
;push num of args: 
mov rbx,1
push rbx
;generate proc:
;bound variable:
mov rbx, [rbp + WORD_SIZE * 2]
mov rbx, [rbx + WORD_SIZE * 1]
mov rax, [rbx + WORD_SIZE * 6]

;back to applic: applic638
;assuming we get correct input, no need to check type closure 
CLOSURE_ENV rbx, rax ;rbx contains pointer to env
push rbx      ;push env pointer
CLOSURE_CODE rbx, rax 
call rbx
;clean stack
add rsp, WORD_SIZE *1 ; pop env
pop rbx               ; pop arg count
shl rbx, 3            ; rbx = rbx * 8
add rbx, WORD_SIZE    ; clean magic
add rsp, rbx          ; pop args

 cmp rax, SOB_FALSE_ADDRESS 
 je Lelse631 
;if:
;applic:applic637
;push magic:
mov rbx, 0
push rbx
;parameter variable:
mov rax, [rbp + WORD_SIZE * (4 + 1)]

push rax
;back to applic: applic637
;push num of args: 
mov rbx,1
push rbx
;generate proc:
;bound variable:
mov rbx, [rbp + WORD_SIZE * 2]
mov rbx, [rbx + WORD_SIZE * 1]
mov rax, [rbx + WORD_SIZE * 6]

;back to applic: applic637
;assuming we get correct input, no need to check type closure 
CLOSURE_ENV rbx, rax ;rbx contains pointer to env
push rbx      ;push env pointer
CLOSURE_CODE rbx, rax 
call rbx
;clean stack
add rsp, WORD_SIZE *1 ; pop env
pop rbx               ; pop arg count
shl rbx, 3            ; rbx = rbx * 8
add rbx, WORD_SIZE    ; clean magic
add rsp, rbx          ; pop args

 cmp rax, SOB_FALSE_ADDRESS 
 je Lelse633 
;applic:applic634
;push magic:
mov rbx, 0
push rbx
;applic:applic635
;push magic:
mov rbx, 0
push rbx
;parameter variable:
mov rax, [rbp + WORD_SIZE * (4 + 1)]

push rax
;back to applic: applic635
;push num of args: 
mov rbx,1
push rbx
;generate proc:
;bound variable:
mov rbx, [rbp + WORD_SIZE * 2]
mov rbx, [rbx + WORD_SIZE * 1]
mov rax, [rbx + WORD_SIZE * 1]

;back to applic: applic635
;assuming we get correct input, no need to check type closure 
CLOSURE_ENV rbx, rax ;rbx contains pointer to env
push rbx      ;push env pointer
CLOSURE_CODE rbx, rax 
call rbx
;clean stack
add rsp, WORD_SIZE *1 ; pop env
pop rbx               ; pop arg count
shl rbx, 3            ; rbx = rbx * 8
add rbx, WORD_SIZE    ; clean magic
add rsp, rbx          ; pop args

push rax
;applic:applic636
;push magic:
mov rbx, 0
push rbx
;parameter variable:
mov rax, [rbp + WORD_SIZE * (4 + 0)]

push rax
;back to applic: applic636
;push num of args: 
mov rbx,1
push rbx
;generate proc:
;bound variable:
mov rbx, [rbp + WORD_SIZE * 2]
mov rbx, [rbx + WORD_SIZE * 1]
mov rax, [rbx + WORD_SIZE * 1]

;back to applic: applic636
;assuming we get correct input, no need to check type closure 
CLOSURE_ENV rbx, rax ;rbx contains pointer to env
push rbx      ;push env pointer
CLOSURE_CODE rbx, rax 
call rbx
;clean stack
add rsp, WORD_SIZE *1 ; pop env
pop rbx               ; pop arg count
shl rbx, 3            ; rbx = rbx * 8
add rbx, WORD_SIZE    ; clean magic
add rsp, rbx          ; pop args

push rax
;back to applic: applic634
;push num of args: 
mov rbx,2
push rbx
;generate proc:
;box get:
;bound variable:
mov rbx, [rbp + WORD_SIZE * 2]
mov rbx, [rbx + WORD_SIZE * 0]
mov rax, [rbx + WORD_SIZE * 0]

mov qword rax, [rax]

;back to applic: applic634
;assuming we get correct input, no need to check type closure 
CLOSURE_ENV rbx, rax ;rbx contains pointer to env
push rbx      ;push env pointer
CLOSURE_CODE rbx, rax 
call rbx
;clean stack
add rsp, WORD_SIZE *1 ; pop env
pop rbx               ; pop arg count
shl rbx, 3            ; rbx = rbx * 8
add rbx, WORD_SIZE    ; clean magic
add rsp, rbx          ; pop args

 jmp Lexit632 
 Lelse633:
;constant
lea rax, [const_tbl+ 4]

 Lexit632: 

 jmp Lexit630 
 Lelse631:
;constant
lea rax, [const_tbl+ 4]

 Lexit630: 

 cmp rax, SOB_FALSE_ADDRESS 
 jne Lexit640
;applicTp:
;parameter variable:
mov rax, [rbp + WORD_SIZE * (4 + 1)]

push rax
;parameter variable:
mov rax, [rbp + WORD_SIZE * (4 + 0)]

push rax
;push num of args: 
mov rbx,2
push rbx
;generate proc:
;bound variable:
mov rbx, [rbp + WORD_SIZE * 2]
mov rbx, [rbx + WORD_SIZE * 1]
mov rax, [rbx + WORD_SIZE * 7]

;assuming we get correct input, no need to check type closure 
add rax, TYPE_SIZE 
mov rbx, [rax] ;rbx contains pointer to env
push rbx      ;push env pointer
add rax, WORD_SIZE 
mov rbx, [rax] ;rbx contains pointer to code ; (rbx contains pointer to code)
;------------------------changes in opt - do not use rbx ---------------------
push qword [rbp + WORD_SIZE ] ; push old ret addr
; lets get to rax the dst to copy
mov rax, [rbp + WORD_SIZE * 3]
mov r9, [rbp]
add rax, 3
shl rax, 3
add rax, rbp
; lets get to rdx the src to copy
mov rdx, [rsp + WORD_SIZE * 2]
mov r10, rdx
add rdx, 2
shl rdx, 3
add rdx, rsp
; lets get to rcx the number of iterations needed
lea rcx, [r10 + 3]
copy_stack639:

mov r11, [rdx]
mov [rax], r11
sub rax, 8
sub rdx, 8
loop copy_stack639
add rax, 8
mov rsp, rax
mov rbp, r9
jmp rbx
 Lexit640: 
leave
ret
Lcont592: 

push rax
;parameter variable:
mov rax, [rbp + WORD_SIZE * (4 + 0)]

pop rbx
mov qword [rax], rbx
;box get:
;parameter variable:
mov rax, [rbp + WORD_SIZE * (4 + 0)]

mov qword rax, [rax]



leave
ret
Lcont586: 

;assuming we get correct input, no need to check type closure 
add rax, TYPE_SIZE 
mov rbx, [rax] ;rbx contains pointer to env
push rbx      ;push env pointer
add rax, WORD_SIZE 
mov rbx, [rax] ;rbx contains pointer to code ; (rbx contains pointer to code)
;------------------------changes in opt - do not use rbx ---------------------
push qword [rbp + WORD_SIZE ] ; push old ret addr
; lets get to rax the dst to copy
mov rax, [rbp + WORD_SIZE * 3]
mov r9, [rbp]
add rax, 3
shl rax, 3
add rax, rbp
; lets get to rdx the src to copy
mov rdx, [rsp + WORD_SIZE * 2]
mov r10, rdx
add rdx, 2
shl rdx, 3
add rdx, rsp
; lets get to rcx the number of iterations needed
lea rcx, [r10 + 3]
copy_stack580:

mov r11, [rdx]
mov [rax], r11
sub rax, 8
sub rdx, 8
loop copy_stack580
add rax, 8
mov rsp, rax
mov rbp, r9
jmp rbx
leave
ret
Lcont579: 

;back to applic: applic573
;assuming we get correct input, no need to check type closure 
CLOSURE_ENV rbx, rax ;rbx contains pointer to env
push rbx      ;push env pointer
CLOSURE_CODE rbx, rax 
call rbx
;clean stack
add rsp, WORD_SIZE *1 ; pop env
pop rbx               ; pop arg count
shl rbx, 3            ; rbx = rbx * 8
add rbx, WORD_SIZE    ; clean magic
add rsp, rbx          ; pop args
mov [fvar_tbl + 45 * WORD_SIZE], rax 
 lea rax, [const_tbl+1] 

	call write_sob_if_not_void

some_compiled_section658:
;define:
; , x
; lambda optional: 
mov rbx, 0
shl rbx, 3
MALLOC rax, rbx
push rax ; pushing ext_env for later 
;copying pointers:
mov rcx, 0
cmp rcx, 1
jle end_pointers_copy644
copy_pointers642:
push rcx
neg rcx
add rcx, 0
mov rbx, [rbp + WORD_SIZE * 2] ; getting pointer to old env
mov rdx, [rbx + rcx * WORD_SIZE] ; getting to rdx old_env[i]
inc rcx
mov [rax + WORD_SIZE * rcx], rdx ; putting env[i] (stored in rdx) into ext_env[i + 1]
pop rcx ; restoring counter
loop copy_pointers642
end_pointers_copy644:
mov rcx, [rbp + 3 * WORD_SIZE] ; getting to rcx the number of the current parameters 
inc rcx
shl rcx, 3
MALLOC rbx, rcx
mov qword [rax], rbx ; getting the new allocated memory pointer to ext_env[0]
mov rax, rbx ; more convinient with pointer to extenv[0] in rax 

mov rbx, rcx ; rbx will be constant and hold the size of params
; copying parameters to new env 
cmp rbx, 0
je end_parameters_copy645
copy_parameters643: 
push rcx
neg rcx
add rcx, rbx ; rcx starts high and decreases with iterations
lea rdx, [rbp + WORD_SIZE * rcx]
add rdx, 4 * WORD_SIZE ; now rdx has the address of param_i 
mov rdx, [rdx] ; now rdx has the param_i 
mov [rax + WORD_SIZE * rcx], rdx 
pop rcx
loop copy_parameters643
end_parameters_copy645:
pop rbx
MAKE_CLOSURE(rax, rbx, Lcode646)
jmp Lcont647
Lcode646: 
push rbp
mov rbp, rsp
mov rax, [rbp + WORD_SIZE * 3] ; rax <- n 
cmp rax, 1; n =? |must|
jne opt_list_creation649
lea rbx, [rbp + WORD_SIZE * (rax + 4)] ; magic <- Nil
mov qword [rbx], const_tbl
jmp actual_code648
opt_list_creation649:
mov rbx, const_tbl
dec rax ; rax <- n - 1
make_list_loop650: ; create list loop 
mov rcx, [rbp + WORD_SIZE * (4 + rax)] ; rcx <- params[i]
MAKE_PAIR(rdx, rcx, rbx)
mov rbx, rdx
dec rax
cmp rax, 1
jge make_list_loop650
mov rax, [rbp + WORD_SIZE * 3]
dec rax; rax <- n - 1
mov [rbp + WORD_SIZE * (4 + rax)], rbx; save optional list on the stack
sub rax, 1 ; constant rax <- n - 1 - |must| (offset to move)
jz actual_code648
lea rcx, [4 + 1] ; i <- must_length + 4 
stack_reduction651:

push rcx
dec rcx
mov rbx, [rbp + WORD_SIZE * rcx]
add rcx, rax
mov [rbp + WORD_SIZE * rcx], rbx
pop rcx
loop stack_reduction651
lea rsp, [rsp + WORD_SIZE * rax]
mov rbp, rsp
mov qword [rbp + WORD_SIZE * 3], 1
actual_code648:
;simple lambda:
mov rbx, 1
shl rbx, 3
MALLOC rax, rbx
push rax; pushing ext_env for later 
;copying pointers:
mov rcx, 1
cmp rcx, 1
jle end_pointers_copy654
copy_pointers652:
push rcx
neg rcx
add rcx, 1
mov rbx, [rbp + WORD_SIZE * 2] ; getting pointer to old env
mov rdx, [rbx + rcx * WORD_SIZE] ; getting to rdx old_env[i]
inc rcx
mov [rax + WORD_SIZE * rcx], rdx ; putting env[i] (stored in rdx) into ext_env[i + 1]
pop rcx ; restoring counter
loop copy_pointers652
end_pointers_copy654:
mov rcx, [rbp + 3 * WORD_SIZE] ; getting to rcx the number of the current parameters 
inc rcx
shl rcx, 3
MALLOC rbx, rcx
mov qword [rax], rbx ; getting the new allocated memory pointer to ext_env[0]
mov rax, rbx ; more convinient with pointer to extenv[0] in rax 

mov rbx, rcx ; rbx will be constant and hold the size of params
; copying parameters to new env 
cmp rbx, 0
je end_parameters_copy655
copy_parameters653: 
push rcx
neg rcx
add rcx, rbx ; rcx starts high and decreases with iterations
lea rdx, [rbp + WORD_SIZE * rcx]
add rdx, 4 * WORD_SIZE ; now rdx has the address of param_i 
mov rdx, [rdx] ; now rdx has the param_i 
mov [rax + WORD_SIZE * rcx], rdx 
pop rcx
loop copy_parameters653
end_parameters_copy655:
pop rbx
MAKE_CLOSURE(rax, rbx, Lcode656)
jmp Lcont657
Lcode656: 
push rbp
mov rbp, rsp
;bound variable:
mov rbx, [rbp + WORD_SIZE * 2]
mov rbx, [rbx + WORD_SIZE * 0]
mov rax, [rbx + WORD_SIZE * 1]

leave
ret
Lcont657: 

leave
ret
Lcont647: 
mov [fvar_tbl + 49 * WORD_SIZE], rax 
 lea rax, [const_tbl+1] 

	call write_sob_if_not_void

some_compiled_section661:
;applic:applic659
;push magic:
mov rbx, 0
push rbx
;constant
lea rax, [const_tbl+ 52]

push rax
;back to applic: applic659
;push num of args: 
mov rbx,1
push rbx
;generate proc:
;applic:applic660
;push magic:
mov rbx, 0
push rbx
;constant
lea rax, [const_tbl+ 41]

push rax
;back to applic: applic660
;push num of args: 
mov rbx,1
push rbx
;generate proc:
;free variable:
mov rax, qword [fvar_tbl + 49 * WORD_SIZE]

;back to applic: applic660
;assuming we get correct input, no need to check type closure 
CLOSURE_ENV rbx, rax ;rbx contains pointer to env
push rbx      ;push env pointer
CLOSURE_CODE rbx, rax 
call rbx
;clean stack
add rsp, WORD_SIZE *1 ; pop env
pop rbx               ; pop arg count
shl rbx, 3            ; rbx = rbx * 8
add rbx, WORD_SIZE    ; clean magic
add rsp, rbx          ; pop args

;back to applic: applic659
;assuming we get correct input, no need to check type closure 
CLOSURE_ENV rbx, rax ;rbx contains pointer to env
push rbx      ;push env pointer
CLOSURE_CODE rbx, rax 
call rbx
;clean stack
add rsp, WORD_SIZE *1 ; pop env
pop rbx               ; pop arg count
shl rbx, 3            ; rbx = rbx * 8
add rbx, WORD_SIZE    ; clean magic
add rsp, rbx          ; pop args

	call write_sob_if_not_void

	mov rax, 0
	add rsp, 4*8
	pop rbp
	ret


car_:
    push rbp
    mov rbp, rsp

    mov rbx, PVAR(0) 
    CAR rax,rbx

    leave
    ret

cdr_:
    push rbp
    mov rbp, rsp

    mov rbx, PVAR(0) 
    CDR rax,rbx
    
    leave
    ret

apply_:
    mov r10, rsp ; lets save the initial rsp in r10
    mov r13, [r10 + 3 * WORD_SIZE] ; closure pointer
    ; now we want to check the size of the list
    xor rcx, rcx ; counter <- 0
    mov r9, [r10 + 2 * WORD_SIZE] ; r9 <- old n
    mov rax, [r10 + WORD_SIZE * (r9 + 2)] ; rax <- pointer to list
    
    cmp byte [rax], T_NIL ; lets check if its null
    je .counted_list
    mov rbx, rax
    .count_list_loop:
    inc rcx ; count++
    CDR rbx, rbx ; lets get to rbx the cdr
    cmp byte [rbx], T_NIL
    jne .count_list_loop

    .counted_list:
    ; lets take a minute to calculate the new n :)))
    mov r12, rcx
    add r12, r9
    sub r12, 2

    cmp rcx, 0
    je .list_is_on_stack
    shl rcx, 3
    sub rsp, rcx
    shr rcx, 3
    mov r8, rsp ; r8 <- dst to copy list

    .copy_list_to_stack:
    CAR rbx, rax ; lets get next element to rbx
    mov [r8], rbx
    add r8, WORD_SIZE
    CDR rax, rax
    loop .copy_list_to_stack

    .list_is_on_stack:
    lea rax, [r10 + WORD_SIZE * (r9 + 1)] ; lets save in rax the pointer to the top most argument to push
    mov rcx, r9 ; old n
    sub rcx, 2 ; number of things to push
    .push_loop:
    push qword [rax]
    sub rax, WORD_SIZE
    loop .push_loop
    
    push r12 ; push the new n
    
    ; lets get the env
    mov rax, [r10 + WORD_SIZE * 3]
    CLOSURE_ENV rax, rax
    
    push rax

    ; lets push the ret address

    push qword [r10]


    ; here we have the new stack under the old stack and we want to use mmap to ride over the old stack
    ; lets get edi <- dst, esi <- src, rdx <- size

    mov r11, r10 ; initial stack pointer
    sub r11, rsp ; this is the size of the new stack
    mov rdx, r11

    lea rdi, [r10 + WORD_SIZE * (r9 + 3)] ; lets get to rdi the address of the end of old_stack (actually this is the pointer to the magic)
    sub rdi, r11

    mov rsi, rsp

    mov rax, 0
    push qword r13 ; closure pointer

    call memmove
        
    pop rbx ; closure pointer
    
    mov rsp, rax

    ; lets get code of the proc
    CLOSURE_CODE rbx, rbx
    jmp rbx

cons_:
    push rbp
    mov rbp, rsp

    mov rbx, PVAR(0)
    mov rcx, PVAR(1) 
    MAKE_PAIR(rax, rbx, rcx)
    
    leave
    ret

set_car:
    push rbp
    mov rbp, rsp

    mov rbx, PVAR(0)
    mov rcx, PVAR(1)
    mov LOWER_DATA(rbx) , rcx
    mov rax, SOB_VOID_ADDRESS

    leave
    ret

set_cdr:
    push rbp
    mov rbp, rsp

    mov rbx, PVAR(0)
    mov rcx, PVAR(1)
    mov UPPER_DATA(rbx) , rcx
    mov rax, SOB_VOID_ADDRESS

    leave
    ret

is_boolean:
    push rbp
    mov rbp, rsp

    mov rsi, PVAR(0)
    mov sil, byte [rsi]

    cmp sil, T_BOOL
    jne .wrong_type
    mov rax, SOB_TRUE_ADDRESS
    jmp .return

.wrong_type:
    mov rax, SOB_FALSE_ADDRESS
.return:
    leave
    ret

is_float:
    push rbp
    mov rbp, rsp

    mov rsi, PVAR(0)
    mov sil, byte [rsi]

    cmp sil, T_FLOAT
    jne .wrong_type
    mov rax, SOB_TRUE_ADDRESS
    jmp .return

.wrong_type:
    mov rax, SOB_FALSE_ADDRESS
.return:
    leave
    ret

is_integer:
    push rbp
    mov rbp, rsp

    mov rsi, PVAR(0)
    mov sil, byte [rsi]

    cmp sil, T_INTEGER
    jne .wrong_type
    mov rax, SOB_TRUE_ADDRESS
    jmp .return

.wrong_type:
    mov rax, SOB_FALSE_ADDRESS
.return:
    leave
    ret

is_pair:
    push rbp
    mov rbp, rsp

    mov rsi, PVAR(0)
    mov sil, byte [rsi]

    cmp sil, T_PAIR
    jne .wrong_type
    mov rax, SOB_TRUE_ADDRESS
    jmp .return

.wrong_type:
    mov rax, SOB_FALSE_ADDRESS
.return:
    leave
    ret

is_null:
    push rbp
    mov rbp, rsp

    mov rsi, PVAR(0)
    mov sil, byte [rsi]

    cmp sil, T_NIL
    jne .wrong_type
    mov rax, SOB_TRUE_ADDRESS
    jmp .return

.wrong_type:
    mov rax, SOB_FALSE_ADDRESS
.return:
    leave
    ret

is_char:
    push rbp
    mov rbp, rsp

    mov rsi, PVAR(0)
    mov sil, byte [rsi]

    cmp sil, T_CHAR
    jne .wrong_type
    mov rax, SOB_TRUE_ADDRESS
    jmp .return

.wrong_type:
    mov rax, SOB_FALSE_ADDRESS
.return:
    leave
    ret

is_string:
    push rbp
    mov rbp, rsp

    mov rsi, PVAR(0)
    mov sil, byte [rsi]

    cmp sil, T_STRING
    jne .wrong_type
    mov rax, SOB_TRUE_ADDRESS
    jmp .return

.wrong_type:
    mov rax, SOB_FALSE_ADDRESS
.return:
    leave
    ret

is_procedure:
    push rbp
    mov rbp, rsp

    mov rsi, PVAR(0)
    mov sil, byte [rsi]

    cmp sil, T_CLOSURE
    jne .wrong_type
    mov rax, SOB_TRUE_ADDRESS
    jmp .return

.wrong_type:
    mov rax, SOB_FALSE_ADDRESS
.return:
    leave
    ret

is_symbol:
    push rbp
    mov rbp, rsp

    mov rsi, PVAR(0)
    mov sil, byte [rsi]

    cmp sil, T_SYMBOL
    jne .wrong_type
    mov rax, SOB_TRUE_ADDRESS
    jmp .return

.wrong_type:
    mov rax, SOB_FALSE_ADDRESS
.return:
    leave
    ret

string_length:
    push rbp
    mov rbp, rsp

    mov rsi, PVAR(0)
    STRING_LENGTH rsi, rsi
    MAKE_INT(rax, rsi)

    leave
    ret

string_ref:
    push rbp
    mov rbp, rsp

    mov rsi, PVAR(0) 
    STRING_ELEMENTS rsi, rsi
    mov rdi, PVAR(1)
    INT_VAL rdi, rdi
    shl rdi, 0
    add rsi, rdi

    mov sil, byte [rsi]
    MAKE_CHAR(rax, sil)

    leave
    ret

string_set:
    push rbp
    mov rbp, rsp

    mov rsi, PVAR(0) 
    STRING_ELEMENTS rsi, rsi
    mov rdi, PVAR(1)
    INT_VAL rdi, rdi
    shl rdi, 0
    add rsi, rdi

    mov rax, PVAR(2)
    CHAR_VAL rax, rax
    mov byte [rsi], al
    mov rax, SOB_VOID_ADDRESS

    leave
    ret

make_string:
    push rbp
    mov rbp, rsp

    
    mov rsi, PVAR(0)
    INT_VAL rsi, rsi
    mov rdi, PVAR(1)
    CHAR_VAL rdi, rdi
    and rdi, 255

    MAKE_STRING rax, rsi, dil

    leave
    ret

symbol_to_string:
    push rbp
    mov rbp, rsp

    
    mov rsi, PVAR(0)
    SYMBOL_VAL rsi, rsi
    
    STRING_LENGTH rcx, rsi
    STRING_ELEMENTS rdi, rsi

    push rcx
    push rdi

    mov dil, byte [rdi]
    MAKE_CHAR(rax, dil)
    push rax
    MAKE_INT(rax, rcx)
    push rax
    push 2
    push SOB_NIL_ADDRESS
    call make_string
    add rsp, 4*8

    STRING_ELEMENTS rsi, rax

    pop rdi
    pop rcx

    cmp rcx, 0
    je .end
	
.loop:
    lea r8, [rdi+rcx]
    lea r9, [rsi+rcx]

    mov bl, byte [r8]
    mov byte [r9], bl
    
    loop .loop
.end:

    leave
    ret

char_to_integer:
    push rbp
    mov rbp, rsp

    
    mov rsi, PVAR(0)
    CHAR_VAL rsi, rsi
    and rsi, 255
    MAKE_INT(rax, rsi)

    leave
    ret

integer_to_char:
    push rbp
    mov rbp, rsp

    
    mov rsi, PVAR(0)
    INT_VAL rsi, rsi
    and rsi, 255
    MAKE_CHAR(rax, sil)

    leave
    ret

is_eq:
    push rbp
    mov rbp, rsp

    
    mov rsi, PVAR(0)
    mov rdi, PVAR(1)
    cmp rsi, rdi
    je .true
    mov rax, SOB_FALSE_ADDRESS
    jmp .return

.true:
    mov rax, SOB_TRUE_ADDRESS

.return:
    leave
    ret

bin_add:
    push rbp
    mov rbp, rsp

    mov r8, 0

    mov rsi, PVAR(0)
    push rsi
    push 1
    push SOB_NIL_ADDRESS
    call is_float
    add rsp, 3*WORD_SIZE 


    cmp rax, SOB_TRUE_ADDRESS
    je .test_next
    or r8, 1

.test_next:

    mov rsi, PVAR(1)
    push rsi
    push 1
    push SOB_NIL_ADDRESS
    call is_float
    add rsp, 3*WORD_SIZE 


    cmp rax, SOB_TRUE_ADDRESS
    je .load_numbers
    or r8, 2

.load_numbers:
    push r8

    shr r8, 1
    jc .first_arg_int
    mov rsi, PVAR(0)
    FLOAT_VAL rsi, rsi 
    movq xmm0, rsi
    jmp .load_next_float

.first_arg_int:
    mov rsi, PVAR(0)
    INT_VAL rsi, rsi
    cvtsi2sd xmm0, rsi

.load_next_float:
    shr r8, 1
    jc .second_arg_int
    mov rsi, PVAR(1)
    FLOAT_VAL rsi, rsi
    movq xmm1, rsi
    jmp .perform_float_op

.second_arg_int:
    mov rsi, PVAR(1)
    INT_VAL rsi, rsi
    cvtsi2sd xmm1, rsi

.perform_float_op:
    addsd xmm0, xmm1

    pop r8
    cmp r8, 3
    jne .return_float

    cvttsd2si rsi, xmm0
    MAKE_INT(rax, rsi)
    jmp .return

.return_float:
    movq rsi, xmm0
    MAKE_FLOAT(rax, rsi)

.return:

    leave
    ret

bin_mul:
    push rbp
    mov rbp, rsp

    mov r8, 0

    mov rsi, PVAR(0)
    push rsi
    push 1
    push SOB_NIL_ADDRESS
    call is_float
    add rsp, 3*WORD_SIZE 


    cmp rax, SOB_TRUE_ADDRESS
    je .test_next
    or r8, 1

.test_next:

    mov rsi, PVAR(1)
    push rsi
    push 1
    push SOB_NIL_ADDRESS
    call is_float
    add rsp, 3*WORD_SIZE 


    cmp rax, SOB_TRUE_ADDRESS
    je .load_numbers
    or r8, 2

.load_numbers:
    push r8

    shr r8, 1
    jc .first_arg_int
    mov rsi, PVAR(0)
    FLOAT_VAL rsi, rsi 
    movq xmm0, rsi
    jmp .load_next_float

.first_arg_int:
    mov rsi, PVAR(0)
    INT_VAL rsi, rsi
    cvtsi2sd xmm0, rsi

.load_next_float:
    shr r8, 1
    jc .second_arg_int
    mov rsi, PVAR(1)
    FLOAT_VAL rsi, rsi
    movq xmm1, rsi
    jmp .perform_float_op

.second_arg_int:
    mov rsi, PVAR(1)
    INT_VAL rsi, rsi
    cvtsi2sd xmm1, rsi

.perform_float_op:
    mulsd xmm0, xmm1

    pop r8
    cmp r8, 3
    jne .return_float

    cvttsd2si rsi, xmm0
    MAKE_INT(rax, rsi)
    jmp .return

.return_float:
    movq rsi, xmm0
    MAKE_FLOAT(rax, rsi)

.return:

    leave
    ret

bin_sub:
    push rbp
    mov rbp, rsp

    mov r8, 0

    mov rsi, PVAR(0)
    push rsi
    push 1
    push SOB_NIL_ADDRESS
    call is_float
    add rsp, 3*WORD_SIZE 


    cmp rax, SOB_TRUE_ADDRESS
    je .test_next
    or r8, 1

.test_next:

    mov rsi, PVAR(1)
    push rsi
    push 1
    push SOB_NIL_ADDRESS
    call is_float
    add rsp, 3*WORD_SIZE 


    cmp rax, SOB_TRUE_ADDRESS
    je .load_numbers
    or r8, 2

.load_numbers:
    push r8

    shr r8, 1
    jc .first_arg_int
    mov rsi, PVAR(0)
    FLOAT_VAL rsi, rsi 
    movq xmm0, rsi
    jmp .load_next_float

.first_arg_int:
    mov rsi, PVAR(0)
    INT_VAL rsi, rsi
    cvtsi2sd xmm0, rsi

.load_next_float:
    shr r8, 1
    jc .second_arg_int
    mov rsi, PVAR(1)
    FLOAT_VAL rsi, rsi
    movq xmm1, rsi
    jmp .perform_float_op

.second_arg_int:
    mov rsi, PVAR(1)
    INT_VAL rsi, rsi
    cvtsi2sd xmm1, rsi

.perform_float_op:
    subsd xmm0, xmm1

    pop r8
    cmp r8, 3
    jne .return_float

    cvttsd2si rsi, xmm0
    MAKE_INT(rax, rsi)
    jmp .return

.return_float:
    movq rsi, xmm0
    MAKE_FLOAT(rax, rsi)

.return:

    leave
    ret

bin_div:
    push rbp
    mov rbp, rsp

    mov r8, 0

    mov rsi, PVAR(0)
    push rsi
    push 1
    push SOB_NIL_ADDRESS
    call is_float
    add rsp, 3*WORD_SIZE 


    cmp rax, SOB_TRUE_ADDRESS
    je .test_next
    or r8, 1

.test_next:

    mov rsi, PVAR(1)
    push rsi
    push 1
    push SOB_NIL_ADDRESS
    call is_float
    add rsp, 3*WORD_SIZE 


    cmp rax, SOB_TRUE_ADDRESS
    je .load_numbers
    or r8, 2

.load_numbers:
    push r8

    shr r8, 1
    jc .first_arg_int
    mov rsi, PVAR(0)
    FLOAT_VAL rsi, rsi 
    movq xmm0, rsi
    jmp .load_next_float

.first_arg_int:
    mov rsi, PVAR(0)
    INT_VAL rsi, rsi
    cvtsi2sd xmm0, rsi

.load_next_float:
    shr r8, 1
    jc .second_arg_int
    mov rsi, PVAR(1)
    FLOAT_VAL rsi, rsi
    movq xmm1, rsi
    jmp .perform_float_op

.second_arg_int:
    mov rsi, PVAR(1)
    INT_VAL rsi, rsi
    cvtsi2sd xmm1, rsi

.perform_float_op:
    divsd xmm0, xmm1

    pop r8
    cmp r8, 3
    jne .return_float

    cvttsd2si rsi, xmm0
    MAKE_INT(rax, rsi)
    jmp .return

.return_float:
    movq rsi, xmm0
    MAKE_FLOAT(rax, rsi)

.return:

    leave
    ret

bin_lt:
    push rbp
    mov rbp, rsp

    mov r8, 0

    mov rsi, PVAR(0)
    push rsi
    push 1
    push SOB_NIL_ADDRESS
    call is_float
    add rsp, 3*WORD_SIZE 


    cmp rax, SOB_TRUE_ADDRESS
    je .test_next
    or r8, 1

.test_next:

    mov rsi, PVAR(1)
    push rsi
    push 1
    push SOB_NIL_ADDRESS
    call is_float
    add rsp, 3*WORD_SIZE 


    cmp rax, SOB_TRUE_ADDRESS
    je .load_numbers
    or r8, 2

.load_numbers:
    push r8

    shr r8, 1
    jc .first_arg_int
    mov rsi, PVAR(0)
    FLOAT_VAL rsi, rsi 
    movq xmm0, rsi
    jmp .load_next_float

.first_arg_int:
    mov rsi, PVAR(0)
    INT_VAL rsi, rsi
    cvtsi2sd xmm0, rsi

.load_next_float:
    shr r8, 1
    jc .second_arg_int
    mov rsi, PVAR(1)
    FLOAT_VAL rsi, rsi
    movq xmm1, rsi
    jmp .perform_float_op

.second_arg_int:
    mov rsi, PVAR(1)
    INT_VAL rsi, rsi
    cvtsi2sd xmm1, rsi

.perform_float_op:
    cmpltsd xmm0, xmm1

    pop r8
    cmp r8, 3
    jne .return_float

    cvttsd2si rsi, xmm0
    MAKE_INT(rax, rsi)
    jmp .return

.return_float:
    movq rsi, xmm0
    MAKE_FLOAT(rax, rsi)

.return:

    INT_VAL rsi, rax
    cmp rsi, 0
    je .return_false
    mov rax, SOB_TRUE_ADDRESS
    jmp .final_return

.return_false:
    mov rax, SOB_FALSE_ADDRESS

.final_return:


    leave
    ret

bin_equ:
    push rbp
    mov rbp, rsp

    mov r8, 0

    mov rsi, PVAR(0)
    push rsi
    push 1
    push SOB_NIL_ADDRESS
    call is_float
    add rsp, 3*WORD_SIZE 


    cmp rax, SOB_TRUE_ADDRESS
    je .test_next
    or r8, 1

.test_next:

    mov rsi, PVAR(1)
    push rsi
    push 1
    push SOB_NIL_ADDRESS
    call is_float
    add rsp, 3*WORD_SIZE 


    cmp rax, SOB_TRUE_ADDRESS
    je .load_numbers
    or r8, 2

.load_numbers:
    push r8

    shr r8, 1
    jc .first_arg_int
    mov rsi, PVAR(0)
    FLOAT_VAL rsi, rsi 
    movq xmm0, rsi
    jmp .load_next_float

.first_arg_int:
    mov rsi, PVAR(0)
    INT_VAL rsi, rsi
    cvtsi2sd xmm0, rsi

.load_next_float:
    shr r8, 1
    jc .second_arg_int
    mov rsi, PVAR(1)
    FLOAT_VAL rsi, rsi
    movq xmm1, rsi
    jmp .perform_float_op

.second_arg_int:
    mov rsi, PVAR(1)
    INT_VAL rsi, rsi
    cvtsi2sd xmm1, rsi

.perform_float_op:
    cmpeqsd xmm0, xmm1

    pop r8
    cmp r8, 3
    jne .return_float

    cvttsd2si rsi, xmm0
    MAKE_INT(rax, rsi)
    jmp .return

.return_float:
    movq rsi, xmm0
    MAKE_FLOAT(rax, rsi)

.return:

    INT_VAL rsi, rax
    cmp rsi, 0
    je .return_false
    mov rax, SOB_TRUE_ADDRESS
    jmp .final_return

.return_false:
    mov rax, SOB_FALSE_ADDRESS

.final_return:


    leave
    ret


